---
tags:
  - 题解
  - 计算几何/旋转卡壳
aliases:
  - Concave Hull
---
## [gym105459B. Concave Hull](https://codeforces.com/gym/105459/problem/B)

一个比较显然的想法是先求凸包，然后选一条边凹进去。
对于凸包上的每一条边，答案是原来凸包的面积减去凹进去的小三角形的面积，为了凹进去的面积最小，要选择凸包内部离这条边最近的点。
根据调整法可知：离外层凸包上的边最近的点一定在内层凸包上，否则必然可以移动到内层凸包的边上使答案更小。
因此求出两层凸包，枚举外层凸包的每一条边，然后旋转卡尺求出内层凸包上最近的点即可。
时间复杂度 $O(n)$
注意特判内部点数量小于等于 $2$（无法形成凸包）的情况，可能会死循环。

[***AC 代码***](https://codeforces.com/gym/105459/submission/342871310)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;

const db eps = 1e-8;
int sgn(auto x) {
    return (x > eps) - (x < -eps);
}

using T = ll;
struct Point {
    T x, y;
    Point(T x = 0, T y = 0) : x(x), y(y) {
    }
    db ang() {
        return atan2(y, x);
    }
    friend istream &operator>>(istream &is, Point &p) {
        return is >> p.x >> p.y;
    }
    friend ostream &operator<<(ostream &os, Point &p) {
        return os << "( " << p.x << ", " << p.y << " )";
    }
    bool operator==(const Point &p) const {
        return sgn(x - p.x) == 0 && sgn(y - p.y) == 0;
    }
    bool operator<(const Point &p) const {
        return x < p.x || (x == p.x && y < p.y);
    }
    Point operator+(const Point &p) const {
        return Point(x + p.x, y + p.y);
    }
    Point operator-(const Point &p) const {
        return Point(x - p.x, y - p.y);
    }
    Point operator*(const T &k) const {
        return Point(k * x, k * y);
    }
    Point operator/(const T &k) const {
        return Point(x / k, y / k);
    }
    T operator*(const Point &p) const {
        return x * p.x + y * p.y;
    }
    T operator^(const Point &p) const {
        return x * p.y - y * p.x;
    }
    T len2() {
        return (*this) * (*this);
    }
    db len() {
        return sqrtl(len2());
    }
    Point rot(const db &ang) {
        return Point(x * cos(ang) - y * sin(ang), x * sin(ang) + y * cos(ang));
    }
    Point trunc(const db &l) {
        return (*this) * (l / len());
    }
};

vector<Point> toConvex(vector<Point> &ori) {
    const int n = ori.size();
    if (n <= 2) {
        return {};
    }
    vector<Point> p = ori;
    sort(p.begin(), p.end());
    vector<Point> st;
    st.reserve(n + 1);

    auto check = [&](Point u) {
        const auto p1 = st.back();
        const auto p2 = *prev(st.end(), 2);
        return sgn((p1 - p2) ^ (u - p1)) <= 0;
    };
    // 上凸壳
    for (const auto &u : p) {
        while (st.size() > 1 && check(u)) {
            st.pop_back();
        }
        st.push_back(u);
    }
    // 下凸壳
    size_t k = st.size();
    p.pop_back();
    reverse(p.begin(), p.end());
    for (const Point &u : p) {
        while (st.size() > k && check(u)) {
            st.pop_back();
        }
        st.push_back(u);
    }
    st.pop_back();

    // 筛选不在凸包上的点
    vector<Point> r;
    set<Point> h(st.begin(), st.end());
    for (const auto &u : ori) {
        if (!h.count(u)) {
            r.push_back(u);
        }
    }
    ori = move(st);
    return r;
}

T area(const vector<Point> &p) {
    T s = 0;
    int n = p.size();
    for (size_t i = 0; i < n; ++i) {
        s += (p[i] ^ p[(i + 1) % n]);
    }
    return abs(s);
}

void solve() {
    int n;
    cin >> n;
    vector<Point> p(n);
    for (auto &u : p) {
        cin >> u;
    }
    vector<Point> r = toConvex(p);
    n = p.size();
    if (r.empty()) {
        cout << "-1\n";
        return;
    }
    ll S = area(p);
    ll ans = 0;

    if (r.size() <= 2) {
        for (const auto &u: r) {
            for (int i = 0; i < n; ++i) {
                const auto p1 = p[i];
                const auto p2 = p[(i + 1) % n];
                ans = max(ans, S - abs((p1-p2)^(u-p1)));
            }
        }
    } else {
        toConvex(r);
        int siz = r.size();
        for (int i = 0, j = 0; i < n; ++i) {
            auto area = [&](Point a) {
                return abs((p[i] - p[(i + 1) % n]) ^ (p[i] - a));
            };
            ans = max(ans, S - area(r[j]));
            while (area(r[j]) >= area(r[(j + 1) % siz])) {
                j = (j + 1) % siz;
                ans = max(ans, S - area(r[j]));
            }
        }
    }

    cout << ans << "\n";
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
```
