---
tags:
  - 题解
  - DP
aliases:
  - Ice Baby
---
## [CF2121H. Ice Baby](https://codeforces.com/problemset/problem/2121/H)

回忆一种最长上升子序列的反表示做法。核心思路是用一个序列存储所有长度非降子序列的末尾最小值。
设 $dp(i,j)$ 表示前 $i$ 个数，LIS 长度为 $j$ 时末尾数字最小是多少。现在 $a_i\in[L_i,R_i]$，考虑转移方程
$$
dp(i,j)=
\begin{cases}
dp(i-1,j) & dp(i-1,j)<L_i \\
\max(L_i, dp(i-1,j-1)) & dp(i-1,j-1)\le R_i \\
dp(i-1,j) & dp(i-1,j-1)>R_i
\end{cases}
$$
第一和第三种状态转移只需要从 $dp(i-1)$ 继承就可以了。
第二种转移是把第一个 $dp(i-1)\ge L_i$ 的位置变成 $L_i$，所有位置往后移一位，然后删除第一个大于 $R_i$ 的数
由于 $dp(i)$ 是一个单调不减的序列，我们只需要使用一个 `multiset` 维护有哪些数字就可以了，最终答案为 `multiset` 的大小。时间复杂度 $O(n\log n)$

[***AC 代码***](https://codeforces.com/contest/2121/submission/332299698)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

void solve()
{
    int n;
    cin >> n;
    
    multiset<int> f;
    for (int i = 1; i <= n; ++i) {
        int l, r;
        cin >> l >> r;
        auto it = f.upper_bound(r);
        if (it != f.end()) { f.erase(it); }
        f.insert(l);
        cout << f.size() << " ";
    }
    cout << "\n";
}


int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int t = 1;
    cin >> t;
    while (t--) { solve(); }
}
```
