---
tags:
  - 题解
  - 拆分数
aliases:
  - 序列
---
## [gym105992A. 序列](https://codeforces.com/gym/105992/problem/A)

先考虑 $g(a)$ 怎么算。记一共有 $n$ 个数，枚举每一种颜色 $c$，考虑有多少子序列包含颜色 $c$，即
$$
\sum_{i=1}^{n}2^{n-cnt_c}\times (2^{cnt_c}-1)
$$
将这个式子展开为
$$
\sum_{i=1}^{n}2^n\times(1-2^{-cnt_c})
$$
接下来求 $f(x)=1-2^{-x}$ 的取值范围
$f''(x)=-2^{-x}\ln^2(2)<0$，是一个上凸函数，在小的地方增长较快。感性认知一下，让大的数减一，小的数加一，会让整体的和变大。即：当 $cnt_c$ 全为 $1$ 时取得最大值，有一个 $n$ 其他全为 $0$ 时取得最小值。取值范围为 $[2^n-1,\ n\times 2^{n-1}]$，因此 $n\le \log x$。
序列具体的取值是不重要的，只有 $cnt_c$ 是重要的，这个问题是经典的拆分数，枚举只需要枚举大概 $60$ 就可以了。

[***AC 代码***](https://codeforces.com/gym/105992/submission/336569221)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

const int N=60;
ll req;
int tot, cnt[N+5];
bool dfs(int u, int n, i128 s) {
    if (n == 0) {
        if (s == req) {
            cout << "Yes\n";
            cout << tot << "\n";
            for (int i = 1; i < u; ++i) {
                for (int j = 1; j <= cnt[i]; ++j) { cout << i << " "; }
            }
            cout << "\n";
            return true;
        } else {
            return false;
        }
    }
    bool done = false;
    for (cnt[u] = cnt[u-1]; cnt[u] <= n && !done; ++cnt[u]) {
        i128 f = ((1LL << cnt[u]) - 1) * (1LL << (tot - cnt[u]));
        if (s + f > req) { continue; }
        done |= dfs(u+1, n-cnt[u], s + f);
    }
    return done;
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cnt[0] = 1;
    cin >> req;
    bool done = false;
    for (tot = 1; tot <= N && !done; ++tot) {
        done |= dfs(1, tot, 0);
    }
    if (!done) {
        cout << "No\n";
    }
}
```
