---
tags:
  - 题解
  - DP/数位DP
aliases:
  - 烦人的数学作业
---
## [P4999 烦人的数学作业](https://www.luogu.com.cn/problem/P4999)

设 $f(p,s)$ 表示已经填了 $[p,len]$，所填数字未达上限且和为 $s$ 时后续填数答案的总和。
从 $f(len,0)$ 开始记忆化搜索，对于每个长度 $l$，$[l,len]$ 只有一种按上限填数的方案，未被记忆的状态数至多只有 $O(len)$，总状态数 $O(len\times(len\times 9))$

[***AC 代码***](https://www.luogu.com.cn/record/226189394)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

const int MOD = 1e9+7;
ll add(ll x, ll y) { return (x + y) % MOD; }
ll del(ll x, ll y) { return add(x, MOD-y); }
ll mul(ll x, ll y) { return (x * y) % MOD; }

const int L = 18, S = 9 * L;
int a[L+5];
ll f[L+5][S+5];
ll dfs(int p, bool limit, int sum)
{
    if (p == 0) {
        return sum;
    }
    if (!limit && ~f[p][sum]) {
        return f[p][sum];
    }
    int up = limit ? a[p] : 9;
    ll res = 0;
    for (int i = 0; i <= up; ++i) {
        res = add(res, dfs(p-1, limit && i==up, sum+i));
    }
    if (!limit) {
        f[p][sum] = res;
    }
    return res;
}

ll query(ll x) 
{
    int len = 0;
    for (; x; x /= 10) {
        a[++len] = x % 10;
    }
    return dfs(len, true, 0);
}

void solve()
{
    ll a, b;
    cin >> a >> b;
    cout << del(query(b), query(a-1)) << "\n";
}

int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    memset(f, -1, sizeof(f));
	int t = 1;
	cin >> t;
	while (t--) { solve(); }
}
```