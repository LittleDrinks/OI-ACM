---
tags:
  - 题解
  - DP/数位DP
aliases:
  - 数字计数
---
## [P2602 [ZJOI2010] 数字计数](https://www.luogu.com.cn/problem/P2602)

枚举 $digit$ 进行 DP，记 $f(p,cnt,0/1)$ 表示已经填完 $[p+1,len]$，且 $digit$ 填了 $cnt$ 个时，$digit$ 出现次数的总和。注意到 $digit>0$ 时答案都是一样的，所以在第三维只需要分两种情况记录就可以了。
记忆化搜索时，需要额外设置两个状态 $limit$ 和 $lead0$ 表示所填数字是否达到上限，以及当前这一位 $p$ 是不是前导零。$f$ 中只记录未达上限且不是前导零的答案。

[***AC 代码***](https://www.luogu.com.cn/record/226192878)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

const int L = 12;
int digit = 0;
ll a[L+5], f[L+5][L+5][2], ans[10];

ll dfs(int p, bool limit, bool lead0, int cnt)
{
    if (!p) {
        return cnt;
    }
    auto& now = f[p][cnt][digit != 0];
    if (!limit && !lead0 && ~now) {
        return now;
    }
    int up = limit ? a[p] : 9;
    ll res = 0;
    for (int i = 0; i <= up; ++i) {
        int tmp = cnt + (i == digit);
        if (lead0 && digit == 0 && i == 0) {
            tmp = 0;
        }
        res += dfs(p-1, limit&&(i==up), lead0&&(i==0), tmp);
    }
    if (!limit && !lead0) {
        now = res;
    }
    return res;
}

void query(ll x, int sgn)
{
    int len = 0;
    for (; x; x /= 10) {
        a[++len] = x % 10;
    }
    for (digit = 0; digit <= 9; ++digit) {
        ans[digit] += sgn * dfs(len, true, true, 0);
    }
}

void solve()
{
    ll a, b;
    cin >> a >> b;
    query(b,1); query(a-1,-1);
    for (int i = 0; i <= 9; ++i) {
        cout << ans[i] << " \n"[i == 9];
    }
}

int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    memset(f, -1, sizeof(f));
	int t = 1;
	// cin >> t;
	while (t--) { solve(); }
}
```
