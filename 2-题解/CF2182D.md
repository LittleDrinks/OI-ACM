---
tags:
  - 题解
  - 贪心
aliases:
  - Christmas Tree Decoration
---
## [CF2182D. Christmas Tree Decoration](https://codeforces.com/contest/2182/problem/D)

设一共有 $s$ 个装饰品，那么摆放装饰品的过程肯定至少进行 $\left\lfloor\dfrac{s}{n}\right\rfloor$ 轮，而不会超过 $\left\lceil\dfrac{s}{n}\right\rceil$ 轮。
记 $k=\left\lfloor\dfrac{s}{n}\right\rfloor$，前 $k$ 轮的摆放策略是固定的，即先选 $a_i$，再选 $a_0$。于是我们可以先模拟前 $k$ 轮。
记此时的装饰品数量为 $b$，有 $z$ 个已经放完装饰品（$b_i=0$）的人，有 $x=s\bmod n$ 个需要放装饰品的人
对于第 $k+1$ 轮，此时有两种情况会摆放装饰品：

- $b_i=1$，那么第 $i$ 个人肯定会在这一轮放置装饰品
- 会在 $z$ 个人中选出 $b_0$ 个人在这一轮放置 $b_0$ 中的装饰品

先把第二种情况选掉，然后两部分再分别排列即可，此时的方案数可以通过 $\displaystyle{z\choose b_0}x!(n-x)!$ 求出。
注意特判不可能的情况：

- $b_i<0$ 或 $b_i>1$
- $b_0<0$ 或 $b_0>z$

[***AC 代码***](https://codeforces.com/contest/2182/submission/360247416)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

const int MOD = 998244353, N = 1e6 + 5;
template<class...T> ll add(T...t){ll r=0;(((r+=t%MOD)>=MOD?r-=MOD:0),...);return(r%MOD+MOD)%MOD;}
template<class...T> ll mul(T...t){ll r=1;((r=r*(t%MOD)%MOD),...);return(r%MOD+MOD)%MOD;}
ll del(ll x,ll y){return add(x,MOD-y);}
ll qpow(ll a,ll b=MOD-2){ll r=1;for(;b;b>>=1,a=mul(a,a))if(b&1)r=mul(r,a);return r;}
ll fac[N + 5], Inv[N + 5];
void preprocess() {
    fac[0] = 1;
    for (int i = 1; i <= N; ++i) fac[i] = mul(fac[i-1], i);
    Inv[N] = qpow(fac[N]);
    for (int i = N - 1; ~i; --i) Inv[i] = mul(Inv[i + 1], i + 1);
}
ll C(ll n, ll m) { return m > n ? 0: mul(fac[n], Inv[m], Inv[n-m]); }
ll P(ll n, ll m) { return m > n ? 0: mul(fac[n], Inv[n-m]); }

void solve()
{
    int n;
    cin >> n;
    vector<int> a(n + 1);
    for (int i = 0; i <= n; ++i) { cin >> a[i]; }
    int s = accumulate(a.begin(), a.end(), 0);
    int k = s / n;
    int z = 0;
    bool bad = false;
    for (int i = 1; i <= n; ++i) {
        int x = min(a[i], k);
        a[i] -= x;
        a[0] -= k - x;
        z += (a[i] == 0);
        bad |= (a[i] > 1);
        bad |= (a[0] < 0);
    }
    bad |= (a[0] > z);
    int ans = 0;
    if (!bad) {
        ans = mul(C(z, a[0]), fac[n-z+a[0]], fac[z-a[0]]);
    }
    cout << ans << "\n";
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    preprocess();
    int t = 1;
    cin >> t;
    while (t--) solve();
}
```
