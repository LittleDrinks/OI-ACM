---
tags:
  - 题解
  - DP/分组DP
aliases:
  - Realistic Gameplay
---
## [CF1430F. Realistic Gameplay](https://codeforces.com/problemset/problem/1430/F)

$\sum a$ 是基本花费。在还剩子弹时强制换弹会增加子弹消耗。
这个问题本质上是分组问题，把 $[1,n]$ 波怪分为若干组，每组内不强制换弹。
$[i,j]$ 能分为一组的条件是，从第 $i$ 波打到第 $j$ 波，打完后还剩至少一回合可以强制换弹。
设 $dp(i)$ 表示干掉前 $i$ 波怪的最小花费。
我们使用刷表法进行 DP。枚举段的左端点，向后模拟打怪的过程。在第 $L_i$ 个时间点前剩余 $r=k$ 颗子弹，每一轮先把上一轮剩下的子弹打完，然后装子弹。于是打完第 $j$ 波怪需要的轮数是
$$
t=\left\lceil\dfrac{\max(0, a_j-r)}{k}\right\rceil
$$
如果 $[i,j]$ 符合 $L_j+t<L_{j+1}$，则更新 $dp(j+1)$
时间复杂度 $O(n^2)$

[***AC 代码***](https://codeforces.com/contest/1430/submission/351738286)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

const ll inf = 1e18;

void solve()
{
    int n, k;
    cin >> n >> k;
    
    vector<ll> L(n + 1), R(n + 1), a(n + 1);
    for (int i = 1; i <= n; ++i) {
        cin >> L[i] >> R[i] >> a[i];
    }

    vector<ll> dp(n + 1, inf);
    dp[1] = 0;
    ll ans = inf;
    for (int i = 1; i <= n; ++i) {
        ll r = k, tot = dp[i];
        for (int j = i; j <= n; ++j) {
            ll del = (R[j] - L[j]) * k;
            if (a[j] > del + r) {
                break;
            }
            ll t = (max(0LL, a[j] - r) + k - 1) / k;
            ll nr = r + t * k - a[j];
            tot += a[j];
            if (j + 1 <= n) {
                if (L[j] + t < L[j + 1]) {
                    dp[j + 1] = min(dp[j + 1], tot + nr);
                }
            } else {
                ans = min(ans, tot);
            }
            r = nr;
        }
    }

    if (ans > inf / 2) { ans = -1; }
    cout << ans << "\n";
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int t = 1;
    // cin >> t;
    while (t--) { solve(); }
}
```
