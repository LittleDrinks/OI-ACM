---
tags:
  - 题解
  - 树状数组
aliases:
  - Barkley II
---
## [QOJ7685. Barkley II](https://qoj.ac/contest/1404/problem/7685)

前置题：[[P1972|[SDOI2009] HH 的项链]]，[[CF2146E|Yet Another MEX Problem]]
前半部分用到 [[CF2146E|Yet Another MEX Problem]] 的想法。
钦定区间的 $\mathrm{mex}=x$，有两个要求：①区间上不出现 $x$，②区间上 $[1,x-1]$ 都有出现。
先考虑第一个条件，记 $[1,n]$ 的 $\mathrm{mex}=M$，对于 $1\le x\le M$，假设它在 $0$ 和 $n+1$ 两个位置有出现，最优的区间是相邻两个 $x$ 之间的那些区间，这些区间的总数是 $O(n)$ 的。
在满足第一个条件的前提下，如果一个区间的 $\mathrm{mex}=y< x$，那么必然满足 $id_{y,1}<id_{x,1}<id_{x,2}<id_{y,2}$，此时选择区间 $[id_{y,1}+1,id_{y,2}-1]$ 肯定更优，取 $\max$ 时 $x$ 不会对答案造成影响。因此第二个条件不用维护。
接下来考虑如何算出一个区间的答案。做法同 [[P1972|[SDOI2009] HH 的项链]]，将所有询问离线，开权值数组，只在某个数最后一次出现的位置置 $1$，其他位置置 $0$，此时区间和即为区间上的种类数。
时间复杂度 $O(n\log n)$

[***AC 代码***](https://qoj.ac/submission/1391979)

```cpp
#include <bits/stdc++.h>
using namespace std;


#define lson (p << 1)
#define rson (p << 1 | 1)
#define m ((l + r) >> 1)
template<typename Info, typename Lazy>
struct segmentTree {
    int n;
    vector<Info> a;
    vector<Lazy> t;
    segmentTree(int n): n(n), a(4 << __lg(n)), t(4 << __lg(n)) { }
    segmentTree(vector<Info>&& vec): segmentTree(vec.size()) {
        function<void(int,int,int)> build = [&](int p, int l, int r) {
            if (l == r - 1) {
                a[p] = vec[l];
                return;
            }
            build(lson, l, m);
            build(rson, m, r);
            push_up(p);
        };
        build(1, 0, n);
    }
    void push_up(int p) {
        a[p] = a[lson] + a[rson];
    }
    void apply(int p, Lazy v) {
        a[p] = a[p] + v;
        t[p] = t[p] + v;
    }
    void spread_down(int p) {
        apply(lson, t[p]);
        apply(rson, t[p]);
        t[p] = Lazy();
    }
    template<typename F>
    Info dfs(int p, int l, int r, int x, int y, F&& op) {
        if (y <= l || r <= x) { return Info(); }
        if (x <= l && r <= y) { op(p, l, r); return a[p]; }
        spread_down(p);
        Info res;
        res = res + dfs(lson, l, m, x, y, op);
        res = res + dfs(rson, m, r, x, y, op);
        push_up(p);
        return res;
    }
    void modify(int x, int y, Lazy v) {
        dfs(1, 0, n, x, y + 1, [&](int p, int l, int r){ apply(p, v); });
    }
    Info query(int x, int y) {
        return dfs(1, 0, n, x, y + 1, [](int,int,int){});
    }
};
#undef lson
#undef rson
#undef m

struct Info {
    int s;
    Info(int s = 0): s(s) { }
};

struct Lazy {
    int a;
    Lazy(int a = 0): a(a) { }
};

Info operator+ (Info u, Info v) {
    return Info(u.s + v.s);
}
Info operator+ (Info u, Lazy v) {
    return Info(u.s + v.a);
}
Lazy operator+ (Lazy u, Lazy v) {
    return Lazy(u.a + v.a);
}

const int inf = 2e9;
const int N = 5e5;
int last[N + 5];
bool vis[N + 5];

void solve()
{
    int n, m;
    cin >> n >> m;
    vector<int> a(n + 1);
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        vis[a[i]] = 1;
    }
    int MEX = 1;
    while (vis[MEX]) { ++MEX; }
    vector idx(MEX + 1, vector<int>());
    for (int i = 1; i <= n; ++i) {
        if (a[i] <= MEX) {
            idx[a[i]].push_back(i);
        }
    }
    vector q(n + 1, vector<pair<int,int>>());
    for (int i = 1; i <= MEX; ++i) {
        int pre = 1;
        idx[i].push_back(n + 1);
        for (auto j: idx[i]) {
            if (pre <= j - 1) {
                q[j - 1].emplace_back(pre, i);
            }
            pre = j + 1;
        }
    }

    int ans = -inf;
    segmentTree<Info, Lazy> t(n + 1);
    for (int i = 1; i <= n; ++i) {
        t.modify(last[a[i]], last[a[i]], Lazy(-1));
        t.modify(i, i, Lazy(1));
        for (auto [j, mex]: q[i]) {
            int res = t.query(j, i).s;
            ans = max(ans, res - mex);
        }
        last[a[i]] = i;
    }
    cout << ans << "\n";

    for (int i = 1; i <= n; ++i) {
        last[a[i]] = 0;
        vis[a[i]] = 0;
    }
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    // memset(last, -1, sizeof(last));
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
```
