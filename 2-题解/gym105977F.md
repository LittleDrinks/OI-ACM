---
tags:
  - 题解
  - 偏序问题
  - 树状数组
  - 线段树
  - 扫描线
aliases:
  - 帕累托前沿
---
## [gym105977F. 帕累托前沿](https://codeforces.com/gym/105977/problem/F)

整个区间内不存在满足条件的数，等价于左右侧第一个满足条件的位置 $a,b$ 满足 $a<l,r<b$。

---

考虑子问题：如何找到左右侧第一个满足 $k<j,x_k\ge x_j,y_k\ge y_j$ 的位置 $k$。

> [!hint] 
> $k<j,x_k\ge x_j,y_k\ge y_j$，这是经典的三维偏序问题，一种做法是排序一维、对第二维开权值数组，权值数组上记录第三维的信息。
> 而“左右侧第一个”是经典的线段树上二分问题。

考虑左侧的做法。以 $(x,y,-i)$ 为关键字从大到小排序，对下标 $i$ 建立线段树 $t$，其上记录 $y$ 的值，初始时 $t_0=t_{n+1}=\infty$。每遍历到一组 $(x,y,-i)$，在 $[0,i)$ 二分找到最后一个满足 $x_k\ge x_i,y_k\ge y_i$ 的位置，该位置即为子问题的答案，记为 $A_i$。
右侧的做法与左侧同构，以 $(x,y,+i)$ 为关键字从大到小排序，二分找到第一个位置即可，答案记为 $B_i$。

---

此时原问题转化为：$[l,r]$ 中有多少 $i$ 满足 $A_i<l\le i\le r<B_i$
这仍然是一个偏序问题，只不过需要设计一下。
一种直观的理解方式是，把 $(0,0)\to(l,r)$ 看作二维平面上的白色矩形，$(A_i+1,i)\to(i,B_i)$ 看成二维平面上的黑色矩形，对于每个白色矩形，问有多少黑色矩形只与其右边线有交。
考虑扫描线。形式化地描述是：把 $\{A_i+1\}\cup\{i+1\}\cup\{l\}$ 看作一维，先用 $A_i<l\le i$ 进行筛选，在 $A_i+1$ 处加入 $i$，在 $i+1$ 处排除 $i$。
对于所有满足 $A_i<l\le i$ 的 $i$，再用 $i\le r<B_i$ 筛选。把 $\{i\}\cup\{r\}\cup\{B_i-1\}$ 看作第二维，对这一维开权值数组，记录有多少满足条件的 $i$，每加入一个 $i$，在权值数组上对区间 $[i,B_i-1]$ 加一，每排除一个 $i$，在对应位置减一，最终 $r$ 位置上的值即为原问题的答案。
子问题需要排序、线段树二分，时间复杂度 $O(n\log n)$；转化后的问题需要排序、树状数组实现区间加法、单点求值，时间复杂度 $O(n\log n)$。总时间复杂度 $O(n\log n)$

[***AC 代码***](https://codeforces.com/gym/105977/submission/330526500)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
constexpr ll inf = 1e18;

#define lson (p << 1)
#define rson (p << 1 | 1)
#define m ((l+r)>>1)
template<typename Info>
struct segmentTree {
    int n;
    vector<Info> a;
    
    void push_up(int p) {
        a[p] = a[lson] + a[rson];
    }

    template<typename F>
    Info dfs(int p, int l, int r, int x, int y, F&& op) {
        if (y <= l || r <= x) { return Info(); }
        if (x <= l && r <= y) { op(p,l,r); return a[p]; }
        Info res;
        res = res + dfs(lson, l, m, x, y, op);
        res = res + dfs(rson, m, r, x, y, op);
        push_up(p);
        return res;
    }

    template<typename F>
    pair<int,Info> findFirst(int p, int l, int r, int x, int y, F&& pred) {
        if (y <= l || r <= x) { return {-1,Info()}; }
        if (x <= l && r <= y && !pred(a[p])) { return {-1,Info()}; }
        if (l == r-1) { return {l,a[p]}; }
        pair<int,Info> res = findFirst(lson, l, m, x, y, pred);
        if (res.first == -1) {
            res = findFirst(rson, m, r, x, y, pred);
        }
        return res;
    }

    template<typename F>
    pair<int,Info> findLast(int p, int l, int r, int x, int y, F&& pred) {
        if (y <= l || r <= x) { return {-1,Info()}; }
        if (x <= l && r <= y && !pred(a[p])) { return {-1,Info()}; }
        if (l == r-1) { return {l,a[p]}; }
        pair<int,Info> res = findLast(rson, m, r, x, y, pred);
        if (res.first == -1) {
            res = findLast(lson, l, m, x, y, pred);
        }
        return res;
    }

    segmentTree(int n = 0): n(n), a(4 << __lg(n)) { }
    segmentTree(vector<Info>&& b): segmentTree(b.size()) {
        function<void(int,int,int)> build = [&](int p, int l, int r) -> void {
            if (r - l == 1) { a[p] = Info(b[l]); return; }
            build(lson, l, m);
            build(rson, m, r);
            push_up(p);
        };
        build(1, 0, n);
    }

    void modify(int pos, ll x) {
        dfs(1, 0, n, pos, pos+1, [&](int p, int l, int r){ a[p].mx = x; });
    }

    int query(int l, int r) {
        return dfs(1, 0, n, l, r+1, [](int,int,int){}).mx;
    }

    int selectFirst(int l, int r, ll y) {
        auto [p, info] = findFirst(1, 0, n, l, r+1, [&](Info u){ return u.mx >= y; });
        return p;
    }
    
    int selectLast(int l, int r, ll y) {
        auto [p, info] = findLast(1, 0, n, l, r+1, [&](Info u){ return u.mx >= y; });
        return p;
    }
};
#undef lson
#undef rson
#undef m
struct Info {
    ll mx;
    Info(ll mx=-1): mx(mx) { }
};
Info operator+ (Info u, Info v) {
    return Info(max(u.mx, v.mx));
}

struct BIT {
	int n;
    vector <int> t;
    BIT(int n): n(n) { t.resize(n+1, 0); }  // 注意值域树状数组中 n=tot
    int lowbit(int x) { return x&-x; }
    void modify(int x, int d) {
        for (; x <= n; x += lowbit(x)) { t[x] += d; }
    }
	// 前缀和
    int query(int x) {
        int res = 0;
        for (; x; x -= lowbit(x)) { res += t[x]; }
        return res;
    }
    // 求最小的前缀和等于x的位置
	int select(int x) {
	    int ans = 0, sum = 0;
	    for (int i = __lg(n); i >= 0; --i) {
	        if (ans+(1<<i) <= n && sum+t[ans+(1<<i)] < x) { 
	            ans += 1<<i;
	            sum += t[ans];
	        }
	    }
	    return ans + 1;
	}
};

int main()
{
    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    int n, m;
    cin >> n >> m;
    vector<ll> a(n+1), b(n+1);
    for (int i = 1; i <= n; ++i) { cin >> a[i]; }
    for (int i = 1; i <= n; ++i) { cin >> b[i]; }

    vector<tuple<ll,ll,int>> que;
    for (int i = 1; i <= n; ++i) {
        que.emplace_back(a[i], b[i], -i);
    }
    
    segmentTree<Info> t(n+2);
    t.modify(0, inf);
    t.modify(n+1, inf);
    sort(que.rbegin(), que.rend());
    vector<int> L(n+1, -1);
    for (auto& [x, y, i]: que) {
        i = -i;
        L[i] = t.selectLast(0, i-1, y);
        t.modify(i, y);
    }
    t = segmentTree<Info>(n+2);
    t.modify(0, inf);
    t.modify(n+1, inf);
    sort(que.rbegin(), que.rend());
    vector<int> R(n+1, -1);
    for (auto& [x, y, i]: que) {
        R[i] = t.selectFirst(i+1, n+1, y);
        t.modify(i, y);
    }

    vector p(n+2, vector<tuple<int,int,int>>());
    for (int i = 1; i <= n; ++i) {
        p[L[i]+1].emplace_back(i, R[i]-1, 1);
        p[i+1].emplace_back(i, R[i]-1, -1);
    }
    for (int i = 1; i <= m; ++i) {
        int x, y;
        cin >> x >> y;
        p[x].emplace_back(y, i, 0);
    }
    BIT fenwick(n+2);
    vector<int> ans(m+1);
    for (int i = 1; i <= n; ++i) {
        for (auto [x, y, c]: p[i]) {
            if (c == 0) {
                ans[y] = fenwick.query(x);
            } else {
                fenwick.modify(x, c);
                fenwick.modify(y+1, -c);
            }
        }
    }
    for (int i = 1; i <= m; ++i) {
        cout << ans[i] << "\n";
    }
}
```
