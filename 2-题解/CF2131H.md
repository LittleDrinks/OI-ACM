---
tags:
  - 题解
  - 贪心
  - 莫比乌斯反演
  - 容斥原理
aliases:
  - Sea, You & copriMe
---
## [CF2131H. Sea, You & copriMe](https://codeforces.com/problemset/problem/2131/H)

建图，互质的位置连边，求一个大小为 $2$ 的匹配。
设原有匹配 $(u,v)$ 和 $(x,y)$，只有 $u,x$ 度为 $2$，且选择将 $u,x$ 相连时才会使答案变劣。
因此，我们可以对每个 $a_i$ 求出其在图上的度数，即序列中有多少数字和它互质，记作 $deg_i$，然后贪心地选择选择最可能匹配成功的点 $u$（度数最多的点）和影响最小的点 $v$（与 $u$ 相连且度数最小的点）进行匹配。

---

接下来考虑：对每个 $a_i$，如何求出序列中有多少数字和它互质。
反过来做，求序列中有多少数字和它不互质。
首先，我们可以对每个 $1\le x\le m$，预处理出序列中有多少数字是 $x$ 的倍数，记作 $f_x$，这个复杂度是调和级数。
然后根据 $f_x$ 容斥。$10^6$ 内的数最多有 $7$ 个质因子，我们枚举 $a_i$ 的所有质因子 $p_k$，使用容斥计算：加上序列中至少含有一个质因子的数的个数 $\displaystyle \sum_{r}f_{p_r}$，减去至少含有两个质因子的个数 $\displaystyle\sum_{r<s}f_{p_rp_s}$，加上含有三个质因子的情况 $\displaystyle\sum_{r<s<t}f_{p_rp_sp_t}$，……
形式化地，设 $Q$ 是 $a_i$ 质因数集合的一个非空子集，我们需要求出
$$
\sum_{Q\subseteq \mathrm{Prime\_Facter}(a_i),Q\ne \emptyset}(-1)^{|Q|+1}f_{\small\prod Q}
$$
比如对于 $15$，答案为 $f_3+f_5-f_{15}$
这一部分的复杂度为 $O(n2^7)$

[***AC 代码***](https://codeforces.com/contest/2131/submission/333766564)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

vector<int> sieve(int n)
{
	vector<bool> vis(n+1);
    vector<int> mP(n+1,1);
	vector<int> prime;
	vis[1] = 1;
	for (int i = 2; i <= n; ++i) {
		if (!vis[i]) {
            prime.push_back(i); 
            mP[i] = i;
        }
		for (auto p: prime) {
			if (i*p > n) { break; }
			vis[i*p] = 1;
            mP[i*p] = p;
			if (i%p == 0) { break; }  // 线性筛关键优化
		}
	}
	return mP;
}
auto mP = sieve(1000000);

void solve()
{
    int n, m;
    cin >> n >> m;
    vector<int> a(n+1);

    vector<int> f(m+1);
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        for (int x = 1; x * x <= a[i]; ++x) {
            if (a[i] % x == 0) {
                f[x]++;
                if (x * x != a[i]) {
                    f[a[i] / x]++;
                }
            }
        }
    }

    vector<int> deg(n+2);
    for (int i = 1; i <= n; ++i) {
        vector<int> pf;
        for (int y = a[i]; y > 1; y /= mP[y]) {
            pf.push_back(mP[y]);
        }
        sort(pf.begin(), pf.end());
        pf.erase(unique(pf.begin(), pf.end()), pf.end());
        vector<pair<ll,int>> fml;
        for (auto x: pf) {
            vector<pair<ll,int>> nfml = fml;
            nfml.emplace_back(x, 1);
            for (auto [y, sgn]: fml) {
                if (x * y > m) { continue; }
                nfml.emplace_back(x*y, -sgn);
            }
            fml = move(nfml);
        }
        for (auto [y, sgn]: fml) {
            deg[i] += sgn * f[y];
        }
        deg[i] = n - deg[i];
    }

    vector<bool> vis(n+1);
    vector<pair<int,int>> ans;
    deg[n+1] = 1e9;
    auto work = [&]() -> void {
        int mxid = 0;
        for (int i = 1; i <= n; ++i) {
            if (!vis[i] && deg[i] > deg[mxid]) { mxid = i; }
        }
        int mnid = n+1;
        for (int i = 1; i <= n; ++i) {
            if (!vis[i] && i != mxid && gcd(a[mxid], a[i]) == 1 && deg[i] < deg[mnid]) {
            	mnid = i;
            }
        }
        if (mxid != 0 && mnid != n + 1) {
            ans.emplace_back(mxid, mnid);
            vis[mxid] = 1;
            vis[mnid] = 1;
            for (int i = 1; i <= n; ++i) {
                if (i != mxid && gcd(a[i], a[mxid]) == 1) { --deg[i]; }
                if (i != mnid && gcd(a[i], a[mnid]) == 1) { --deg[i]; }
            }
        }
    };

    work(); work();
    if (ans.size() < 2) { cout << "0\n"; }
    else {
        for (auto [x, y]: ans) { cout << x << " " << y << " "; }
        cout << "\n";
    }
} 

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int t = 1;
    cin >> t;
    while (t--) { solve(); }
}
```
