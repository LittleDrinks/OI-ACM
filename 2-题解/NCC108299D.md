---
tags:
  - 题解
  - DP/背包
aliases:
  - Donkey Thinks...
---
## [NCC108299D. Donkey Thinks...](https://ac.nowcoder.com/acm/contest/108299/D)

前置题：[[gym616306C]]
“最后剩余”这个状态不太方便即时求出，我们考虑枚举最后剩余的容量 $u$，将物品的价值看作 $h_i-d_iu$ 重新跑背包，时间复杂度 $O(V\cdot NV)$
利用背包容量很小的特点优化 DP。
每个重量为 $s$ 的物品最多放 $\dfrac{V}{s}$ 个，有效物品的数量是 $\sum (V/s)=O(V\log V)$ 的，可以使用 `nth_element` 在不增加复杂度的情况下取出这些物品，然后套用背包 DP 计算。时间复杂度 $O(V^3\log V)$

[***AC 代码***](https://ac.nowcoder.com/acm/contest/view-submission?submissionId=78914872)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

void solve()
{
    int n, v;
    cin >> n >> v;
    vector obj(v+1, vector<pair<ll,ll>>());
    for (int i = 1; i <= n; ++i) {
        ll h, s, d;
        cin >> h >> s >> d;
        obj[s].emplace_back(h, d);
    }

    auto work = [&](int u) -> ll {
        vector<ll> dp(u + 1, -1e18);
        dp[0] = 0;
        for (int i = 1; i <= u; ++i) {
            if (obj[i].empty()) { continue; }
            int vol = min(int(obj[i].size())-1, u/i);
            nth_element(obj[i].begin(), obj[i].begin() + vol, obj[i].end(), [&](auto a, auto b){
                auto [h1, d1] = a;
                auto [h2, d2] = b;
                return h1 - d1 * (v - u) > h2 - d2 * (v - u);
            });
            for (int j = 0; j <= vol; ++j) {
                auto [h, d] = obj[i][j];
                for (int k = u; k - i >= 0; --k) {
                    dp[k] = max(dp[k], dp[k-i] + h - d * (v - u));
                }
            }
        }
        return dp[u];
    };

    ll ans = 0;
    for (int i = 1; i <= v; ++i) {
        ll res = work(i);
        ans = max(ans, res);
    }
    cout << ans << "\n";
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int t = 1;
    cin >> t;
    while (t--) { solve(); }
}

```
