---
tags:
  - 题解
  - 计算几何
aliases:
  - Cut ellipse
---
## [gym106139B. Cut ellipse](https://codeforces.com/gym/106139/problem/B)

椭圆其实是圆经过仿射变换得到的，将坐标轴横坐标缩小 $a$ 倍，纵坐标缩小 $b$ 倍就可以将椭圆变为单位圆。
将直线横截距缩小 $a$ 倍，纵坐标缩小 $b$ 倍，就可以得到直线的点方向式 $(A,\vec{v})$，计算原点到直线的距离
$$
d=\dfrac{\| \vec{v}\times \overrightarrow{OA} \|}{\|\vec{v}\|}
$$
逆仿射变换完，较小部分的图形是一个弓形，可以通过扇形减去三角形得到。
$$
S=\arccos d - d\sqrt{1-d^2}
$$
最后的面积等于 $(\pi-S) ab$

[***AC 代码***](https://codeforces.com/gym/106139/submission/346786326)

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll = long long;
using db = long double;
const db PI = acos(-1.0);
using T = db;
struct Point {
    T x, y;
    Point(T x=0, T y=0): x(x), y(y) {
    }
    Point operator+ (const Point &u) { return Point(x+u.x, y+u.y); }
    Point operator- (const Point &u) { return Point(x-u.x, y-u.y); }
    Point operator* (const db &k) { return Point(x*k, y*k); }
    Point operator/ (const db &k) { return Point(x/k, y/k); }
    T operator* (const Point &u) { return x*u.x + y*u.y; }
    T operator^ (const Point &u) { return x * u.y - u.x * y; }
    db len() { return sqrtl((*this)*(*this)); }
};

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    int a, b, k, c;
    cin >> a >> b >> k >> c;
    if (c == 0) {
        cout << fixed << setprecision(9) << PI * a * b / 2 << "\n";
        return 0;
    }
    Point p1(0, c), p2(-1.0*c/k, 0);
    p1 = p1 / b;
    p2 = p2 / a;
    db d = abs((p1-p2)^p1)/((p1-p2).len());
    db ang = 2 * acos(d);
    db S = ang / 2;
    S -= d * sqrtl(1 - d * d);
    S = PI - S;
    S = a * b * S;
    cout << fixed << setprecision(9) << max(S, PI*a*b-S) << "\n";
}
```
