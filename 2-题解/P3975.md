---
tags:
  - 题解
  - 后缀自动机SAM
aliases:
  - 弦论
---
## [P3975 [TJOI2015] 弦论](https://www.luogu.com.cn/problem/P3975)

SAM 求字典序第 $k$ 大子串。
先通过 SAM 预处理出 end pos，表示以这个节点结尾的子串数量
处理 $g(u)$ 表示以这个节点为结尾的子串个数， $f(u)$ 表示 end pos 在 DAG 上位于 $u$ 后方的子串个数。
当 $t=0$ 时 $f(u)=g(u)=1$
当 $t=1$ 时 $g(u)=endpos(u)$，$f(u)=g(u)+\sum f(v)$
注意特判空串，即 $f(1)=g(1)=0$
查询时根据 $f,g$ 决定在 DAG 上是否继续往下走、以及走的方向。当 $k\le g(u)$ 时在 $u$ 点停下，否则减去 $g(u)$。再考虑往后追加字母。比如追加一个 $\texttt{a}$，子串数量为 $f(ch(u,\texttt{a}))$，如果 $k\le f(ch(u,\texttt{a}))$ 说明追加 $\texttt{a}$ 恰好能满足 $k$ 的邀请，否则令 $k\leftarrow k-f(ch(u,\texttt{a}))$，表示已经走遍了这步追加 $\texttt{a}$ 的情况，继续考虑下一个字母。

[***AC 代码***](https://www.luogu.com.cn/record/227754054)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

//edited by piaoyun from some other's code 

int t, k;
string ans;

struct SAM {
    static const int N=1e6+5, S=28;
    int tot=1, last=1, link[N<<1], ch[N<<1][S], len[N<<1], endpos[N<<1];
	// 总点数 tot，点的 index 属于 [1-tot]，空串/根为 1 
	// last 为上一次插入的点
	// link 为点的 parent 树父节点 / 最长 出现位置与自己不同 的后缀
	// ch[n][s] 指节点 n 末尾加字符 s 所转移到的点
	// len 指该节点的串的 最长长度，注意到 最短长度 等于 len[link[n]] + 1 即父节点最长 + 1
	// endpos[n] 参考 get_endpos() 的注释 
    void clear() {
        for (int i = 0; i <= tot; ++i) {
            link[i] = len[i] = endpos[i] = 0;
            for (int k = 0; k < S; ++k) { ch[i][k] = 0; }
        }
        tot = 1; 
        last = 1;
    }

    // 延长一个字符，通常为 [1-26] 
    void extend(int w) {
        int p = ++tot, x = last, r, q;
        endpos[p] = 1;
        for (len[last=p]=len[x]+1; x&&!ch[x][w]; x=link[x]) { ch[x][w]=p; }
        if (!x) { link[p] = 1; }
        else if (len[x] + 1 == len[q=ch[x][w]]) { link[p]=q; }
        else {
            link[r=++tot] = link[q];
            memcpy(ch[r], ch[q], sizeof(ch[r]));
            len[r] = len[x] + 1;
            link[p] = link[q] = r;
            for (; x && ch[x][w] == q; x = link[x]) { ch[x][w] = r; }
        }
    }

    // 注意 vector 占用的空间 
    vector<int> p[N<<1];  //建立 parent 树，以便从上到下 dfs 
    void dfs(int u) {
        int v;
        for (int i = 0; i < int(p[u].size()); ++i) {
            v = p[u][i];
            dfs(v);
            endpos[u] += endpos[v];
        }
    }
    
    //注意！在使用该方法前，endpos[] 代表每个点作为“终结点”的次数
	//使用该方法后，endpos[] 指在串中出现总次数，即原数组的子树求和
    void get_endpos() {
        for (int i = 1; i <= tot; ++i) { p[i].clear(); }
        for (int i = 2; i <= tot; ++i) {
            p[link[i]].push_back(i);
        }
        dfs(1);
        for (int i = 1; i <= tot; ++i) { p[i].clear(); }
    }

    // 在您不确定是否有抄写错误时再使用该方法 
    // 必须在输入任何数据前自检，此前的数据会被清空 
    static const int STC = 998244353;
    void self_test() {
        clear();
        for (int i = 1; i <= 1000; ++i) { extend(i * i % 26 + 1); }
        ll tmp = 107 * last + 301 * tot;
        for (int i = 1; i <= tot; ++i) {
            tmp = (tmp * 33 + link[i] * 101 + len[i] * 97) % STC;
            for (int k = 1; k < S; ++k) { tmp = (tmp + k * ch[i][k]) % STC; }
        }
        assert("stage 1" && tmp == 393281314);   // stage1 : 检查建树是否正确
        tmp = 0;
        get_endpos();
        for (int i = 1; i <= tot; ++i) { tmp = (tmp * 33 + endpos[i]) % STC; }
        assert("stage 2" && tmp == 178417668);   // stage2 : 检查endpos计算是否正确，如果您修改了endpos[]的含义则会报错
        cout << "Self Test Passed. Remember to delete this function's use. \n";
        clear(); 
    }

	// 调试时可调用 
    void debug_print() {
        for (int i = 1; i <= tot; ++i) {
            cerr << "node : " << i << " father : " << link[i] << " endpos : " << endpos[i] << " len : " << len[i] << "\n"; 
        }
    }

    bool vis[N<<1];
    ll f[N<<1], g[N<<1];
    ll dfs2(int u) {
        if (vis[u]) { return f[u]; }
        vis[u] = 1;
        for (int i = 1; i < S; ++i) {
            if (ch[u][i]) { f[u] += dfs2(ch[u][i]); }
        }
        return f[u];
    }

    void print(int u, int k) {
        // cerr << "print :: " << u << " " << k << " " << g[u] << "\n";
        if (k <= g[u]) {
            return;
        } else {
            k -= g[u];
            for (int i = 1; i < S; ++i) {
                if (f[ch[u][i]] >= k) {
                    cout << char('a'+i-1);
                    print(ch[u][i], k);
                    break;
                } else {
                    k -= f[ch[u][i]];
                }
            }
        }
    }

    void solve() {
        if (t == 0) {
            for (int i = 1; i <= tot; ++i) { f[i] = g[i] = 1; }
        } else {
            get_endpos();
            for (int i = 1; i <= tot; ++i) { f[i] = g[i] = endpos[i]; }
        }
        f[1] = g[1] = 0;
        dfs2(1);
        if (f[1] < k) { cout << "-1\n"; }
        else { print(1, k); }
    }
} sam;

void solve()
{
    // sam.self_test();
    string s; cin >> s >> t >> k;
    for (auto c: s) { sam.extend(c-'a'+1); }
    sam.solve();
}

int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
	int t = 1;
	// cin >> t;
	while (t--) { solve(); }
}
```
