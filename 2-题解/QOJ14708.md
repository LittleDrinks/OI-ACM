---
tags:
  - 题解
  - 贪心
aliases:
  - Crossing River
---
## [QOJ14708. Crossing River](https://qoj.ac/contest/2563/problem/14708)

一艘船从到岸到出发中间可能会有一段冗余的等待时间，注意到把这段时间移动到开头一定不劣。
倒着做。枚举最后一个人在哪边，从最后一个人开始让船不停左右左右接人，如果发现接不到人，就在开头加上一段冗余的等待时间。
时间复杂度 $O(n)$

[***AC 代码***](https://qoj.ac/submission/1617571)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

void solve()
{
    int siz[2]; ll k;
    cin >> siz[0] >> siz[1] >> k;
    vector<pair<ll,int>> a[2];
    for (auto side: {0, 1}) {
        a[side].resize(siz[side]);
        for (int i = 0; i < siz[side]; ++i) {
            auto &[t, id] = a[side][i];
            id = i + 1;
            cin >> t;
        }
        sort(a[side].begin(), a[side].end(), greater<>());
    }

    ll ans_st = 1e18;
    ll ans_ed = 1e18;
    vector<tuple<int,int,int>> ans;
    for (auto ed_side: {0, 1}) {
        int p[2] = {-1, -1};
        int tot = 0;
        for (int side = ed_side; p[0] < siz[0] - 1 || p[1] < siz[1] - 1; side ^= 1, ++tot) {
            ++p[side];
        }

        ll st = 0;
        p[0] = p[1] = -1;
        vector<tuple<int,int,int>> res;
        for (int i = tot, side = ed_side; i; --i, side ^= 1) {
            ll now = st + k * (i - 1);
            if (p[side] < siz[side] - 1) {
                ++p[side];
                auto [req, id] = a[side][p[side]];
                if (now < req) {
                    st += req - now;
                    now = req;
                }
                res.emplace_back(i-1, side, id);
            }
        }
        reverse(res.begin(), res.end());
        assert(res.size() == siz[0] + siz[1]);
        if (st + k * tot < ans_ed) {
            ans_st = st;
            ans_ed = st + k * tot;
            ans = res;
        }
    }

    cout << ans_ed << "\n";
    for (int i = 0; i < siz[0] + siz[1]; ++i) {
        auto [bef, side, id] = ans[i];
        cout << ans_st + k * bef << " " << side << " " << id << "\n";
    }
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    int t = 1;
    // cin >> t;
    while (t--) {
        solve();
    }
}
```
