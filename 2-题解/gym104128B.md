---
tags:
  - 题解
  - DP/单调队列优化DP
aliases:
  - Ropeway
---
## [gym104128B. Ropeway](https://codeforces.com/gym/104128/problem/B)

先想不修改怎么做。
设 $f(i)$ 表示第 $i$ 个位置的塔必选的情况下，前 $i$ 个位置的塔符合要求的最小花费。
钦定 $f(0)=0$，$s_0=\texttt{1}$，记上一个 $s=\texttt{1}$ 的位置为 $last$，则有
$$
f(i)=\min_{j=\max(last,i-k,0)}^{i-1} \{ f(j) \} + a_i
$$
使用单调队列优化，$s=\texttt{1}$ 的限制可以看作把队列清空，不难做到 $O(n)$
*note：使用线段树进行状态转移会 TLE*
然后考虑修改。显然单点修改后 $[p,n+1]$ 的 $f$ 会受到影响，暴力的复杂度是 $O(qn)$。
题目中比较特征的数据范围是 $k,q\le 3\times 10^3$。到这里会有一些局部重构的想法，因为比较直观的性质是：①每 $k$ 个位置必须造一座塔；②单点修改能影响的区间其实很小，比如 $[0,p)$ 区间上的 $f$ 并不会被修改。
为了更好地利用性质②，我们可以倒着做一遍 DP。设 $g(i)$ 表示第 $i$ 座塔必选的情况下，$[i,n+1]$ 位置的塔符合要求的最小花费。显然 $(p,n+1]$ 位置上的 $g$ 也不会被修改。
为了方便统计答案，$g(i)$ 处可以不加上 $a_i$ 这座塔的花费。此时根据性质①，我们在任意一个长度为 $k$ 的区间枚举某座塔必选就可以得到答案：
$$
ans = \min \{ f(i) + g(i) \}
$$
利用性质①，我们钦定在 $[p,p+k]$ 这个区间上选择一个必造的塔，根据 $f(i)+g(i)$ 计算答案。因为单点修改后 $f$ 的值会改变，我们只需要重新计算位于 $[p,p+k]$ 这个区间内的 $f$ 即可。
时间复杂度 $O(n+qk)$

[***AC 代码***]()

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 5e5 + 5;
const ll inf = 1e18;
int n, k;
ll a[N + 5], f[N + 5], g[N + 5], h[N + 5];
string must;

void init(ll dp[]) {
    deque<pair<ll, int>> dq;
    dp[0] = 0;
    dq.emplace_back(0LL, 0);
    for (int i = 1; i <= n + 1; ++i) {
        while (!dq.empty() && dq.front().second < i - k) {
            dq.pop_front();
        }
        dp[i] = dq.front().first + a[i];
        if (must[i - 1] == '1') {
            dq.clear();
        }
        while (!dq.empty() && dq.back().first >= dp[i]) {
            dq.pop_back();
        }
        dq.emplace_back(dp[i], i);
    }
}

ll query(int p, ll v) {
    ll old = a[p];
    a[p] = v;

    ll res = inf;
    deque<pair<ll,int>> dq;
    for (int i = k; i; --i) {
        if (p - i < 0) {
            continue;
        }
        if (must[p - i - 1] == '1') {
            dq.clear();
        }
        while (!dq.empty() && dq.back().first >= f[p - i]) {
            dq.pop_back();
        }
        dq.emplace_back(f[p - i], p - i);
    }
    for (int i = p; i <= p + k && i <= n + 1; ++i) {
        while (!dq.empty() && dq.front().second < i - k) {
            dq.pop_front();
        }
        h[i] = dq.front().first + a[i];
        res = min(res, h[i] + g[i]);
        if (must[i - 1] == '1') {
            dq.clear();
        }
        while (!dq.empty() && dq.back().first >= h[i]) {
            dq.pop_back();
        }
        dq.emplace_back(h[i], i);
    }

    a[p] = old;
    return res;
}

void solve() {
    cin >> n >> k;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
    }
    a[n + 1] = 0;
    cin >> must;
    init(f);
    reverse(a, a + n + 2);
    reverse(must.begin(), must.end());
    init(g);
    reverse(g, g + n + 2);
    reverse(a, a + n + 2);
    reverse(must.begin(), must.end());
    for (int i = 1; i <= n; ++i) {
        g[i] -= a[i];
    }

    int q;
    cin >> q;
    while (q--) {
        int p;
        ll v;
        cin >> p >> v;
        cout << query(p, v) << "\n";
    }
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
```
