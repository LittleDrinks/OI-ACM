---
tags:
  - 题解
  - DP/背包/退背包
  - DP/树形DP
aliases:
  - DFS Order 2
---
## [gym104076C. DFS Order 2](https://codeforces.com/gym/104076/problem/C)

记一个节点 $u$ 的儿子个数为 $son_u$，对于每个节点，可以任意调换其儿子的顺序，则 dfs 序的总数为
$$
\prod_{u=1}^{n} son_u!
$$
记答案为 $ans(u,i)$ ，即 dfs 序的第 $i$ 位是 $u$ 的方案数。$ans(1,1)$ 就是 dfs 序的总数。
注意到在一个节点 $u$ 处，dfs 序一定是先选择一个子节点遍历其子树，然后再选择下一个儿子。这启发我们考虑如何求出节点 $u$ 的一个儿子 $v$ 处的答案。
我们考虑 $u,v$ 在 dfs 序中的相对位置关系，如 $u,x,y,z,v$，此处 $x,y,z$ 都必须是 $u$ 子树内若干棵完整的子树。不妨设 $index_u + s + 1 = index_v$，记 $f(s)$ 表示 $v$ 前方有节点总数为 $s$ 的若干棵完整子树的 dfs 序数量，则有转移：
$$
ans(v,j)=\sum_{i < j} ans(u,j-i-1)\times \dfrac{f(i)}{\sum_{k=0}^m f(k)}
$$
接下来考虑如何求出 $f$。
不妨设 $u$ 一共有 $m$ 个儿子，$g(k,s)$ 表示从除 $v$ 外的 $m-1$ 个儿子中选择 $k$ 个儿子，且节点总数为 $s$ 的方案数，再乘上前后两部分各自全排列的系数，求得 $v$ 作为第 $k+1$ 个儿子的方案数为
$$
f(s)=\sum_kg(k,s)\times k!\times (m-1-k)!
$$
而 $g(k,s)$ 是一个典型的树形背包问题。
$$
g(k,s)=\sum g(k-1,s-siz_i) 
$$
一种朴素的做法是对于每一个儿子节点 $v$，对除去 $v$ 之外的儿子跑一遍背包求出 $g(k,s)$，然后对应转移。时间复杂度 $O(n^4)$。
事实上，从背包中“除去一个物品”是经典的退背包问题。
背包的各个物品之间调换顺序不会影响背包的结果，所以可以假想除去的子树 $v$ 是最后一个进行转移的，想要把 $v$ 除去，就按逆顺序把之前加上的全部减掉就可以了，时间复杂度就是往背包里加入一个物品的复杂度 $O(n^2)$，总时间复杂度 $O(n^3)$。

[***AC 代码***](https://codeforces.com/gym/104076/submission/341029995)

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 505;
const int MOD = 998244353;
int add(int x, int y) {
    return (x + y) % MOD;
}
int del(int x, int y) {
    return add(x, MOD - y);
}
int mul(int x, int y) {
    return 1LL * x * y % MOD;
}
int qpow(int a, int b = MOD - 2) {
    int res = 1;
    for (; b; b >>= 1, a = mul(a, a)) {
        if (b & 1) {
            res = mul(res, a);
        }
    }
    return res;
}
int fac[N + 5], Inv[N + 5];
int C(int n, int k) {
    return k > n ? 0 : mul(fac[n], mul(fac[k], fac[n - k]));
}

int n, son[N + 5], siz[N + 5];
int f[N + 5][N + 5], ans[N + 5][N + 5];
bool vis[N + 5];
vector<int> G[N + 5];

void dfs(int u, int fa) {
    siz[u] = 1;
    for (auto v : G[u]) {
        if (v == fa) {
            continue;
        }
        dfs(v, u);
        ++son[u];
        siz[u] += siz[v];
    }
    ans[1][1] = mul(ans[1][1], fac[son[u]]);
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    fac[0] = Inv[0] = 1;
    for (int i = 1; i <= N; ++i) {
        fac[i] = mul(fac[i - 1], i);
    }
    Inv[N] = qpow(fac[N]);
    for (int i = N - 1; i; --i) {
        Inv[i] = mul(Inv[i + 1], i + 1);
    }
    cin >> n;
    for (int i = 1; i < n; ++i) {
        int u, v;
        cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    ans[1][1] = 1;
    dfs(1, 0);

    queue<int> q;
    q.push(1);
    vis[1] = 1;
    while (not q.empty()) {
        int u = q.front();
        q.pop();
        vis[u] = 1;

        int m = son[u];
        vector g(m + 1, vector<int>(n + 1));
        g[0][0] = 1;

        for (auto v : G[u]) {
            if (vis[v]) {
                continue;
            }
            for (int i = m; i; --i) {
                for (int j = siz[v]; j <= siz[u]; ++j) {
                    g[i][j] = add(g[i][j], g[i-1][j-siz[v]]);
                }
            }
        }
        
        for (auto v : G[u]) {
            if (vis[v]) {
                continue;
            }
            for (int i = 1; i <= m; ++i) {
                for (int j = siz[v]; j <= siz[u]; ++j) {
                    g[i][j] = del(g[i][j], g[i-1][j-siz[v]]);
                }
            }
            for (int i = 0; i <= m; ++i) {
                for (int j = 0; j < siz[u]; ++j) {
                    f[v][j] =
                        add(f[v][j], mul(g[i][j], mul(fac[i], fac[m - i - 1])));
                }
            }

            for (int i = m; i; --i) {
                for (int j = siz[v]; j <= siz[u]; ++j) {
                    g[i][j] = add(g[i][j], g[i-1][j-siz[v]]);
                }
            }

            int t = 0;
            for (int i = 0; i <= n; ++i) {
                t = add(t, f[v][i]);
            }
            t = qpow(t);
            for (int i = 0; i < n; ++i) {
                for (int j = i + 1; j <= n; ++j) {
                    ans[v][j] = add(ans[v][j], mul(ans[u][j - i - 1], mul(f[v][i], t)));
                }
            }
            vis[v] = 1;
            q.push(v);
        }
    }

    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            cout << ans[i][j] << " \n"[j == n];
        }
    }
}
```
