---
tags:
  - 题解
  - 贪心
aliases:
  - Canvas Painting
---
## [QOJ14303. Canvas Painting](https://qoj.ac/contest/2513/problem/14303)

先将区间排序，一个直观的想法是每次选择 $[L, L+1]$ 进行涂色，但是有一个 bug

```
1 7
1 8
1 9
2 3
```

这四个区间如果按照这个策略进行贪心，会把 $[2,3]$ 浪费掉。
考虑相邻的两个左端点 $L_1=1,\ L_2=2$，$[L_1,L_2)$ 之间应该用区间 $[L_1,*]$ 进行填充，多余的继承给 $L_2$。

[***AC 代码***](https://qoj.ac/submission/1318799)

```cpp
#include <bits/stdc++.h>
using namespace std;

void solve() {
    int m, n;
    cin >> m >> n;
    vector<pair<int, int>> seg;
    seg.reserve(m);
    for (int i = 0; i < m; ++i) {
        int x, y;
        cin >> x >> y;
        if (x < y) {
            seg.emplace_back(x, y);
        }
    }
    seg.emplace_back(n + 1, n + 1);
    sort(seg.begin(), seg.end());
    priority_queue<int, vector<int>, greater<>> q;
    int cur = 1, ans = n;
    for (auto [x, y] : seg) {
        while (!q.empty() && cur < x) {
            auto t = q.top();
            q.pop();
            if (cur < t) {
                ++cur;
                --ans;
            }
        }
        cur = max(cur, x);
        q.push(y);
    }
    cout << ans << "\n";
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
```
