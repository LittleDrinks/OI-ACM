---
tags:
  - 题解
  - DP/背包/退背包
aliases:
  - Marble Race
---
## [gym105459E. Marble Race](https://codeforces.com/gym/105459/problem/E)

一共有 $mn$ 个可能的时间取值，枚举中位数 $t$，求恰好有 $\left\lfloor \dfrac{m}{2}\right\rfloor$ 个弹珠未通过原点的概率。
不妨设每个弹珠在此时有 $p_i$ 的概率没过原点。如果直接跑背包，单次时间复杂度 $O(m^2)$，难以接受。
重新观察所有球的状态，发现其实只有 $O(mn)$ 种不同的时间，我们从小到大枚举时间作为中位数，每次只有一个弹珠的 $p$ 会发生变化。这实际上是一个退背包问题。
这里给出一种比较方便的退背包理解方法。从生成函数的视角理解背包，实际上是求
$$
\left[x^{\lfloor m/2\rfloor}\right]\prod_{i=1}^m p_ix+(1-p_i)
$$
每次修改相当于先除以一个单项式 $px+(1-p)$，再乘一个单项式 $p'x+(1-p')$，单次计算的时间复杂度是 $O(m)$，总时间复杂度 $O(mn\cdot m)$

[***AC 代码***](https://codeforces.com/gym/105459/submission/335016970)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

const int MOD = 1e9+7;
ll add(ll x, ll y) { x %= MOD; y %= MOD; return (x + y) % MOD; }
ll del(ll x, ll y) { x %= MOD; y %= MOD; return add(x, MOD-y); }
ll mul(ll x, ll y) { x %= MOD; y %= MOD; return (x * y) % MOD; }
ll qpow(ll a, ll b = MOD - 2) {
    ll res = 1;
    for (; b; b >>= 1, a = mul(a, a)) {
        if (b & 1) { res = mul(res, a); }
    }
    return res;
}

using poly = vector<ll>;
poly operator*(const poly &a, const poly &b) {
    int n = a.size();
    int m = b.size();
    poly c(n + m - 1);
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            c[i + j] = add(c[i + j], mul(a[i], b[j]));
        }
    }
    return c;
}
poly operator/(poly a, poly b) {
    int n = a.size();
    int m = b.size();
    if (b[1] == 0) {
        return a;
    }

    poly c(n - 1);
    ll base = qpow(b[1]);
    for (int i = n - 1; i; --i) {
        ll d = mul(a[i], base);
        c[i - 1] = d;
        a[i - 1] = del(a[i - 1], mul(d, b[0]));
    }
    return c;
}

void solve() {
    int n, m;
    cin >> n >> m;
    ll invn = qpow(n);
    vector<ll> x(n), v(m);
    for (auto &val : x) {
        cin >> val;
    }
    for (auto &val : v) {
        cin >> val;
    }
    vector<tuple<db, ll, int>> q;
    q.reserve(n * m);
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            q.emplace_back(-1.0 * x[i] / v[j], mul(-x[i], qpow(v[j])), j);
        }
    }
    sort(q.begin(), q.end());
    vector<poly> p(m, {1, 0});
    poly sum{1};
    for (auto a : p) {
        sum = sum * a;
    }
    ll ans = 0;
    while (!sum.empty() && sum.back() == 0) {
        sum.pop_back();
    }
    for (auto [_, t, id] : q) {
        sum = sum / p[id];
        p[id][0] = del(p[id][0], invn);
        p[id][1] = del(1, p[id][0]);
        if (sum.size() > m / 2) {
            ans = add(ans, mul(t, sum[m / 2]));
        }
        sum = sum * p[id];
    }
    cout << mul(ans, invn) << "\n";
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t = 1;
    // cin >> t;
    while (t--) {
        solve();
    }
}
```
