---
tags:
  - 题解
aliases:
---
## []()

在统计理想数组之前，我们先理解如何检查一个给定数组 $c$ 是否是理想的。我们将按如下方式进行：尝试构造一个美丽的数组 $b$，使得 $b$ **不是**数组 $c$ 的子序列。

让我们尝试理解数组 $b$ 的第一个元素在数组 $c$ 中的位置。为此，我们将找到数字 $a_{1,1}, a_{1,2}, \dots, a_{1,l_1}$ 在数组 $c$ 中的首次出现。如果我们没有找到其中至少一个数字，我们可以选择它作为 $b_1$，这样 $b$ 就不会是 $c$ 的子序列。否则，我们将以限制子序列“扩展”的方式选择 $b_1$ ——即从数组 $a_1$ 中选择一个在 $c$ 中首次出现最晚的元素（因为子序列只能在这个出现之后继续）。

我们如何选择 $b_2$？实际上，我们面临同样的问题，但现在我们从第二个元素开始构造数组 $b$，并且只有数组 $c$ 的某个后缀保留下来。我们将找到数组 $a_2$ 中元素的最近出现，选择其中最晚的一个，然后在 $c$ 的某个更短的后缀上继续选择 $b_3$，依此类推。

然而，更方便的做法是稍微重新表述这个算法。让我们从左到右遍历数组 $c$，并维护以下内容：
- $x$（$0 \le x \le k$）——数组 $b$ 的前几个元素的数量，我们已经为它们找到了所有选择所需的出现；
- $s$ ——来自数组 $a_{x+1}$ 的元素集合（$b_{x+1}$ 的候选），我们当前正在搜索它们的出现。

然后，我们遇到的每个数组 $c$ 的元素要么属于集合 $s$（此时需要将其从 $s$ 中移除，如果 $s$ 变为空，则我们移动到 $x+1$ 并将数组 $a_{x+2}$ 的所有元素添加到 $s$ 中），要么不在这个集合中（此时我们可以直接跳过它）。

实际上，这已经允许我们统计理想数组 $c$ 的数量。让我们为这个过程编写动态规划：$dp_{i,x,|s|}$ ——选择数组 $c$ 的前 $i$ 个元素的方法数，使得在处理它们之后，我们得到给定的 $x$ 值和集合 $s$ 的大小（实际上我们只关心集合中元素的数量，而不是元素本身）。转移非常简单：
- 要么从集合 $s$ 中选择一个数字（有 $|s|$ 种选择方式），转移到 $dp_{i+1,x,|s|-1}$ 或 $dp_{i+1,x+1,l_2}$；
- 要么选择不在这个集合中的数字（有 $m - |s|$ 种选择方式），转移到 $dp_{i+1,x,|s|}$。

不幸的是，这太慢了。让我们尝试理解如何加速这个动态规划。

假设我们将 $c$ 中的所有元素分为两组：那些在处理时减少 $|s|$ 大小的（组 A），和那些不减少的（组 B）。如果我们只考虑组 A 的元素，应该有恰好 $\sum l_i$ 个，并且选择它们的方法数是 $\prod (l_i)!$ ——我们选择在 $c$ 中遇到每个数组 $a_i$ 元素的顺序。

但我们也可能有组 B 的元素：恰好有 $n - \sum l_i$ 个。数组 $c$ 的整体结构将如下所示：B* A B* A B* ... B* A B*，其中 A 表示来自组 A 的元素，B* 表示来自组 B 的元素块（可能为空）。总共，块 B* 必须包含 $n - \sum l_i$ 个元素。

对于每个块 B*，我们知道哪些数字可以在其中使用，哪些不能：唯一不能使用的数字是当前在集合 $s$ 中的数字。它们取决于我们在 $c$ 中遇到相应数组 $a_i$ 元素的顺序，但它们的数量对于每个块 B* 是唯一确定的。也就是说，对于每个块 B*，我们知道选择该块中每个元素的方法数。

我们需要的最后一个观察是：对于每个块 B*，选择每个元素的方法数位于区间 $[m-5, m]$ 内。这样，我们现在就可以解决问题了。

我们将所有块 B* 根据其中“禁止”元素的数量分为 6 个类别：令 $d_i$ 为第 $i$ 个类别中的块数，其中禁止元素的数量等于 $i$（$i \in [0, 5]$）。假设第 $i$ 个类别中有 $e_i$ 个元素；那么选择它们的方法数是 $(m-i)^{e_i}$，并且将它们分布到块中的方法是 $\binom{e_i + d_i - 1}{e_i}$。

现在我们只需要在所有将 $n - \sum l_i$ 表示为 6 个整数 $e_0, e_1, \dots, e_5$ 之和的方法中计算答案。为此，对于每个类别 $i$，我们将形成一个次数为 $n - \sum l_i$ 的多项式，其中第 $j$ 项的系数是 $\binom{j + d_i - 1}{j} \cdot (m-i)^j$。如果我们将所有这些多项式相乘，那么第 $(n - \sum l_i)$ 项的系数正是我们需要的：对于所有将数字 $(n - \sum l_i)$ 分解为非负整数 $e_i$ 的方法，乘积 $\binom{e_i + d_i - 1}{e_i} \cdot (m-i)^{e_i}$ 的总和。

自然，为了在这里相乘多项式，我们需要使用 FFT（或 NTT，因为模数适合 NTT）。在相乘多项式时，我们可以每次将结果“修剪”到次数 $(n - \sum l_i)$，因为我们不需要更高的次数。

[***AC 代码***]()

```cpp

```
