---
tags:
  - 题解
  - AC自动机
  - DP/状压DP
aliases:
  - "[HNOI2004] L 语言"
  - L 语言
---
## [P2292 [HNOI2004] L 语言](https://www.luogu.com.cn/problem/P2292)

朴素的思路是，设 $f(i)$ 表示长度为 $i$ 的前缀是否可以被解读。有如下状态转移
$$
f(i) \leftarrow \bigvee_{t[j+1:i]\in S} f(j)
$$
我们希望找到所有能和模式串匹配的 $t$ 的后缀，每次暴力跳 fail 的复杂度是 $O(m\cdot |s|\cdot|t|)$ 的。
注意到 $|S|\le20$，考虑状压，设第 $i$ 位表示该节点是否有长度为 $i$ 的模式串后缀。
如果 AC 自动机上的一个节点 $u$ 是一个长度为 $L$ 的模式串的结束位置，那么所有能通过 fail 指针跳到 $u$ 的节点都有这个长度为 $L$ 的后缀，可以在建 fail 树时进行状态转移。总结点数 $O(n|s|)$，建 fail 指针及转移的时间复杂度是 $O(n|s|^2)$。
完成状态转移后，每次匹配到一个节点时，可以 $O(1)$ 查询到一个二进制串 $stat$ 表示当前节点有哪些后缀是模式串，$f$ 的转移式可以改写为
$$
f(i)\leftarrow [stat\land f[i-21:i-1]]
$$

[***AC 代码***](https://www.luogu.com.cn/record/225461680)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

struct AhoCorasick {
    static constexpr int ALPHABET = 26;
    struct Node {
        int len;
        int link;
        bitset<21> stat;
        array<int,ALPHABET> next;
        Node(): len{0}, link{0}, next{} { }
    };

    int siz;
    Node t[1005];

    AhoCorasick() {
        init();
    }

    void init() {
        siz = 1;
        t[0] = t[1] = Node();
        t[0].next.fill(1);
        t[0].len = -1;
    }

    int newNode() {
        t[++siz] = Node();
        return siz;
    }

    int add(const string &a) {
        int p = 1;
        for (auto c: a) {
            int x = c - 'a';
            if (t[p].next[x] == 0) {
                t[p].next[x] = newNode();
                t[t[p].next[x]].len = t[p].len + 1;
            }
            p = t[p].next[x];
        }
        t[p].stat[t[p].len - 1] = 1;
        return p;
    }

    void work() {
        queue<int> q;
        q.push(1);

        while (!q.empty()) {
            int x = q.front();
            q.pop();

            for (int i = 0; i < ALPHABET; ++i) {
                if (t[x].next[i] == 0) {
                    t[x].next[i] = t[t[x].link].next[i];
                    t[x].stat |= t[t[x].link].stat;
                } else {
                    t[t[x].next[i]].link = t[t[x].link].next[i];
                    q.push(t[x].next[i]);
                }
            }
        }
    }

    int next(int p, int x) {
        return t[p].next[x];
    }

    int link(int p) {
        return t[p].link;
    }

    int len(int p) {
        return t[p].len;
    }

    bitset<21> stat(int p) {
        return t[p].stat;
    }

    int size() {
        return siz + 1;
    }
};

void solve()
{
    int n, q;
    cin >> n >> q;

    AhoCorasick AC;

    vector<int> pos(n+1);
    set<int> ed;
    vector<string> s(n+1);
    for (int i = 1; i <= n; ++i) {
        cin >> s[i-1];
        pos[i] = AC.add(s[i-1]);
        ed.insert(pos[i]);
    }
    AC.work();

    while (q--) {
        string T;
        cin >> T;
        T = " " + T;

        int ans = 0;
        bitset<21> ck;
        ck[0] = 1;
        int p = 1;
        for (int i = 1; i < int(T.size()); ++i) {
            ck <<= 1;
            int c = T[i] - 'a';
            if (p == 0) { p = 1; }
            p = AC.next(p, c);
            bitset<21> msk = AC.stat(p) << 1;
            msk &= ck;
            if (msk.any()) {
                ck[0] = 1;
                ans = i;
            }
            // cerr << i << "\t" << p << "\t" << ck << "\n";
        }

        cout << ans << "\n";
    }
}

int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
	int t = 1;
	// cin >> t;
	while (t--) { solve(); }
}
```
