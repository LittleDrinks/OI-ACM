---
tags:
  - 题解
  - 哈希
aliases:
  - Famous Choreographer
---
## [CF2132G. Famous Choreographer](https://codeforces.com/contest/2132/problem/G)

选择原矩阵的一个角作为中心，一定可以构造出一个大小为 $(2n-1)\times(2m-1)$ 的符合条件的矩阵。
选择原矩阵角上的一个大小为 $(x,y)$ 的子矩阵作为中心，只要这个矩阵旋转 $180\degree$ 后能和原来重合，就一定能构造出一个大小为 $(2n-x)\times(2m-y)$ 的矩阵符合条件。
$O(nm)$ 枚举选择的子矩阵。预处理哈希，可以在 $O(1)$ 的时间内判断是否可以构造出合法的大矩阵。

[***AC 代码***](https://codeforces.com/contest/2132/submission/335001458)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

ll add(ll x, ll y, ll MOD) { x %= MOD; y %= MOD; return (x + y) % MOD; }
ll del(ll x, ll y, ll MOD) { x %= MOD; y %= MOD; return add(x, MOD-y, MOD); }
ll mul(ll x, ll y, ll MOD) { x %= MOD; y %= MOD; return (x * y) % MOD; }
using hs = pair<ll,ll>;
const int MOD1 = 1e9+7, MOD2 = 1e9+9;
const hs p1 = { 117, 131 }, p2 = { 114, 514 };
hs operator+ (hs a, hs b) { return hs{add(a.first, b.first, MOD1), add(a.second, b.second, MOD2)}; }
hs operator- (hs a, hs b) { return hs{del(a.first, b.first, MOD1), del(a.second, b.second, MOD2)}; }
hs operator* (hs a, hs b) { return hs(mul(a.first, b.first, MOD1), mul(a.second, b.second, MOD2)); }
ostream& operator<< (ostream& os, hs h) { return os << "( " << h.first << " " << h.second << " )"; }

const int N=2e6;
hs Pow1[N+5], Pow2[N+5];

void solve()
{
    int n, m;
    cin >> n >> m;
    vector<string> g(n);
    for (auto &r: g) { cin >> r; }
    vector<string> rg(g);
    reverse(rg.begin(), rg.end());
    for (auto &r: rg) { reverse(r.begin(), r.end()); }

    auto calc_hs = [&](const vector<string>& mp) -> vector<vector<hs>> {
        vector res(n+1, vector<hs>(m+1));
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j) {
                res[i][j] = Pow1[i] * Pow2[j] * hs{(mp[i-1][j-1]-'a'+1), (mp[i-1][j-1]-'a'+1)};
                res[i][j] = res[i][j] + res[i-1][j] + res[i][j-1] - res[i-1][j-1];
            }
        }
        return res;
    };

    auto h = calc_hs(g);
    auto rh = calc_hs(rg);

    auto get_hs = [&](const vector<vector<hs>>& hash, int lx, int ly, int rx, int ry) -> hs {
        if (lx > rx) { swap(lx, rx); }
        if (ly > ry) { swap(ly, ry); }
        hs h = hash[rx][ry] - hash[lx-1][ry] - hash[rx][ly-1] + hash[lx-1][ly-1];
        return h * Pow1[n - rx] * Pow2[m - ry];
    };

    ll ans = numeric_limits<ll>::max();
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            bool valid = false;
            valid |= get_hs(h, 1, 1, i, j) == get_hs(rh, n-i+1, m-j+1, n, m);
            valid |= get_hs(rh, 1, 1, i, j) == get_hs(h, n-i+1, m-j+1, n, m);
            if (valid) {
                ll r = (i+2*(n-i));
                ll c = (j+2*(m-j));
                ans = min(ans, r * c - n * m);
            }
        }
    }
    for (int i = n; i; --i) {
        for (int j = 1; j <= m; ++j) {
            bool valid = false;
            valid |= get_hs(h, i, j, 1, m) == get_hs(rh, n-i+1, m-j+1, n, 1);
            valid |= get_hs(rh, i, j, 1, m) == get_hs(h, n-i+1, m-j+1, n, 1);
            if (valid) {
                ll r = (i+2*(n-i));
                ll c = ((m-j+1)+2*(j-1));
                ans = min(ans, r * c - n * m);
            }
        }
    }
    cout << ans << "\n";
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 

    Pow1[0] = { 1, 1 };
    Pow2[0] = { 1, 1 };
    for (int i = 1; i <= N; ++i) {
        Pow1[i] = Pow1[i-1] * p1;
        Pow2[i] = Pow2[i-1] * p2;
    }

    int t = 1;
    cin >> t;
    while (t--) { solve(); }
}
```
