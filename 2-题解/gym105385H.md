---
tags:
  - 题解
  - 二分图/二分图匹配
aliases:
  - Stop the Castle
---
## [gym105385H. Stop the Castle](https://codeforces.com/gym/105385/problem/H)

能相互打到的一对塔建点，一个障碍物最多阻拦横纵两对能互相攻击的塔。
如果横向的一对塔和纵向的一对塔有交叉点则连边，原问题等价于二分图最大匹配。
先把这些交叉点填好，其他位置在连线上任选一点即可，如果相邻则无合法方案。

[***AC 代码***](https://codeforces.com/gym/105385/submission/344063339)

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

const int N = 1000 + 5;
int n, m;
int x1[N + 5], y1[N + 5], x2[N + 5], y2[N + 5];
int a[N + 5][N + 5];

vector<int> pos;
int len;
int getPos(int v) { return lower_bound(pos.begin(), pos.end(), v) - pos.begin() + 1; }

const int M = 1e6 + 5;
int cnt;
vector<pair<int,int>> node;
vector<int> G[M + 5];
int match[M + 5];
bool vis[M + 5], ok[M + 5];
bool dfs(int u)
{
    for (auto v: G[u]) {
        if (!vis[v]) {
            vis[v] = 1;
            if (!match[v] || dfs(match[v])) {
                match[v] = u;
                return 1;
            }
        }
    }
    return 0;
}

void solve()
{
    pos.clear();
    node.clear();
    for (int i = 1; i <= n; ++i) {
        x1[i] = y1[i] = 0;
    }
    for (int i = 1; i <= m; ++i) {
        x2[i] = y2[i] = 0;
    }
    for (int i = 1; i <= cnt; ++i) {
        G[i].clear();
        vis[i] = 0;
        match[i] = 0;
        ok[i] = 0;
    }
    cnt = 0;
    for (int i = 1; i <= len; ++i) {
        for (int j = 1; j <= len; ++j) {
            a[i][j] = 0;
        }
    }
    len = 0;

    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> x1[i] >> y1[i];
        pos.push_back(x1[i]); 
        pos.push_back(y1[i]); 
    }
    cin >> m;
    for (int i = 1; i <= m; ++i) {
        cin >> x2[i] >> y2[i];
        pos.push_back(x2[i]); 
        pos.push_back(y2[i]); 
    }
    sort(pos.begin(), pos.end());
    pos.erase(unique(pos.begin(), pos.end()), pos.end());
    len = pos.size();

    for (int i = 1; i <= n; ++i) {
        int xx = getPos(x1[i]);
        int yy = getPos(y1[i]);
        a[xx][yy] = i;
    }
    for (int i = 1; i <= m; ++i) {
        int xx = getPos(x2[i]);
        int yy = getPos(y2[i]);
        a[xx][yy] = -1;
    }

    for (int i = 1; i <= len; ++i) {
        for (int j = 1; j <= len; ++j) {
            if (a[i][j] <= 0) { continue; }
            int st = j;
            while (j + 1 < len && a[i][j + 1] == 0) { ++j; }
            ++j;
            if (j > len || a[i][j] <= 0) { continue; }
            node.emplace_back(a[i][st], a[i][j]);
            --j;
        }
    }
    for (int j = 1; j <= len; ++j) {
        for (int i = 1; i <= len; ++i) {
            if (a[i][j] <= 0) { continue; }
            int st = i;
            while (i + 1 < len && a[i + 1][j] == 0) { ++i; }
            ++i;
            if (i > len || a[i][j] <= 0) { continue; }
            node.emplace_back(a[st][j], a[i][j]);
            --i;
        }
    }
    cnt = node.size();

    for (int i = 1; i <= cnt; ++i) {
        auto [a, b] = node[i - 1];
        for (int j = i + 1; j <= cnt; ++j) {
            auto [c, d] = node[j - 1];
            if (x1[a] == x1[b] && y1[c] == y1[d]) {
                if (x1[c] < x1[a] && x1[a] < x1[d] && y1[a] < y1[c] && y1[c] < y1[b]) {
                    G[i].push_back(j);
                }
            }
        }
    }

    for (int i = 1; i <= cnt; ++i) {
        for (int j = 1; j <= cnt; ++j) { vis[j] = 0; }
        auto [a, b] = node[i - 1];
        if (x1[a] == x1[b] && dfs(i)) {
            ok[i] = 1;
        }
    }

    vector<pair<int,int>> ans;
    for (int i = 1; i <= cnt; ++i) {
        auto [a, b] = node[i - 1];
        if (ok[i]) {
            continue;
        }
        if (match[i]) {
            auto [c, d] = node[match[i] - 1];
            ans.emplace_back(x1[c], y1[a]);
        } else {
            if (x1[a] == x1[b]) {
                if (y1[a] == y1[b] - 1) { cout << "-1\n"; return; }
                ans.emplace_back(x1[a], y1[a] + 1);
            } else {
                if (x1[a] == x1[b] - 1) { cout << "-1\n"; return; }
                ans.emplace_back(x1[a] + 1, y1[a]);
            }
        }
    }

    cout << ans.size() << "\n";
    for (auto [u, v]: ans) {
        cout << u << " " << v << "\n";
    }
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int t = 1;
    cin >> t;
    while (t--) { solve(); }
}
```
