---
tags:
  - 题解
  - 最小生成树
aliases:
---
## [HDUC1172-1006. 景区建设](https://acm.hdu.edu.cn/contest/problem?cid=1172&pid=1006)

给出的公式非常奇特，注意到以下两个特点：

- 链接角上的两个传送器的花费为 $114\times100+5141\times100+919810\times10000<2^{34}$，因此应该尽可能地少建传送器
- $919810\times 1>114\times100+5141\times100$，链接传送器时应该优先选择高度差小的

如果一个点比它四周四个点都高，它肯定无法直接到达，必须建传送器。
传送器之间链接等价于构建最小生成树。考虑 Prim 算法，选择以高度最低点作为基准点，每次将一个点加入连通块，发现选择的点必然是外部高度最小的那个点。因此只需要把所有传送器按高度从小到大排序后依次链接即可。

[***AC 代码***](https://acm.hdu.edu.cn/contest/view-code?cid=1172&rid=27674)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

const int dx[]={0,0,1,-1};
const int dy[]={1,-1,0,0};

void solve()
{
	int n, m;
	cin >> n >> m;
    vector h(n+1, vector<int>(m+1));
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            cin >> h[i][j];
        }
    }
    vector<pair<int,int>> p;
    p.emplace_back(1, 1);
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            if (i == 1 && j == 1) { continue; }
            bool gre = true;
            for (int d = 0; d < 4; ++d) {
                int x = i + dx[d];
                int y = j + dy[d];
                if (1 <= x && x <= n && 1 <= y && y <= m) {
                    gre &= (h[i][j] > h[x][y]);
                }
            }
            if (gre) { p.emplace_back(i, j); }
        }
    }
    sort(p.begin(), p.end(), [&](auto a, auto b){
        auto [x, y] = a;
        auto [u, v] = b;
        return h[x][y] < h[u][v];
    });
    ll ans = 0;
    for (int i = 1; i < int(p.size()); ++i) {
        auto [x, y] = p[i];
        auto [u, v] = p[i-1];
        ans += 114L * abs(x-u) + 5141L * abs(y-v) + 919810L * abs(h[x][y]-h[u][v]);
    }
    cout << (ans + (1LL<<34) * (p.size()-1)) << "\n";

}

int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
	int t = 1;
	cin >> t;
	while (t--) { solve(); }
}
```
