---
tags:
  - 题解
  - 图论建图
  - 二分图/二分图匹配
  - 贪心
aliases:
  - Perfect Matching
---
## [gym104128J. Perfect Matching](https://codeforces.com/gym/104128/problem/J)

$|i-j|=|a_i-a_j|$ 等价于 $a_i+i=a_j+j$ 或 $a_i-i=a_j-j$，可以将 $(i,a_i)$ 视为二维平面上的一个点，横坐标或纵坐标相同的点之间有连边。
我们对一个连通块内的点进行讨论。
注意到一个坐标对应的所有点之间是一张完全图，无法在有限时间内完成建图。
此时需要用到一个 trick：对坐标拆点，把横坐标和纵坐标视为两个点，把原来的点视作横纵坐标两点间的边。此时问题转化为，将图拆为若干条长度为 $2$ 的链。
后半段和 2024 济南 I 倒吊人很像
我们对原图求出任意一棵 dfs 树，从底向上进行构造，考虑当前节点除连向父亲外的若干条边，如果这些边是偶数条，那么两两匹配，把连向父亲的边留到处理父亲时分配。如果边是奇数条，则将连向父亲的边也加入匹配。

[***AC 代码***](https://codeforces.com/gym/104128/submission/342750233)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1e5 + 5;
int n, lcnt, rcnt, a[N + 5], deg[(N << 1) + 5], dep[(N << 1) + 5];
vector<pair<int, int>> ans;
vector<pair<int, int>> G[(N << 1) + 5];
bool vis[(N << 1) + 5];

int bfs(int s)
{
    queue<int> q;
    q.push(s);
    vis[s] = 1;

    int ret = 0;

    while (!q.empty()) {
        int u = q.front(); q.pop();

        ret += deg[u];
        
        for (auto [v, id] : G[u]) {
            if (vis[v]) {
                continue;
            }
            vis[v] = 1;
            q.push(v);
        }
    }

    return ret / 2;
}

int dfs(int u, int fa, int fr)
{
    dep[u] = dep[fa] + 1;
    vector<int> vec;
    for (auto [v, id]: G[u]) {
        if (v == fa) {
            continue;
        }
        if (dep[v] > 0) {
            if (dep[v] < dep[u]) {
                vec.push_back(id);
            }
        } else {
            int t = dfs(v, u, id);
            if (t > 0) {
                vec.push_back(t);
            }
        }
    }

    while (vec.size() > 1) {
        int x = vec.back(); vec.pop_back();
        int y = vec.back(); vec.pop_back();
        ans.emplace_back(x, y);
    }
    if (vec.size() == 1) {
        ans.emplace_back(vec.back(), fr);
        return -1;
    } else {
        return fr;
    }
}

void solve()
{
    cin >> n;

    ans.clear();
    for (int i = 1; i <= 2 * n; ++i) {
        G[i].clear();
        deg[i] = 0;
        vis[i] = 0;
        dep[i] = 0;
    }

    unordered_map<int, int> L, R;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        L[a[i] - i] = 0;
        R[a[i] + i] = 0;
    }

    lcnt = 0;
    rcnt = 0;
    for (auto &[x, t] : L) {
        t = ++lcnt;
    }
    for (auto &[x, t] : R) {
        t = ++rcnt;
    }

    for (int i = 1; i <= n; ++i) {
        int x = L[a[i] - i];
        int y = lcnt + R[a[i] + i];
        G[x].emplace_back(y, i);
        ++deg[x];
        G[y].emplace_back(x, i);
        ++deg[y];
    }

    for (int i = 1; i <= lcnt + rcnt; ++i) {
        if (!vis[i]) {
            if (bfs(i) & 1) {
                cout << "No\n";
                return;
            }
            dfs(i, 0, 0);
        }
    }

    cout << "Yes\n";
    for (auto [x, y] : ans) {
        cout << x << " " << y << "\n";
    }
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
```
