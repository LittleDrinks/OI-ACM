---
tags:
  - 题解
  - 贪心
  - 线段树/线段树二分
aliases:
  - Unique Array
---
## [CF1969E. Unique Array](https://codeforces.com/contest/1969/problem/E)

考虑每一个数 $x$，设其出现的位置为 $p_i$，那么对于每个 $i$，所有这样的区间必然合法：
$$
\begin{cases}
l\in(p_{i-1},p_i]\\
r\in[p_i,p_{i+1})
\end{cases}
$$
一个非常有道理的转换是：对于每一个左端点 $l$，我们记第一个不合法的右端点为 $r=f(l)$，此时我们必须在 $[l,f(l)]$ 这个区间上选一个位置进行替换。
这个问题等价于用最少的点数覆盖 $n$ 个形如 $[l,f(l)]$ 的区间。这是区间选点问题，按右端点排序，每次贪心地选择最小的右端点，然后把覆盖的区间删掉，重复即可。
接下来我们考虑如何求出 $f(l)$
根据之前的想法，我们对每一个数 $x$ 考虑。从左到右考虑每一个 $l$，当 $l=p_{i-1}+1$ 的时候，区间 $[p_i,p_{i+1})$ 整体加一，表示有一个数 $x$，使得右端点在 $[p_i,p_{i+1})$ 时合法，当 $l=p_i+1$ 的时候把这段区间减一。使用线段树二分找到第一个使 $[l,r]$ 最小值等于 $0$ 的 $r$ 即满足 $f(l)=r$。
时间复杂度 $O(n\log n)$

[***AC 代码***](https://codeforces.com/contest/1969/submission/355361261)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

template<typename T1,typename T2>
ostream& operator<<(ostream& os, const pair<T1,T2>& p) {
    return os << "( " << p.first << ", " << p.second << " )";
}
template<typename T>
ostream& operator<<(ostream& os, const vector<T>& v) {
    os << "[ ";
    if (v.size()) os << v[0];
    for (int i = 1; i < int(v.size()); ++i) {
        os << ", " << v[i];
    }
    return os << " ]";
}

template<typename T>
void gmax(T &x, T y) {
	x = max(x, y);
}

template<typename T>
void gmin(T &x, T y) {
	y = min(x, y);
}

#define lson (p << 1)
#define rson (p << 1 | 1)
#define m ((l+r)>>1)
template<typename Info, typename Lazy>
struct segmentTree {
    int n;
    vector<Info> a;
    vector<Lazy> t;

    segmentTree(int n): n(n), a(4 << __lg(n)), t(4 << __lg(n)) { }
    segmentTree(vector<Info>&& vec): segmentTree(vec.size()) {
        function<void(int,int,int)> build = [&](int p, int l, int r) -> void {
            if (r - l == 1) { a[p] = vec[l]; return; }
            build(lson, l, m);
            build(rson, m, r);
            push_up(p); 
        };
        build(1, 0, n);
    }

    void push_up(int p) {
        a[p] = a[lson] + a[rson];
    }

    void apply(int p, Lazy v) {
        a[p] = a[p] + v;
        t[p] = t[p] + v;
    }

    void spread_down(int p) {
        apply(lson, t[p]);
        apply(rson, t[p]);
        t[p] = Lazy();
    }

    template<typename F>
    Info dfs(int p, int l, int r, int x, int y, F&& op) {
        if (y <= l || r <= x) { return Info(); }
        if (x <= l && r <= y) { op(p,l,r); return a[p]; }
        spread_down(p);
        Info res;
        res = res + dfs(lson, l, m, x, y, op);
        res = res + dfs(rson, m, r, x, y, op);
        push_up(p);
        return res;
    }

    template<typename F>
    pair<int,Info> findFirst(int p, int l, int r, int x, int y, F&& pred) {
        if (y <= l || r <= x) { return {-1,Info()}; }
        if (x <= l && r <= y && !pred(a[p])) { return {-1,Info()}; }
        if (l == r-1) { return {l,a[p]}; }
        spread_down(p);
        pair<int,Info> res = findFirst(lson, l, m, x, y, pred);
        if (res.first == -1) {
            res = findFirst(rson, m, r, x, y, pred);
        }
        return res;
    }

    void modify(int x, int y, Lazy v) {
        dfs(1, 0, n, x, y+1, [&](int p, int l, int r){ apply(p, v); });
    }

    Info query(int x, int y) {
        return dfs(1, 0, n, x, y+1, [](int,int,int){});
    }

    int fpos(int x) {
        return findFirst(1, 0, n, x, n, [&](Info u){ return u.mn == 0; }).first;
    }
};
#undef lson
#undef rson
#undef m
const int inf = 1e9;
struct Info {
    int mn;
    Info(int mn = 0): mn(mn) { }
};
struct Lazy {
    int a;
    Lazy(int a = 0): a(a) { }
};
Info operator+ (Info u, Info v) {
    return Info(min(u.mn, v.mn));
}
Info operator+ (Info u, Lazy v) {
    return Info(u.mn + v.a);
}
Lazy operator+ (Lazy u, Lazy v) {
    return Lazy(u.a + v.a);
}

void solve()
{
    int n;
    cin >> n;
    vector<int> a(n + 1);
    vector pos(n + 1, vector<int>{0});
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        pos[a[i]].push_back(i);
    }
    vector seg(n + 2, vector<array<int,3>>());
    for (int i = 1; i <= n; ++i) {
        pos[i].push_back(n + 1);
        for (int j = 1; j + 1 < int(pos[i].size()); ++j) {
            seg[pos[i][j-1] + 1].push_back({pos[i][j], pos[i][j+1]-1, 1});
            seg[pos[i][j] + 1].push_back({pos[i][j], pos[i][j+1]-1, -1});
        }
    }
    segmentTree<Info, Lazy> t(n + 2);
    vector<int> f(n + 1);
    for (int i = 1; i <= n; ++i) {
        for (auto &[l, r, dt]: seg[i]) {
            t.modify(l, r, Lazy(dt));
        }
        f[i] = t.fpos(i);
        if (f[i] == -1) { f[i] = n + 1; }
    }

    vector<pair<int,int>> arr(n);
    for (int i = 1; i <= n; ++i) {
        arr[i - 1] = make_pair(f[i], i);
    }
    sort(arr.begin(), arr.end(), greater<>());
    int ans = 0;
    while (!arr.empty()) {
        auto [r, l] = arr.back(); arr.pop_back();
        if (r == n + 1) {
            break;
        }
        ++ans;
        while (!arr.empty() && arr.back().second <= r) {
            arr.pop_back();
        }
    }
    cout << ans << "\n";
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int t = 1;
    cin >> t;
    while (t--) { solve(); }
}
```
