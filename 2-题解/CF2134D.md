---
tags:
  - 题解
  - 树的直径与中心
aliases:
  - Sliding Tree
---
## [CF2134D. Sliding Tree](https://codeforces.com/contest/2134/problem/D)

*做这题前先注意到输出方式非常奇怪，交题前应该先想清楚 checker 怎么写。*
所有度数大于等于三的节点都需要进行操作。
考虑菊花图。肯定是选最长的一条子链作为 $a$，往其中一条链移动。最后的操作数等于点数减最长的两条链的长度（或者说点数减直径）。
这是一个可以利用的结论。接下来有两种思考路径，一种是贪心，一种是 DP。
从贪心的角度考虑。思考答案的下界。
当整棵树没有变成链之前，其直径上必然存在一个度数大于等于 $3$ 的点，选择它作为 $b$ 点，直径上的一点作为 $a$ 点，不在直径上的一点作为 $c$ 点，就可以让树的直径加一。每次操作最多让树的直径加一，操作数的下界其实是点数减直径长度，而按照上述方法就可以构造出一组操作序列，使得每次直径长度加一。
因此，答案操作序列只需要满足：① $a$ 点在直径上，② $b$ 点在直径上且度数大于等于 $3$，③ $c$ 点不在直径上

[***AC 代码***](https://codeforces.com/contest/2134/submission/335775534)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

void solve()
{
    int n;
    cin >> n;
    vector G(n+1, vector<int>());
    vector<int> deg(n+1);
    for (int i = 1; i < n; ++i) {
        int u, v;
        cin >> u >> v;
        G[u].push_back(v); ++deg[u];
        G[v].push_back(u); ++deg[v];
    }

    if (all_of(deg.begin(), deg.end(), [](int x){ return x <= 2; })) {
        cout << "-1\n"; return;
    }

	int mxd=0, V=0;
	vector<int> f(n+1);
	function<void(int,int,int)> dfs = [&](int u, int fa, int d){
	    f[u] = fa;
	    if (d > mxd) {
	        mxd = d;
	        V = u;
	    }
	    for (auto v: G[u]) {
	        if (v != fa) {
	            dfs(v, u, d+1);
	        }
	    }
	};
	
	// 第一次 dfs，找端点
	mxd = 0;
	dfs(1, 0, 1);
	
	// 第二次 dfs，走直径
	mxd = 0;
	int s = V;
	dfs(V, 0, 1);
	int t = V;
	
	// 把直径存入 vector
	vector<int> R{t};
	while (t != s) {
	    t = f[t];
	    R.push_back(t);
	}

    for (int i = 1; i < int(R.size()); ++i) {
        if (deg[R[i]] >= 3) {
            int u = 0;
            for (auto v: G[R[i]]) {
                if (v == R[i-1]) { continue; }
                if (i + 1 < int(R.size()) && v == R[i+1]) { continue; }
                u = v;
                break;
            }
            assert(u != 0);
            cout << R[i-1] << " " << R[i] << " " << u << "\n";
            return;
        }
    }
    assert(false);
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int t = 1;
    cin >> t;
    while (t--) { solve(); }
}
```
