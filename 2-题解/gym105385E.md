---
tags:
  - 题解
  - 线段树/优化建图
aliases:
  - Sensors
---
## [gym105385E. Sensors](https://codeforces.com/gym/105385/problem/E)

一个传感器向一段区间上的球连边，考虑线段树优化建图，将一整段区间拆成至多 $\log n$ 个区间，当每个区间只剩一个和零个红球时才将修改下放到传感器上。
时间复杂度 $O(n\log n)$

[***AC 代码***](https://codeforces.com/gym/105385/submission/344024555)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

const int N = 5e5 + 5;
int n, m, num[N + 5];
ll ans = 0;

#define lson (p << 1)
#define rson (p << 1 | 1)
#define m ((l + r) >> 1)
int cnt[(N << 4) + 5], lazy[(N << 4) + 5];
vector<int> G[(N << 4) + 5];

void push_up(int p)
{
    cnt[p] = cnt[lson] + cnt[rson];
}

void build(int p, int l, int r) 
{
    G[p].clear();
    lazy[p] = 0;
    if (l == r - 1) {
        cnt[p] = 1;
        return;
    }
    build(lson, l, m);
    build(rson, m, r);
    push_up(p);
}

void modify(int p, int l, int r, int x, int d)
{
    if (x + 1 <= l || r <= x) {
        return;
    }
    cnt[p] += d;
    lazy[p] += d;
    if (cnt[p] <= 1 && lazy[p] < 0) {
        for (auto u: G[p]) {
            num[u] += lazy[p];
            if (num[u] == 1) {
                ans += 1LL * u * u;
            }
            if (num[u] == 0) {
                ans -= 1LL * u * u;
            }
        }
        lazy[p] = 0;
    }
    if (l == r - 1) {
        return;
    }
    modify(lson, l, m, x, d);
    modify(rson, m, r, x, d);
    push_up(p);
    return;
}

void add_edge(int p, int l, int r, int x, int y, int id) 
{
    if (r <= x || y <= l) {
        return;
    }
    if (x <= l && r <= y) {
        G[p].push_back(id);
        return;
    }
    add_edge(lson, l, m, x, y, id);
    add_edge(rson, m, r, x, y, id);
    push_up(p);
}
#undef lson
#undef rson
#undef m

void solve()
{
    cin >> n >> m;
    build(1, 0, n);
    for (int i = 1; i <= m; ++i) {
        int l, r;
        cin >> l >> r;
        ++r;
        add_edge(1, 0, n, l, r, i);
        num[i] = r - l;
        if (num[i] == 1) {
            ans += 1LL * i * i;
        }
    }
    cout << ans << " ";
    for (int i = 1; i <= n; ++i) {
        int a;
        cin >> a;
        a = (ans + a) % n;
        modify(1, 0, n, a, -1);
        cout << ans << " \n"[i == n];
    }
    ans = 0;
    for (int i = 1; i <= m; ++i) {
        num[i] = 0;
    }
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int t = 1;
    cin >> t;
    while (t--) { solve(); }
}
```
