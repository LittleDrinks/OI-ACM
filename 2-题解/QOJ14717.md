---
tags:
  - 题解
  - 树上启发式合并
aliases:
  - Label Matching
---
## [QOJ14717. Label Matching](https://qoj.ac/contest/2563/problem/14717)

按颜色开一个桶，$a$ 中出现某种颜色记作 $+1$，$b$ 中出现某种颜色记作 $-1$，最后桶中正数之和和 $b$ 中的 $0$ 抵消，负数之和和 $a$ 中的 $0$ 抵消。
使用 DSU on tree 可以在 $O(n\log n)$ 的时间内对每个节点处理出对应的桶。

[***AC 代码***](https://qoj.ac/submission/1603900)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 4e5 + 5;
int n, siz[N + 5], hvs[N + 5];
int L[N + 5], R[N + 5], dfn[N + 5], totdfn;
vector<int> G[N + 5];
int a[N + 5], b[N + 5], ans[N + 5];

void dfs_init(int u, int fa)
{
    siz[u] = 1;
    L[u] = ++totdfn;
    dfn[totdfn] = u;
    for (auto v: G[u]) {
        if (v == fa) { continue; }
        dfs_init(v, u);
        siz[u] += siz[v];
        if (hvs[u] == 0 || siz[v] > siz[hvs[u]]) {
            hvs[u] = v;
        }
    }
    R[u] = totdfn;
}

int s_po, s_ne, zero[2], colcnt[N + 5];

void add_col(int col, int t, int dt) 
{
    if (t == -1) {
        colcnt[col] += dt;
        if (dt == 1) {
            if (colcnt[col] <= 0) { --s_ne; }
            else                  { ++s_po; }
        } else if (dt == -1) {
            if (colcnt[col] >= 0) { --s_po; }
            else                  { ++s_ne; }
        }
    } else {
        zero[t] += dt;
    }
}

void add(int u, int dt)
{
    // a : +1
    // b : -1
    // zero[0] : cnt 0 in a
    // zero[1] : cnt 0 in b
    add_col(a[u], (a[u]==0? 0: -1), dt);
    add_col(b[u], (b[u]==0? 1: -1), (b[u] == 0? dt: -dt));
}

void dfs_solve(int u, int fa, bool keep)
{
    for (auto v: G[u]) {
        if (v != fa && v != hvs[u]) {
            dfs_solve(v, u, false);
        }
    }
    if (hvs[u]) {
        dfs_solve(hvs[u], u, true);
    }
    for (auto v: G[u]) {
        if (v != fa && v != hvs[u]) {
            for (int i = L[v]; i <= R[v]; ++i) {
                add(dfn[i], 1);
            }
        }
    }
    add(u, 1);
    if (zero[0] >= s_ne && zero[1] >= s_po) {
        ans[u] = 1;
    }
    if (keep) { return; }
    for (int i = L[u]; i <= R[u]; ++i) {
        add(dfn[i], -1);
    }
}

void solve()
{
    cin >> n;
    for (int i = 1; i <= n; ++i) { cin >> a[i]; }
    for (int i = 1; i <= n; ++i) { cin >> b[i]; }
    for (int i = 1; i < n; ++i) {
        int u, v;
        cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    dfs_init(1, 0);
    dfs_solve(1, 0, false);
    for (int i = 1; i <= n; ++i) { cout << ans[i]; }
    cout << "\n";

    s_po = s_ne = zero[0] = zero[1] = totdfn = 0;
    for (int i = 1; i <= n; ++i) {
        G[i].clear();
        ans[i] = 0;
        colcnt[i] = 0;
        siz[i] = 0;
        hvs[i] = 0;
        L[i] = 0;
        R[i] = 0;
        dfn[i] = 0;
    }
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
```
