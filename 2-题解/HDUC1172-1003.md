---
tags:
  - 题解
  - DP/SOSDP
aliases:
---
## [HDUC1172-1003. 奸商](https://acm.hdu.edu.cn/contest/problem?cid=1172&pid=1003)

长度为奇数的子串一定优秀。如果长度为 $2L$ 的子串优秀，则所有长度大于 $2L$ 的子串一定优秀。
如果 $len$ 为奇数，令 $len$ 加一。下文中 $len$ 为偶数。
用一个 $|\Sigma|=17$ 位的二进制串表示某些字母强制不选，比如 $\texttt{100}\ldots$ 表示 $\texttt{a}$ 强制不选。
如果一个状态 $msk$ 能使某个子串不优秀，则称这个状态非法。比如 $\texttt{abcd}\ (len=4)$，$msk=\texttt{11000}\ldots$ 时子串不优秀，则其非法。
对于一个非法状态 $msk$，其所有超集都非法，比如上例中，$\texttt{111000}\ldots,\texttt{110101}\ldots$ 等都非法。
可以 $O(n)$ 枚举长度恰为 $len$ 的子串，对于每个子串，再花 $O(n)$ 的时间求出令该子串不优秀的最小状态 $msk$，使用 SOSDP 在 $O(|\Sigma|\times2^{|\Sigma|})$ 的时间内标记所有非法状态的超集。对于每个合法状态，累加所有 $0$ 位置的花费，取最小值即为答案。
总时间复杂度 $O(T|\Sigma|2^{|\Sigma|}+Tn^2)$

[***AC 代码***](https://acm.hdu.edu.cn/contest/view-code?cid=1172&rid=27596)

```cpp
#include <bits/stdc++.h>
using namespace std;

void solve()
{
    int n;
    string s;
    array<int,17> w;
    int len;
    cin >> n >> s;
    for (auto &x: w) { cin >> x; }
    cin >> len;

    len += (len & 1);
    if (len > n) { cout << "0\n"; return; }

    vector<bool> ok(1<<17, 1);
    for (int i = 0, j = i + len - 1; j < n; ++i, ++j) {
        int msk = 0;
        for (int k = 0; k < len / 2; ++k) {
            if (s[i+k] != s[j-k]) {
                int p = min(s[i+k], s[j-k]) - 'a';
                msk |= 1 << p;
            } else {
                msk = 0;
                break;
            }
        }
        if (msk) { ok[msk] = 0; }
    }
    for (int k = 0; k < 17; ++k) {
        for (int i = 0; i < (1<<17); ++i) {
            if (i>>k&1) { ok[i] = ok[i] & ok[i^(1<<k)]; }
        }
    }
    int ans = 1e9;
    for (int i = 0; i < (1 << 17); ++i) {
        if (!ok[i]) { continue; }
        int cost = 0;
        for (int j = 0; j < 17; ++j) {
            if (!(i>>j&1)) { cost += w[j]; }
        }
        ans = min(ans, cost);
    }
    cout << ans << "\n";
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    int t = 1;
    cin >> t;
    while (t--) { solve(); }
}
```
