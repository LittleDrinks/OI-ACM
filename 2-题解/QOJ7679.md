---
tags:
  - 题解
  - 线性基
aliases:
  - Master of Both IV
---
## [QOJ7679. Master of Both IV](https://qoj.ac/contest/1404/problem/7679)

注意到 $\oplus_{i=1}^n a_i<2\max\{a\}$，$\mathrm{lcm}_{i=1}^n \ge \max\{a\}$，所以可能的情况只有 $xor=0$ 或 $xor=\max\{a\}$。
$xor=0$ 的情况等价于询问有多少个异或和为零的非空子序列。
考虑线性基。记线性基的大小为 $r$。
线性基的要求是：能表示出原序列任意子序列的异或和，并且内部任意多个数异或和不为零。
将原序列分为在线性基和不在线性基两部分。仅在线性基内部选数异或和不可能为零。任选若干个线性基外的数字构成序列，设其异或和为 $x$，必然可以在线性基内部选取若干个数凑出 $x$，使这两部分合起来的异或和为零。最后再去掉一个空序列，答案为 $2^{n-r}$。
$xor=\max\{a\}$ 的情况和上述问题同构。我们从小到大枚举 $a_i$，并钦定 $xor=a_i$，此时的答案就是 $a_{[1,i-1]}$ 异或和为零的子序列（可能为空）数量，答案为 $2^{i-r_i}$。
预处理 $[1,n]$ 所有数的因数，按上述过程求解，时间复杂度 $O(n\log^2n)$

[***AC 代码***](https://qoj.ac/submission/1394352)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int MOD = 998244353;
ll add(ll x, ll y) { return (x + y) % MOD; }
ll del(ll x, ll y) { return add(x, MOD-y); }
ll mul(ll x, ll y) { return (x * y) % MOD; }
ll qpow(ll a, ll b = MOD - 2) {
    ll res = 1;
    for (; b; b >>= 1, a = mul(a, a)) {
        if (b & 1) {
            res = mul(res, a);
        }
    }
    return res;
}

struct LinearBasis {
    static const int maxbase = 20;
    bool flag = false;
    ll a[maxbase + 1];
    int tot;
    LinearBasis() {
        memset(a, 0, sizeof a);
        tot = 0;
    }
    LinearBasis(ll *x, int n) {
        LinearBasis();
        build(x, n);
    }
    void build(ll *x, int n) {
        for (int i = 1; i <= n; ++i) insert(x[i]);
    }
    void clear() { memset(a, 0, sizeof a); }
    bool insert(ll t) {
        // 暴力插入一个数，维护的是一个上三角型的线性基矩阵，时间复杂度低，当待插入元素能插入时，返回true
        for (int i = maxbase; i >= 0; --i) {
            if (t & (1ll << i)) {
                if (!a[i]) {
                    a[i] = t;  // 这里表示插入成功
                    break;
                }
                t ^= a[i];
            }
        }
        if (t == 0) flag = true, tot++;
        return t;
    }
    bool query(ll t) {
        // 询问t是否可以被当前线性基表示，不插入
        if (t > queryMax()) return false;
        if (t == 0) return true;
        for (int i = maxbase; i >= 0; --i) {
            if (t & (1ll << i)) {
                if (!a[i]) {
                    return false;
                }
                t ^= a[i];
            }
        }
        return true;
    }
    void Insert(ll t) {
        // 插入一个线性基，利用高斯消元法维护一个对角矩阵
        for (int i = maxbase; i >= 0; --i) {
            if (t >> i & 1) {
                if (a[i])
                    t ^= a[i];
                else {
                    a[i] = t;
                    for (int j = i - 1; j >= 0; --j)
                        if (a[j] && (a[i] >> j & 1)) a[i] ^= a[j];
                    for (int j = i + 1; j <= maxbase; ++j)
                        if (a[j] >> i & 1) a[j] ^= a[i];
                    break;
                }
            }
        }
    }
    LinearBasis merge(const LinearBasis &l1, const LinearBasis &l2) {
        // 得到两个线性基的并
        LinearBasis ret = l1;
        for (int i = maxbase; i >= 0; --i)
            if (l2.a[i]) ret.insert(l2.a[i]);
        return ret;
    }
    LinearBasis intersection(const LinearBasis &l1, const LinearBasis &l2) {
        // 得到两个线性基的交
        LinearBasis all, ret, full;
        ret.clear();
        for (int i = maxbase; i >= 0; --i) {
            all.a[i] = l1.a[i];
            full.a[i] = 1ll << i;
        }
        for (int i = maxbase; i >= 0; --i) {
            if (l2.a[i]) {
                ll v = l2.a[i], k = 0;
                bool flag = true;
                for (int j = maxbase; j >= 0; --j) {
                    if (v & (1ll << j)) {
                        if (all.a[j]) {
                            v ^= all.a[j];
                            k ^= full.a[j];
                        } else {
                            // l2's basis is not in l1's;
                            flag = false;
                            all.a[j] = v;
                            full.a[j] = k;
                            break;
                        }
                    }
                }
                if (flag) {
                    ll v = 0;  // get intersection by k;
                    for (int j = maxbase; j >= 0; --j) {
                        if (k & (1ll << j)) {
                            v ^= l1.a[j];
                        }
                    }
                    ret.insert(v);
                }
            }
        }
        return ret;
    }
    // 询问最值
    ll queryMax() {
        ll ret = 0;
        for (int i = maxbase; i >= 0; --i)
            if ((ret ^ a[i]) > ret) ret ^= a[i];
        return ret;
    }
    ll queryMin() {
        for (int i = 0; i <= maxbase; ++i)
            if (a[i]) return a[i];
        return 0;
    }
    ll Kth_Max(ll k) {
        ll res = 0;
        for (int i = 62; i >= 0; i--)
            if (k & (1LL << i)) res ^= a[i];
        return res;
    }
} LB;

const int N=2e5;
vector<int> fac[N + 5];
int n, a[N + 5], cnt[N + 5];
ll ans = 0;

void solve() {
    cin >> n;
    ll ans = 0;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
    }
    sort(a + 1, a + n + 1);
    for (int i = 1; i <= n; ++i) {
        LB.clear();
        int m = 0;
        for (auto x: fac[a[i]]) {
            int c = cnt[x];
            if (c > 0) {
                bool v = LB.query(x);
                if (!v) {
                    LB.insert(x);
                    --c;
                }
                m += c;
            }
        }
        ans = add(ans, qpow(2, m));
        ++cnt[a[i]];
    }
    int r = 0;
    LB.clear();
    for (int i = 1; i <= n; ++i) {
        bool v = LB.query(a[i]);
        if (!v) {
            LB.insert(a[i]);
            ++r;
        }
    }
    ans = add(ans, del(qpow(2, n - r), 1));
    cout << ans << "\n";
    for (int i = 1; i <= n; ++i) {
        cnt[a[i]] = 0;
        a[i] = 0;
    }
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    for (int i = 1; i <= N; ++i) {
        for (int j = i; j <= N; j += i) {
            fac[j].push_back(i);
        }
    }
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
```
