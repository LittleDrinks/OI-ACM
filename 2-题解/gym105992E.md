---
tags:
  - 题解
  - 线段树
  - 时间复杂度/势能分析法
  - 线段树/势能线段树
aliases:
  - Djangle 的数据结构
---
## [gym105992E. Djangle 的数据结构](https://codeforces.com/gym/105992/problem/E)

使用懒标记线段树维护区间和、区间 $\gcd$ 和区间 $\mathrm{lcm}$

- 直接维护操作 1
- 操作 2 可以看作先对每个位置做 $a_i\leftarrow \gcd(a_i,x)$ 再求和
	- 对于 $\mathrm{lcm}\mid x$ 的区间，直接跳过
	- 否则暴力修改左右区间
- 当 $\gcd=\mathrm{lcm}$（区间全等）的时候打懒标记

---

一个数 $x$ 有 $\log x$ 个因数，不断取 $\gcd$ 最多降低 $\log x$ 次。
使用势能分析法。定义势能 $E(a)=\displaystyle\sum_{i=1}^n\log_2 a_i$
区间覆盖最多更新 $\log n$ 个节点，每个节点的势能最多增加 $\log_2 V$，势能最多增加 $O(\log n\log V)$
操作 2 会遍历若干个区间，每遍历到一个区间势能至少降低 $1$，只要在 $\mathrm{lcm}\mid x$ 的区间（势能无法降低）和全部相等（操作 1 增加势能的区间）退出，就能保证遍历到的区间数量最大为 $O(n\log n\log V)$
时间复杂度 $O(n\log n\log^2V)$，第二个 $\log_2V$ 是计算 $\gcd$ 的复杂度

[***AC 代码***](https://codeforces.com/gym/105992/submission/336534429)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

const int N = 1e5;

struct Info {
    ll s, len, _gcd, _lcm;
    Info() : s(0), len(0), _gcd(0), _lcm(0) {
    }
    Info(ll s, int len) : s(s), len(len), _gcd(s), _lcm(s) {
    }
    Info(ll s, int len, int _gcd, int _lcm)
        : s(s), len(len), _gcd(_gcd), _lcm(_lcm) {
    }
};

struct Lazy {
    ll v, g;
    Lazy() : v(-1), g(0) {
    }
    Lazy(int v, int g) : v(v), g(g) {
    }
};

ll vec[N + 5];

#define lson (p << 1)
#define rson (p << 1 | 1)
#define m ((l + r) >> 1)
Info a[N * 5 + 5];
Lazy t[N * 5 + 5];
void push_up(int p) {
    a[p].s = a[lson].s + a[rson].s;
    a[p].len = a[lson].len + a[rson].len;
    a[p]._gcd = gcd(a[lson]._gcd, a[rson]._gcd);
    a[p]._lcm = lcm(a[lson]._lcm, a[rson]._lcm);
}
void apply(int p, Lazy v) {
    if (v.v != -1) {
        a[p].s = 1LL * v.v * a[p].len;
        a[p]._gcd = a[p]._lcm = v.v;
        t[p].v = v.v;
        t[p].g = 0;
    }
    if (v.g != 0) {
        a[p].s = 1LL * gcd(a[p].s / a[p].len, v.g) * a[p].len;
        a[p]._gcd = gcd(a[p]._gcd, v.g);
        a[p]._lcm = gcd(a[p]._lcm, v.g);
        if (a[p]._gcd == a[p]._lcm) {
            t[p].g = gcd(t[p].g, v.g);
        }
    }
}
void spread_down(int p) {
    apply(lson, t[p]);
    apply(rson, t[p]);
    t[p] = Lazy();
}
void build(int p, int l, int r) {
    if (r - l == 1) {
        a[p] = Info(vec[l], 1);
        return;
    }
    a[p] = Info();
    t[p] = Lazy();
    build(lson, l, m);
    build(rson, m, r);
    push_up(p);
}
void modify1(int p, int l, int r, int x, int y, ll v) {
    if (y <= l || r <= x) {
        return;
    }
    if (x <= l && r <= y) {
        apply(p, Lazy(v, 0));
        return;
    }
    spread_down(p);
    modify1(lson, l, m, x, y, v);
    modify1(rson, m, r, x, y, v);
    push_up(p);
}
void modify2(int p, int l, int r, int x, int y, ll g) {
    if (y <= l || r <= x) {
        return;
    }
    if (g % a[p]._lcm == 0) {
        return;
    }
    if (x <= l && r <= y && a[p]._gcd == a[p]._lcm) {
        apply(p, Lazy(-1, g));
        return;
    }
    spread_down(p);
    modify2(lson, l, m, x, y, g);
    modify2(rson, m, r, x, y, g);
    push_up(p);
}
ll query(int p, int l, int r, int x, int y) {
    if (y <= l || r <= x) {
        return 0;
    }
    if (x <= l && r <= y) {
        return a[p].s;
    }
    ll s = 0;
    spread_down(p);
    s += query(lson, l, m, x, y);
    s += query(rson, m, r, x, y);
    return s;
}
#undef lson
#undef rson
#undef m

void solve() {
    int n, q;
    cin >> n >> q;
    for (int i = 0; i < n; ++i) {
        cin >> vec[i];
    }
    build(1, 0, n);
    while (q--) {
        int o, l, r;
        ll x;
        cin >> o >> l >> r >> x;
        --l;
        if (o == 0) {
            modify1(1, 0, n, l, r, x);
        } else {
            modify2(1, 0, n, l, r, x);
            cout << query(1, 0, n, l, r) << "\n";
        }
    }
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
```
