---
tags:
  - 题解
  - DP
aliases:
  - Bubble Sort
---
## [CF2146F. Bubble Sort](https://codeforces.com/contest/2146/problem/F)

从冒泡排序的性质出发思考 `sort(a)` 怎么求。
整个序列升序，等价于对于每个 $1\le i\le n$，前方没有比它大的数字。
记 $c_i$ 表示 $a_i$ 前面有多少个比它大的数字，每一轮冒泡排序会把一个最大值移动到最后，剩下位置 $c$ 会减一。因此 $\mathrm{sort}(a) = \max\{c_i\}$，$b$ 是 $c$ 的前缀最大值。
观察发现 $a$ 和 $c$ 是一一对应的，因此数有多少 $a$ 等价于数有多少 $c$，并且数 $c$ 会更方便。

> [!note] 正确性说明
> - 显然 $a$ 可以唯一生成对应的 $c$
> - $0\le c_i < i$，$c$ 的总数是 $n!$
> - 倒序还原 $a$，每次从未被选择的数字中选择第 $c_i$ 大的那一个，就可以唯一生成一个合法的 $a$

注意到 $b$ 一定是单调不降的，将题干中给的限制重写为：

- $b_l\le k$
- $b_{r+1} > k$

据此 DP 求 $c$。设 $f(i,j)$ 表示已经填了 $c_{[1,i]}$，并且最大值为 $j$ 的方案数，使用前缀和优化可以做到 $O(n^2)$
注意到 $m\le 10^3$，这是一个非常特征的条件，并且题干中的限制转化后只和 $l,r$ 两个点有关，因此我们考虑将有效的状态数压到 $O(m^2)$。
将 $k_i$ 从小到大排成序列 $v$，设 $dp(i,j)$ 表示填到了第 $i$ 个端点，且最大值在区间 $[v_{j-1}+1,v_j]$ 中。
设 $g(l,r,x)$ 表示将区间 $[l,r]$ 用不超过 $x$ 的数填充，且 $1\le c_i<i$ 的方案数，这个可以单次 $O(\log n)$ 计算
则有状态转移方程
$$
\begin{align}
dp(i,j) =  \\
&dp(i-1,j)\times g(p_{i-1}+1,i,v_j)  \\
&+ \sum_{k=1}^{j-1} dp(i-1,k)\times \bigg(g(p_{i-1}+1, p_i,v_j)-g(p_{i-1}+1,p_i,v_{j-1})\bigg)
\end{align}
$$
同样使用前缀和优化，时间复杂度 $O(m^2\log n)$

[***AC 代码***](https://codeforces.com/contest/2146/submission/339957885)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

const int MOD = 998244353;
ll add(ll x, ll y) {
    return (x + y) % MOD;
}
ll del(ll x, ll y) {
    return add(x, MOD - y);
}
ll mul(ll x, ll y) {
    return (x * y) % MOD;
}
ll qpow(ll a, ll b = MOD - 2) {
    ll res = 1;
    for (; b; b >>= 1, a = mul(a, a)) {
        if (b & 1) {
            res = mul(res, a);
        }
    }
    return res;
}

const int N = 1e6 + 5;
ll fac[N + 5], Inv[N + 5];
int lo[N + 5], up[N + 5];

void solve() {
    int n, m;
    cin >> n >> m;
    vector<int> v{-1, n - 1}, p{n};
    vector<tuple<int, int, int>> seg(m);
    for (int i = 0; i < m; ++i) {
        auto &[k, l, r] = seg[i];
        cin >> k >> l >> r;
        ++r;
        p.push_back(l);
        if (r <= n) {
            p.push_back(r);
        }
        v.push_back(k);
    }
    sort(p.begin(), p.end());
    p.erase(unique(p.begin(), p.end()), p.end());
    sort(v.begin(), v.end());
    v.erase(unique(v.begin(), v.end()), v.end());
    m = v.size() - 1;
    for (auto i : p) {
        lo[i] = 0;
        up[i] = m;
    } 
    for (auto [k, l, r] : seg) {
        up[l] = min(up[l], int(lower_bound(v.begin(), v.end(), k) - v.begin()));
        if (r <= n) {
            lo[r] =
                max(lo[r], int(lower_bound(v.begin(), v.end(), k) - v.begin()));
        }
    }

    auto calc = [&](int l, int r, int x) {
        // ll ans = 1;
        // for (int i = l; i <= r; ++i) {
        //     ans = mul(ans, min(i, x + 1));
        // }
        // return ans;
        if (r <= x + 1) {
            return mul(fac[r], Inv[l - 1]);
        } else if (x + 1 <= l) {
            return qpow(x + 1, r - l + 1);
        } else {
            ll ans = mul(fac[x], Inv[l - 1]);
            ans = mul(ans, qpow(x + 1, r - x));
            return ans;
        }
    };

    vector<ll> f(m + 1);
    vector<ll> s(m + 1);
    f[1] = 1;
    int last = 1;
    for (auto i : p) {
        for (int j = 1; j <= m; ++j) {
            s[j] = add(s[j - 1], f[j]);
        }
        for (int j = 1; j <= m; ++j) {
            if (lo[i] < j && j <= up[i]) {
                f[j] = mul(f[j], calc(last, i, v[j]));
                f[j] = add(f[j], mul(s[j - 1], del(calc(last, i, v[j]),
                                                   calc(last, i, v[j - 1]))));
            } else {
                f[j] = 0;
            }
        }
        last = i + 1;
    }
    cout << accumulate(f.begin() + 1, f.end(), 0LL, add) << "\n";
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    fac[0] = Inv[0] = 1;
    for (int i = 1; i <= N; ++i) {
        fac[i] = mul(fac[i - 1], i);
    }
    Inv[N] = qpow(fac[N]);
    for (int i = N - 1; i; --i) {
        Inv[i] = mul(Inv[i + 1], i + 1);
    }

    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
```
