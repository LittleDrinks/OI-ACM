---
tags:
  - 题解
  - 树状数组
  - DP
aliases:
  - 传送排序
---
## [HDUC1177-1004. 传送排序](https://acm.hdu.edu.cn/contest/problem?cid=1177&pid=1004)

答案的上界是 $n$，一种操作方法是在 $1$ 右边加一个传送门，然后把所有数字从大到小塞到传送门右边。
想要获得更小的答案，肯定需要指定若干只猫不进行传送操作。
考虑 DP，设 $dp(i)$ 表示把 $[1,i]$ 排序，且钦定 $i$ 不进行传送操作的最小方案数。在开头和结尾加上 $0$ 和 $n+1$ 解决 $1$ 和 $n$ 可能移动的问题，最终答案为 $dp(n+1)$。记 $loc_i$ 表示 $i$ 的位置。讨论上一个不进行传送操作的位置。
当 $loc_i>loc_{i-1}$ 时，可以钦定 $i-1$ 不进行传送操作，则有 $dp(i)\leftarrow\min (dp(i), dp(i-1))$，这步转移可以 $O(1)$ 完成
钦定 $j$ 为上一个不进行传送操作的数，则此时需要在 $i$ 前方插入一个传送门，把 $(j,i)$ 插进来，一共需要进行 $j-i$ 次操作。则有 $\displaystyle dp(i)\leftarrow\min_{j<i,loc_j<loc_i}\{ dp(j)+i-j\}$。分离下标，有 $dp(i)-i=\min\{dp(j)-j\}$，按值从小到大遍历序列，对下标开树状数组存 $dp(j)-j$ 然后取前缀 $\min$ 即可，时间复杂度 $O(\log n)$
总时间复杂度 $O(n\log n)$

[***AC 代码***](https://acm.hdu.edu.cn/contest/view-code?cid=1177&rid=13685)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

struct BIT {
    int n;
    vector<int> t;
    BIT(int n): n(n), t(n+1, 1e9) { }
    int lowbit(int x) { return x & -x; }
    void modify(int x, int d) {
        for (; x <= n; x += lowbit(x)) { t[x] = min(t[x], d); }
    }
    int query(int x) {
        int res = 0;
        for (; x; x -= lowbit(x)) { res = min(res, t[x]); }
        return res;
    }
};

void solve()
{
    int n;
    cin >> n;
    vector<int> a(n+2), loc(n+2);
    loc[0] = 1;
    loc[n+1] = n+2;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        loc[a[i]] = i+1;
    }

    BIT t(n+2);
    vector<int> dp(n+2, n);
    dp[0] = 0;
    t.modify(loc[0], 0);
    for (int i = 1; i <= n + 1; ++i) {
        dp[i] = min(dp[i], t.query(loc[i]) + i);
        if (loc[i-1] < loc[i]) { dp[i] = min(dp[i], dp[i-1]); }
        t.modify(loc[i], dp[i]-i);
    }
    cout << dp[n+1] << "\n";
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int t = 1;
    cin >> t;
    while (t--) { solve(); }
}

```
