---
tags:
  - 题解
  - 贪心
  - 二分
aliases:
  - Beautiful Dangos
---
## [QOJ14682. Beautiful Dangos](https://qoj.ac/contest/2558/problem/14682)

三个颜色能凑出一个相邻两项互不相同的序列，充要条件是
$$
a - 1 \leq b + c, \quad b - 1 \leq a + c, \quad c - 1 \leq a + b
$$

> [!note]- 证明
>  要用三种颜色填充一个序列，使得相邻元素颜色不同，设三种颜色的使用次数分别为 $a$, $b$, $c$（即 $\text{cnt\_col}[0] = a$, $\text{cnt\_col}[1] = b$, $\text{cnt\_col}[2] = c$），且 $a + b + c = n$。则存在这样的序列的充要条件为：
> 
> $$
> \max(a, b, c) \leq \left\lceil \frac{n}{2} \right\rceil
> $$
> 
> 等价地，条件可以写为：
> 
> $$
> a \leq b + c + 1, \quad b \leq a + c + 1, \quad c \leq a + b + 1
> $$
> 
> ### 证明
> 
> #### 必要性
> 
> 假设存在满足条件的序列。设出现次数最多的颜色为 $A$，出现次数为 $a$。由于相邻颜色不同，$a$ 个 $A$ 颜色元素至少需要 $a-1$ 个其他颜色的元素来隔开，因此：
> 
> $$
> b + c \geq a - 1 \quad \Rightarrow \quad a \leq b + c + 1
> $$
> 
> 同理可得其他两个不等式。因此条件是必要的。
> 
> #### 充分性
> 
> 如果条件满足，可以通过贪心算法构造序列：
> 
> - 从空序列开始
> - 每次选择与前一颜色不同且剩余数量最多的颜色
> 
> 下面证明该算法始终有效。设当前剩余颜色数量为 $a', b', c'$，满足：
> 
> $$
> a' \leq b' + c' + 1, \quad b' \leq a' + c' + 1, \quad c' \leq a' + b' + 1
> $$
> 
> **情况 1**：添加颜色 $A$（假设 $A$ 剩余最多）
> 
> 新数量为 $(a'-1, b', c')$，需要验证：
> 
> - $(a'-1) \leq b' + c' + 1$ ⇒ $a' \leq b' + c' + 2$ ✓
> - $b' \leq (a'-1) + c' + 1$ ⇒ $b' \leq a' + c'$ ✓（因 $a' \geq b'$）
> - $c' \leq (a'-1) + b' + 1$ ⇒ $c' \leq a' + b'$ ✓
> 
> **情况 2**：添加颜色 $B$（前一颜色为 $A$）
> 
> 新数量为 $(a', b'-1, c')$，需要验证：
> 
> - $a' \leq (b'-1) + c' + 1$ ⇒ $a' \leq b' + c'$ ✓（因添加 $A$ 前有 $a'+1 \leq b' + c' + 1$）
> - $(b'-1) \leq a' + c' + 1$ ⇒ $b' \leq a' + c' + 2$ ✓
> - $c' \leq a' + (b'-1) + 1$ ⇒ $c' \leq a' + b'$ ✓
> 
> 条件在每一步后仍然满足，且当剩余颜色总数大于零时，至少有两种颜色剩余，因此算法总能继续直到序列完成。
> 
> 综上，条件是充要的。

如果两侧限制颜色，等价于上述情况的中间过程，然后两端强制选择现在的颜色。因此条件可以写作
$$
\begin{cases}
a - 1 +[c_l=a]+[c_r=a]\leq b + c \\
b - 1+[c_l=a]+[c_r=a] \leq a + c \\
c - 1+[c_l=a]+[c_r=a] \leq a + b
\end{cases}
$$

二分最短长度，然后每次贪心选择满足不等式条件的颜色填入即可。

[***AC 代码***]()

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

unordered_map<char,int> get_id = { {'A', -1}, {'C', 0}, {'W', 1}, {'P', 2} };
unordered_map<int,char> get_col= { {-1, 'A'}, {0, 'C'}, {1, 'W'}, {2, 'P'} };

void solve()
{
    int n;
    string s;
    cin >> n >> s;
    s = "A" + s + "A";
    int minl = n, maxr = 0; 
    for (int i = 1; i <= n; ++i) {
        if (s[i] == s[i - 1]) {
            minl = min(minl, i);
            maxr = max(maxr, i - 1);
        }
    }
    
    if (maxr == 0) {
        cout << "Beautiful\n";
        return;
    }

    vector cnt(3, vector<int>(n + 1));
    for (int i = 1; i <= n; ++i) {
        for (int col = 0; col < 3; ++col) {
            cnt[col][i] = cnt[col][i - 1];
        }
        cnt[get_id[s[i]]][i]++;
    }

    auto get_cnt = [&](int l, int r) -> array<int,3> {
        return (array<int,3>){cnt[0][r]-cnt[0][l-1], cnt[1][r]-cnt[1][l-1], cnt[2][r]-cnt[2][l-1]};
    };

    auto check = [&](array<int,3> cnt, int col_l, int col_r) -> bool {
        int s = cnt[0] + cnt[1] + cnt[2];
        bool f = true;
        for (int k = 0; k < 3; ++k) {
            f &= (s - cnt[k] >= cnt[k] - 1 + (col_l == k) + (col_r == k));
        }
        return f;
    };

    auto query = [&](int len) {
        for (int i = max(1, maxr-len+1); i <= min(minl, n-len+1); ++i) {
            if (check(get_cnt(i, i+len-1), get_id[s[i-1]], get_id[s[i+len]])) {
                return i;
            }
        }
        return 0;
    };

    int L = 0, R = n + 1;
    while (L + 1 < R) {
        int m = ((L + R) >> 1);
        if (query(m)) {
            R = m;
        } else {
            L = m;
        }
    }

    if (R == n + 1) {
        cout << "Impossible\n";
        return;
    }

    int ansL = query(R);
    int ansR = ansL + R - 1;
    cout << "Possible\n" << ansL << " " << ansR << "\n";
    string ans;
    for (int i = 1; i < ansL; ++i) { ans += s[i]; }
    auto colcnt = get_cnt(ansL, ansR);
    int lst = get_id[s[ansL-1]];
    for (int i = ansL; i <= ansR; ++i) {
        for (int k = 0; k < 3; ++k) {
            if (k == lst || colcnt[k] == 0) {
                continue;
            }
            --colcnt[k];
            if (check(colcnt, k, get_id[s[ansR + 1]])) {
                ans += get_col[k];
                lst = k;
                break;
            }
            ++colcnt[k];
        }
    }
    for (int i = ansR + 1; i <= n; ++i) { ans += s[i]; }
    cout << ans << "\n";
    assert(ans.size() == n);
    for (int i = 1; i < n; ++i) {
        assert(ans[i] != ans[i - 1]);
    }
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int t = 1;
    cin >> t;
    while (t--) { solve(); }
}

```
