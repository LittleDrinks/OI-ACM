---
tags:
  - 题解
aliases:
  - Imagined Holly
---
## [QOJ14689. Imagined Holly](https://qoj.ac/contest/2558/problem/14689)

*indicies 不要看错*
以 $1$ 为根，$LCA(u,v)=a(1,u)\oplus a(1, v)\oplus a(u, v)$。
对每个点 $u$，可以通过 $lca(u,v)=v$ 确定 $v$ 为 $u$ 的祖先。
对每个点 $u$，可以通过 $\sum_v[lca(u,v)=u]$ 求出其子树大小。
点 $u$ 的直系父亲就是所有祖先中子树大小最小的那一个。

[***AC 代码***](https://qoj.ac/submission/1594217)

```cpp
#include <bits/stdc++.h>
using namespace std;

void solve()
{
    int n;
    cin >> n;
    vector a(n+1, vector<int>(n+1));
    for (int i = 1; i <= n; ++i) {
        for (int j = i; j <= n; ++j) {
            cin >> a[i][j];
        }
    }
    auto get = [&](int u, int v) {
        if (u > v) { swap(u, v); }
        return a[u][v];
    };
    auto lca = [&](int u, int v) {
        return get(1, u) ^ get(1, v) ^ get(u, v);
    };

    vector fath(n+1, vector<int>());
    vector<int> f(n + 1);
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (i == j) { continue; }
            int LCA = lca(i, j);
            assert(1 <= LCA && LCA <= n);
            if (lca(i, j) == i) {
                fath[j].push_back(i);
                ++f[i];
            }
        }
    }
    for (int i = 2; i <= n; ++i) {
        assert(!fath[i].empty());
        int fa = *min_element(fath[i].begin(), fath[i].end(), [&](int x, int y){ return f[x] < f[y]; });
        cout << i << " " << fa << "\n";
    }
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t = 1;
    // cin >> t;
    while (t--) {
        solve();
    }
}
```
