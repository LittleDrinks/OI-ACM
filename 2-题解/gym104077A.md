---
tags:
  - 题解
  - 分块
aliases:
  - Bridge
---
## [gym104077A. Bridge](https://codeforces.com/gym/104077/problem/A)

注意到加上一条边后 $a$ 最终会走到 $a+1$，而 $a+1$ 最终会走到 $a$，这其实就是把两个起点对应的终点交换了一下。于是得到一个结论：一个终点，能且仅能从某一个起点到达。
记 $f(i)$ 表示起点 $i$ 对应的终点是谁。初始时 $f(i)=i$，倒着扫一遍，遇到桥就交换相邻的 $f$，最终扫到 $1$ 时 $f$ 即为所求。这样做修改的复杂度是 $O(m)$，查询的复杂度是 $O(1)$。
*这类修改和查询复杂度不均衡的算法，启发我们往分块上思考。*
我们将横向 $B$ 个位置分成一块。记 $f(i,j)$ 表示 $i$ 经过了第 $j$ 个块后的终点在哪里，初始时 $f(i)=i$。
每次修改我们需要重构所在块，从 $b$ 处往前模拟，找到 $a$ 和 $a+1$ 会由哪两个位置到达，然后把这两个位置的 $f(i,j)$ 交换即可，时间复杂度 $O(B)$。
每次查询，我们可以从左到右按块模拟，时间复杂度 $O(\dfrac{m}{B})$
$n,m,q$ 同构时，取 $B=\sqrt{n}$ 有最小复杂度 $O(n\sqrt{n})$
参考了[这篇的代码](https://blog.csdn.net/SummerKisara/article/details/142370641)

[***AC 代码***](https://codeforces.com/gym/104077/submission/343850752)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1e5 + 5, S = 350 + 5;
int n, m, q, f[N + 5][S + 5];
map<int,int> bridge[N + 5];

void solve()
{
    cin >> n >> m >> q;

    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j <= m / S; ++j) {
            f[i][j] = i;
        }
    }

    while (q--) {
        int o, a;
        cin >> o >> a;
        if (o == 1) {
            int b;
            cin >> b;
            int bk = b / S;
            int x = a, y = a + 1;
            for (int j = b; j >= bk * S; --j) {
                if (bridge[x].count(j)) { x = bridge[x][j]; }
                if (bridge[y].count(j)) { y = bridge[y][j]; }
            }
            swap(f[x][bk], f[y][bk]);
            bridge[a][b] = a + 1;
            bridge[a + 1][b] = a;
        } else {
            for (int i = 0; i <= m / S; ++i) { a = f[a][i]; }
            cout << a << "\n";
        }
    }
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t = 1;
    // cin >> t;
    while (t--) {
        solve();
    }
}
```
