---
tags:
  - 题解
  - 线性基
  - 搜索
aliases:
  - 子集
---
## [HDUC1173-1012. 子集](https://acm.hdu.edu.cn/contest/problem?cid=1173&pid=1012)

$2\pu{MB}=2\times1024\times1024\pu{B}$，一个 `long long` $64$ 位，占据 $8\pu{B}$ 的空间，因此 $2\pu{MB}$ 空间可以存下 $262144$ 个 `long long`。
去掉【不能选相邻两数】的限制，这是一道线性基的板题。加上限制后，仍然从线性基的角度考虑，被插入线性基的数字在原序列中间隔一定小于三。考虑 ${\color{red}{a_1}},a_2,{\color{orange}{a_3}},a_4,{\color{red}a5}$，在已有 $a_1,a_5$ 的情况下，插入 $a_3$ 一定不会使答案变劣。
搜索，在位置 $p$ 时，枚举下一个插入线性基的位置是 $p+2$ 还是 $p+3$。这个搜索的复杂度等于被搜到的线性基数量。设 $g(i)$ 表示强制插入 $a_i$ 时线性基的数量，则
$$
g(i)=g(i-2)+g(i-3)
$$
使用如下代码
```python
f = [0] * 51
f[1] = f[2] = 1
for i in range(3, 51):
    f[i] = f[i-2] + f[i-3]
print(f[50]+f[49])
```
算得需要搜索的线性基有 $g(50)+g(49)=1221537$ 个，可以接受

[***AC 代码***](https://acm.hdu.edu.cn/contest/view-code?cid=1173&rid=23476)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

struct LinearBasis {
    static const int N=62;
    ll a[N+5];
    LinearBasis() { memset(a, 0, sizeof(a)); }
    bool insert(ll t) {
        for (int i = N; i >= 0; --i) {
            if (t >> i & 1) {
                if (!a[i]) {
                    a[i] = t;
                    break;
                }
                t ^= a[i];
            }
        }
        return t;
    }
    ll queryMax() {
        ll ret = 0;
        for (int i = N; i >= 0; --i) {
            if ((ret ^ a[i]) > ret) { ret ^= a[i]; }
        }
        return ret;
    }
};

const int N=50;
int n;
ll a[N+5], ans;
void dfs(int p, LinearBasis B)
{
    if (p > n) { ans = max(ans, B.queryMax()); return; }
    B.insert(a[p]);
    dfs(p+2, B);
    dfs(p+3, B);
}

void solve()
{
	cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
    }
    ans = 0;
    LinearBasis B;
    dfs(1, B);
    dfs(2, B);
    cout << ans << "\n";
}

int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
	int t = 1;
	cin >> t;
	while (t--) { solve(); }
}

```
