---
tags:
  - 题解
  - DP
aliases:
  - 编码器-解码器
---
## [gym105336D. 编码器-解码器](https://codeforces.com/gym/105336/problem/D)

先想子序列个数应该怎么做。
设 $f(x,y)$ 表示 $T$ 串区间 $[x,y)$ 作为子序列出现的次数，特别地，设 $f(i,i)=1$
将两个串拼接时有状态转移方程
$$
f(x,y) = \sum_{k=x}^{y}f_1(x,k)\times f_2(k,y)
$$
惊喜地发现这个形式和矩阵乘法是一样的，记第 $i$ 次拼接后的 $S'$ 的状态为矩阵 $f_i$，则有
$$
f_{i+1} = f_i\times ch_c \times f_i 
$$
其中，$ch_c$ 表示单个字符 $c$ 与 $T$ 的匹配情况。
时间复杂度 $O(|S|\cdot|T|^3)$

[***AC 代码***](https://codeforces.com/gym/105336/submission/336726423)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int MOD = 998244353;
ll add(ll x, ll y) {
    return (x + y) % MOD;
}
ll mul(ll x, ll y) {
    return (x * y) % MOD;
}

template <typename T>
vector<vector<T>> operator*(const vector<vector<T>> a, vector<vector<T>> b) {
    int n = a.size();
    int m = b.size();
    int p = b.front().size();
    vector c(n, vector<T>(p));
    for (int i = 0; i < n; ++i) {
        for (int j = i; j < p; ++j) {
            for (int k = i; k < m; ++k) {
                c[i][j] = add(c[i][j], mul(a[i][k], b[k][j]));
            }
        }
    }
    return c;
}

template <typename T>
vector<vector<T>> operator+(const vector<vector<T>> a, vector<vector<T>> b) {
    int n = a.size();
    int m = a.front().size();
    auto c = a;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            c[i][j] = add(c[i][j], b[i][j]);
        }
    }
    return c;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<vector<T>> &a) {
    for (auto &r : a) {
        for (auto x : r) {
            os << x << " ";
        }
        os << "\n";
    }
    return os;
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    string s, t;
    cin >> s >> t;
    int n = s.size();
    int m = t.size();
    unordered_map<char, vector<vector<ll>>> ch;
    for (char c = 'a'; c <= 'z'; ++c) {
        vector mat(m + 1, vector<ll>(m + 1));
        for (int i = 0; i <= m; ++i) {
            mat[i][i] = 1;
        }
        for (int i = 0; i < m; ++i) {
            if (t[i] == c) {
                mat[i][i + 1] = 1;
            }
        }
        ch[c] = mat;
    }
    vector<vector<ll>> ans = ch[s[0]];
    for (int i = 1; i < n; ++i) {
        ans = ans * ch[s[i]] * ans;
    }
    cout << ans[0][m] << "\n";
}
```
