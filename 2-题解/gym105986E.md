---
tags:
  - 题解
  - DP/树形DP/换根DP
  - 概率与期望
aliases:
  - 怯战蜥蜴 VI
---
## [gym105986E. 怯战蜥蜴 VI](https://codeforces.com/gym/105986/problem/E)

先特判所有叶子节点 $u$，答案为 $p_u$。
对于 $n>2$ 的情况，至少能找到一个非叶子节点，记作 $s$。
下记 $q_u=1-p_u$。
设 $f(u,i)$ 表示以 $s$ 为根，在 $u$ 的子树内从叶子走到 $u$，**至少**遇到 $i$ 个爪牙的概率。分在 $u$ 处是否遭遇爪牙两种情况讨论，有如下状态转移方程：
$$
\begin{cases}
f(u,0) = 1 \\
f(u,1) = p_u \\
f(u,i) = \underbrace{q_u\prod_{v\in son(u)} \bigg(f(v,i)\bigg)}_{u 不遭遇爪牙} + \underbrace{p_u\prod_{v\in son(u)} \bigg( f(v,i-1) \bigg)}_{u遭遇爪牙}
\end{cases}
$$
坎格鲁斯普雷希望找到爪牙数量最少的一条路径，所以如果希望到节点 $u$ 时遭遇了 $i$ 只爪牙（不妨设 $u$ 处未遇到爪牙），那么它的所有子树内都必须遭遇 $i$ 只爪牙，如果有一个儿子 $v$ 遭遇的爪牙数量小于 $i$，说明有路径能减少爪牙数量，那么坎格鲁斯普雷就一定不会选择遭遇 $i$ 只爪牙的路径。

---

从 $s$ 的答案出发进行换根。
记 $fa_u$ 表示以 $s$ 为根时 $u$ 的父节点。设 $g(u,i)$ 表示以 $u$ 为根，$fa_u$ 子树内至少需要遭遇 $i$ 只爪牙的概率。则有状态转移方程
$$
\begin{align}
g(u,i) =  \\
&q_{fa_u}\times g(fa_u,i)\times\prod_{v\in son(fa_u), v\ne u} \bigg(f(v,i)\bigg)  \\
+ \ & p_{fa_u}\times g(fa_u,i-1)\times\prod_{v\in son(fa_u),v\ne u}\bigg( g(v,i-1) \bigg)
\end{align}
$$
这个状态转移方程和 $f(u,i)$ 本质上是一样的，只不过需要排除 $u$ 的答案。注意实现时如果使用先乘 $f(u)$ 再除以 $f(u)$ 的方式，会被 $f(u)\equiv 0$ 的情况卡掉。应该采用前缀积和后缀积的方式进行实现。

---

最后考虑如何计算答案。先特判一下叶子节点。对于非叶子节点，同样分 $u$ 处会不会遭遇爪牙两种情况讨论。注意 $f,g$ 表示至少遇到 $i$ 只爪牙，相当于有这点概率会【额外加一】，或者说是一个底为次数、高为概率的三角形面积横着算，于是有
$$
ans_u=\sum_{i=1}^{n} \left(
\begin{align}
&q_u\bigg(g(u,i)\times\prod_{v\in son(u)} f(v,i)\bigg) \\
+ \ & p_u\bigg(g(u,i-1)\times \prod_{v\in son(u)}f(v,i-1)\bigg)
\end{align}
\right)
$$

[***AC 代码***](https://codeforces.com/gym/105986/submission/330170967)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int MOD = 998244353;
ll add(ll x, ll y) { x%=MOD; y%=MOD; return (x + y) % MOD; }
ll del(ll x, ll y) { x%=MOD; y%=MOD; return add(x, MOD-y); }
ll mul(ll x, ll y) { x%=MOD; y%=MOD; return (x * y) % MOD; } 

ll qpow(ll a, ll b = MOD - 2) 
{
    ll res = 1;
    for (; b; b >>= 1) {
        if (b & 1) { res = mul(res, a); }
        a = mul(a, a);
    }
    return res;
}

const int N=3005;
int n, s, deg[N], siz[N], son[N];
vector<int> G[N];
ll p[N], q[N], f[N][N], g[N][N], c[N][N], ans[N];
ll prod[N][N], pre[N][N], suf[N][N], h[N][N];

void dfs1(int u, int fa)
{
    son[u] = 0;
    fill(c[u], c[u]+n+1, 1);
    if (fa) { G[u].erase( find(G[u].begin(), G[u].end(), fa) ); }
    for (auto v: G[u]) {
        assert(v != fa);
        ++son[u];
        dfs1(v, u);
        for (int i = 0; i <= n; ++i) {
            c[u][i] = mul(c[u][i], f[v][i]);
        }
    }
    f[u][0] = 1;
    if (son[u] == 0) {
        f[u][1] = p[u];
    } else {
        for (int i = 1; i <= n; ++i) {
            f[u][i] = add( mul(q[u],c[u][i]), mul(p[u],c[u][i-1]) );
        }
    }
}

void dfs2(int u, int fa)
{
    // 求以 u 为根的答案
    if (!fa) {
        for (int i = 1; i <= n; ++i) {
            ans[s] = add(ans[s], f[s][i]);
        }
    } else {
        for (int i = 1; i <= n; ++i) {
            ll A = add( mul(q[u],mul(c[u][i],g[u][i])), mul(p[u],mul(c[u][i-1],g[u][i-1])) );
            ans[u] = add(ans[u], A);
        }        
    }

    // 预处理前缀积
    for (int i = 0; i <= n; ++i) {
        fill(prod[i], prod[i]+son[u]+5, 1);
        fill(pre[i], pre[i]+son[u]+5, 1);
        fill(suf[i], suf[i]+son[u]+5, 1);
    }
    for (int id = 1; id <= son[u]; ++id) {
        int v = G[u][id-1];
        assert(v != fa);
        for (int i = 1; i <= n; ++i) {
            prod[i][id] = mul( prod[i][id], f[v][i] );
        }
    }
    for (int i = 0; i <= n; ++i) {
        for (int id = 1; id <= son[u]; ++id) {
            pre[i][id] = mul(pre[i][id-1], prod[i][id]);
        }
        for (int id = son[u]; id; --id) {
            suf[i][id] = mul(suf[i][id+1], prod[i][id]);
        }
        for (int id = 1; id <= son[u]; ++id) {
            h[i][id] = mul(pre[i][id-1], suf[i][id+1]);
            if (fa) {
                h[i][id] = mul(h[i][id], g[u][i]);
            }
        }
    }
    
    // 求子节点的 g
    for (int id = 1; id <= son[u]; ++id) {
        int v = G[u][id-1];
        g[v][0] = 1;
        for (int i = 1; i <= n; ++i) {
            g[v][i] = add( mul(q[u],h[i][id]), mul(p[u],h[i-1][id]) );
        }
    }
    for (auto v: G[u]) {
        dfs2(v, u);
    }
}

void solve()
{
    cin >> n;
    for (int i = 1; i <= n; ++i) { cin >> p[i]; }
    for (int i = 1; i <= n; ++i) {
        ll b; cin >> b;
        p[i] = mul(p[i], qpow(b));
        q[i] = del(1, p[i]);
    }

    for (int i = 1; i < n; ++i) {
        int u, v;
        cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
        ++deg[u];
        ++deg[v];
    }

    if (n == 2) { cout << p[1] << " " << p[2] << "\n"; return; }

    s = 1;
    while (deg[s] == 1) { ++s; }

    dfs1(s, 0);
    dfs2(s, 0);
    for (int i = 1; i <= n; ++i) {
        if (deg[i] == 1) { cout << p[i]; }
        else { cout << ans[i]; }
        cout << " \n"[i == n];
    }
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    int t = 1;
    // cin >> t;
    while (t--) { solve(); }
}
```
