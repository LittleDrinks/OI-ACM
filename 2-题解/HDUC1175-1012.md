---
tags:
  - 题解
  - 自适应辛普森法
  - 计算几何
aliases:
  - 海上的太阳
---
## [HDUC1175-1012. 海上的太阳](https://acm.hdu.edu.cn/contest/problem?cid=1175&pid=1012)

给定的山坡满足 $f'(x)\ge0$，是一个下凸函数。某幢建筑的影子必然会全部落在山坡上。
经过这幢建筑最高点的光线可以用过 $(X,Y)$ 和 $(u,f(u)+h_1)$ 的直线 $l(x)=kx+b$ 表示，下一幢建筑 $(v,f(v))$ 需要满足采光条件 $f(v)\ge l(v)$ 和距离条件 $\sqrt{(u-v)^2+(f(u)-f(v))^2}\ge\max(h_1,h_2)$，可以通过二分法找到满足条件的下一幢建筑的位置。
观察给出的不满意度函数，肯定是每一幢建筑尽可能靠近原点时最优。$n$ 非常小，枚举建筑的相对顺序。通过上述二分法求出每幢建筑的位置。接下来考虑如何计算不满意度。
难点在于计算从原点到建筑物底部的曲线长度。这段长度可以用弧微分公式表示为
$$
\int_l^r\sqrt{f'(x)^2+1}\ \mathrm{d}x
$$
难以直接积分，但可以用自适应辛普森法求出近似解。

[***AC 代码***](https://acm.hdu.edu.cn/contest/view-code?cid=1175&rid=14644)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

void output(db x){
    static char s[25];
    sprintf(s,"%.4Le",x);
    for(int i:{0,1,2,3,4,5,6,7}) printf("%c",s[i]);
    printf("%c\n",s[strlen(s)-1]);
}

const int N=6, M=5;
const db EPS = 1e-10;
int n, m, x, y;
int a[M+5], b[M+5];

db f(db x) {
    db res = 0;
    for (int i = m; i >= 0; --i) { res = res * x + a[i]; }
    return res;
}

db ff(db x) {
    db res = 0;
    for (int i = m-1; i >= 0; --i) { res = res * x + b[i]; }
    return sqrtl(res * res + 1);
}

db simpson(db l, db r) {
    db mid = (l + r) / 2;
    return (r - l) * (ff(l) + 4 * ff(mid) + ff(r)) / 6;  // 辛普森公式
}

db asr(db l, db r, db eps, db ans,
           int step) {  // step是递归的下限
    db mid = (l + r) / 2;
    db fl = simpson(l, mid), fr = simpson(mid, r);
    if (abs(fl + fr - ans) <= 15 * eps && step < 0)
        return fl + fr + (fl + fr - ans) / 15;  // 足够相似的话就直接返回
    return asr(l, mid, eps / 2, fl, step - 1) +
           asr(mid, r, eps / 2, fr, step - 1);  // 否则分割成两段递归求解
}

db calc(db l, db r) {
    return asr(l, r, EPS, simpson(l, r), 7);
}

db calc(db p, int h1, int h2)
{
    db k = (y - f(p) - h1) / (x - p);
    db b = y - k * x;
    db l=0, r=1e9;
    while (r - l > EPS) {
        db m = (l + r) / 2;
        if (hypot(p-m, f(p)-f(m)) < max(h1, h2) || f(m) < k*m+b) {
            l = m;
        } else {
            r = m;
        }
    }
    return l;
}

void solve()
{
    cin >> n >> m >> x >> y;
    for (int i = 1; i <= m; ++i) { cin >> a[i]; }
    for (int i = 0; i < m; ++i) {
        b[i] = a[i+1] * (i+1);
    }
    vector<pair<int,int>> bu(n);
    for (auto& [h, w]: bu) { cin >> h >> w; }
    sort(bu.begin(), bu.end());
    db ans = DBL_MAX;
    do {
        db res = 0;
        db u = 0;
        for (int i = 1; i < n; ++i) {
            u = calc(u, bu[i-1].first, bu[i].first);
            res += bu[i].second * calc(0, u);
        }
        ans = min(ans, res);
    } while (next_permutation(bu.begin(), bu.end()));
    output(ans);
}

int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
	int t = 1;
	cin >> t;
	while (t--) { solve(); }
}

```
