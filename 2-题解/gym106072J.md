---
tags:
  - 题解
  - 哈希
  - 构造
aliases:
  - Reconstruct the tree
---
## [gym106072J. Reconstruct the tree](https://codeforces.com/gym/106072/problem/J)

只有叶子才可能出现在 $m$ 组关系中。
直观的想法是构造一张菊花图，把叶子分成若干组挂在菊花上。
注意到每组叶子的连边情况都是相同的，并且必须向其他所有组都连边。可以用哈希分组并判断合法性。
构造时需要特判一些边界情况。下称不在任何一组内的点为无用点。

- 当 $n=2$ 时，直接连边就合法
- 当只有一个无用点时，所有组大小只能为 $1$，此时是一张标准的菊花图
- 当只有两组叶子时，可以将无用点排成一条链（只需要至少一个无用点），然后把两组叶子挂在两侧
- 当无用点数量大于叶子组数时，可以将一个无用点放在中间，其他无用点向其连边，然后每组叶子挂在最外面

[***AC 代码***](https://codeforces.com/gym/106072/submission/339397492)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ull = unsigned long long;

const int N = 2e5;
mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());
ull h[N + 5], a[N + 5], colhs[N + 5], allhs;
int colcnt, col[N + 5];

void solve() {
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= m; ++i) {
        int u, v;
        cin >> u >> v;
        a[u] ^= h[v];
        a[v] ^= h[u];
    }
    vector<ull> val;
    for (int i = 1; i <= n; ++i) {
        if (a[i] > 0) {
            val.push_back(a[i]);
        }
    }
    sort(val.begin(), val.end());
    val.erase(unique(val.begin(), val.end()), val.end());
    colcnt = val.size();

    vector<int> nd;
    for (int i = 1; i <= n; ++i) {
        if (a[i]) {
            col[i] =
                lower_bound(val.begin(), val.end(), a[i]) - val.begin() + 1;
            colhs[col[i]] ^= h[i];
            allhs ^= h[i];
        } else {
            nd.push_back(i);
        }
    }

    bool valid = true;
    for (int i = 1; i <= n; ++i) {
        if (col[i]) {
            valid &= (a[i] == (allhs ^ colhs[col[i]]));
        }
    }

    vector<pair<int, int>> E;
    if (colcnt == 2 && n == 2) {
        E.emplace_back(1, 2);
    } else if (valid && nd.size() == 1) {
        vector<bool> vis(colcnt + 1);
        for (int i = 1; i <= n; ++i) {
            if (col[i]) {
                if (vis[col[i]]) {
                    valid = false;
                }
                vis[col[i]] = true;
                E.emplace_back(nd[0], i);
            }
        }
    } else if (valid && colcnt == 2 && nd.size() > 0) {
        for (int i = 1; i < int(nd.size()); ++i) {
            E.emplace_back(nd[i - 1], nd[i]);
        }
        for (int i = 1; i <= n; ++i) {
            if (col[i] == 1) {
                E.emplace_back(nd[0], i);
            } else if (col[i] == 2) {
                E.emplace_back(nd.back(), i);
            }
        }
    } else if (valid && nd.size() > colcnt) {
        for (int i = 1; i < int(nd.size()); ++i) {
            E.emplace_back(nd[0], nd[i]);
        }
        for (int i = 1; i <= n; ++i) {
            if (col[i]) {
                E.emplace_back(nd[col[i]], i);
            }
        }
    } else {
        valid = false;
    }

    if (valid) {
        cout << "YES\n";
        for (auto [x, y] : E) {
            cout << x << " " << y << "\n";
        }
    } else {
        cout << "NO\n";
    }

    allhs = 0;
    for (int i = 1; i <= n; ++i) {
        a[i] = 0;
        col[i] = 0;
    }
    for (int i = 1; i <= colcnt; ++i) {
        colhs[i] = 0;
    }
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    for (int i = 1; i <= N; ++i) {
        h[i] = rng();
    }
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
```
