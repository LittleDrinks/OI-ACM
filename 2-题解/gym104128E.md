---
tags:
  - 题解
aliases:
  - Color the Tree
---
## [gym104128E. Color the Tree](https://codeforces.com/gym/104128/problem/E)

先考虑一条链怎么做。
一个深度为 $d$ 的点只能被深度小于等于 $d$ 的点染色，如果是一条链，那么将一个点染色的代价是 
$$\min_{i=0}^{d-1}a_i$$
拓展一下，如下图。我们考虑只染色同一层的连续一段，比如只染色图中的 $x$，那么代价是 $x,1,2,3,4$ 四个节点中花费最小的那一个，即 $\min_{i=0}^4 a_i$。但是这步操作并不一定会出现在最终的答案内，因为位于上层的点花费大，但是它能染色更多的节点。
![[8d4f92b8ceb5bba9158665bb9c0c046c.jpeg|300]]
我们考虑 $x$ 最终可能有几种有效的染色方案。图中 $2,3$ 两个节点子树内，深度和 $x$ 相同的点集是一样的，那么此时 $2,3$ 两个点中花费较大的那一个点就是无用操作。而如果选择从 $1$ 号点进行操作，它能染色更多的节点，就算 $a_4>a_3,a_2$，一号点也可能更优。
对于节点 $x$，每多一种有效操作，lca 就会向上移动，并且同一层要多一个点，此时需要增加的点的数量为 $2,3,\ldots$，因此每个点的有效操作数是 $O(\sqrt{n})$ 级别的。
我们将所有节点以深度为第一关键字，dfs 序为第二关键字排序，每次考虑一层的节点如何染色。
设 $f_d(i)$ 表示将深度为 $d$ 的前 $i$ 个节点染色的最小花费，每次二分求出第一个使 lca 变化的点 $r$，记 $p=lca(i,i+1,\ldots,r-1)$，$q=lca(i,i+1,\ldots,r)$，则有
$$
f_d(i-1) + \min_{i=d-dep_{p}}^{d-dep_{q}-1} a_i \to f_d(r)
$$
时间复杂度 $O(n\sqrt{n}\log n)$

[***AC 代码***](https://codeforces.com/gym/104128/submission/342853960)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

template <typename T>
struct ST {
    int n=0, I=0;
    vector<int> Log;
    vector<vector<T>> st;
    function<T(T,T)> op;
    ST() { }
    ST(const vector<T>& a, function<T(T,T)> op): n(a.size()), Log(vector<int>(n+1)), op(op) {
        for (int i = 2; i <= n; ++i) {
        	I=Log[i]=Log[i/2]+1;
        }
        st.assign(I+1, vector<T>(n));
        copy(a.begin(), a.end(), st[0].begin());
        for (int i = 1; i <= I; ++i) {
            for (int j = 0; j+(1<<(i-1)) < n; ++j) {
                st[i][j] = op( st[i-1][j], st[i-1][j+(1<<(i-1))] );
            }
        }
    }
    T query(int l, int r) {
    	assert(l <= r);  // l > r 时的返回值需要特殊定义
        int s = Log[r-l+1];
        return op( st[s][l], st[s][r-(1<<s)+1] );
    }
};

const int N = 1e5+5;
const ll inf = 1e18;
int n;
int first[N + 5], dep[N + 5];
vector<int> G[N + 5], ver[N + 5];
vector<pair<int,int>> eular;
void dfs(int u, int fa)
{   // 预处理深度和欧拉序
    first[u] = eular.size();
    dep[u] = dep[fa] + 1;
    ver[dep[u]].push_back(u);
    eular.push_back( {dep[u], u } );
    for (int v: G[u]) {
        if (v != fa) {
            dfs(v, u);
            eular.push_back( {dep[u], u } );
        }
    }
}

ST<pair<int,int>> st;
int lca(int u, int v)
{
    u = first[u];
    v = first[v];
    if (u > v) { swap(u, v); }
    return st.query(u, v).second;
}

void solve()
{
    cin >> n;
    vector<ll> a(n);
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
    }
    ST<ll> ma(a, [](auto x, auto y){ return min(x, y); });

    for (int i = 1; i < n; ++i) {
        int u, v;
        cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    dfs(1, 0);
    st = ST<pair<int,int>>(eular, [](auto x, auto y){ return min(x, y); });

    ll ans = 0;
    for (int d = 1; d <= n; ++d) {
        if (ver[d].empty()) { continue; }
        int siz = ver[d].size();
        vector<ll> f(siz + 1, inf);
        f[0] = 0;
        for (int j = 1; j <= siz; ++j) {
            int cur = j - 1;
            while (cur < siz) {
                int nowlca = lca(ver[d][j - 1], ver[d][cur]);
                int l = cur, r = siz;
                while (l + 1 < r) {
                    int m = ((l + r) >> 1);
                    if (lca(ver[d][j - 1], ver[d][m]) != nowlca) {
                        r = m;
                    } else {
                        l = m;
                    }
                }
                int al = d - dep[nowlca];
                int ar = d - 1;
                if (r < siz) {
                    int nxtlca = lca(ver[d][j - 1], ver[d][r]);
                    ar = d - dep[nxtlca] - 1;
                }
                ll val = ma.query(al, ar);
                f[r] = min(f[r], f[j - 1] + val);
                cur = r;
            }
        }
        ans += f[siz];
    }
    cout << ans << "\n";

    eular.clear();
    for (int i = 1; i <= n; ++i) {
        dep[i] = 0;
        first[i] = 0;
        G[i].clear();
        ver[i].clear();
    }
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
```
