---
tags:
  - 题解
  - DP/数位DP
aliases:
  - Sum of Log
---
## [gym102900C. Sum of Log](https://codeforces.com/gym/102900/problem/C)

对式子展开得到
$$
\begin{align}
&\sum_{i=0}^{X}\sum_{j=[i=0]}^{Y}[i\&j=0]\lfloor\log_2(i+j)+1\rfloor \\
&=\sum_{k=0}^{\log_2 n}(k+1)\times\sum_{i=0}^X\sum_{j=0}^{Y}[i\& j=0][\log_2(i+j)=k]
\end{align}
$$
枚举 $k$，记 $dp(p,la,lb)$ 表示已经填了 $[p+1,len]$ 上的数字，$i,j$ 是否达到上限用 $la$ 和 $lb$ 表示。枚举 $p$ 位上放的 $(0,0),(1,0),(0,1)$ 的情况向下记忆化搜索。注意因为我们要恰好让 $\log_2(i+j)=k$，所以在有前导零的情况下 $(0,0)$ 是非法的，需要特判。
如果只记录 $i,j$ 未达上限的情况，每枚举到一个 $k$ 都会向下枚举到最后一位，复杂度变为 $O(\log_2^2n)$，会 `TLE on 7` 。而如果把 $i,j$ 是否到达上限的四种情况 $dp(p,la,lb)$ 都记录下来，对于每一轮数据 $f$ 数组都需要清空，但可以保证复杂度是 $O(4\log_2n)$。

[***AC 代码***](https://codeforces.com/gym/102900/submission/330458593)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

const int MOD = 1e9+7;
ll add(ll x, ll y) { return (x + y) % MOD; }
ll mul(ll x, ll y) { return (x * y) % MOD; }

const int L=31;
ll f[L+5][2][2];
ll a, b;
ll dfs(int p, int la, int lb, bool lead0) 
{
    if (!p) { return 1; }
    auto& now = f[p][la][lb];
    if (!lead0 && ~now) { return now; } 
    int upa = (la ? (a>>(p-1)&1) : 1);
    int upb = (lb ? (b>>(p-1)&1) : 1);
    ll res = 0;
    for (int i = 0; i <= upa; ++i) {
        for (int j = 0; j <= upb; ++j) {
            if (i && j) { continue; }
            if (lead0 && i==0 && j==0) { continue; }
            res = add(res, dfs(p-1, la&&(i==upa), lb&&(j==upb), false));
        }
    }
    if (!lead0) { now = res; }
    return res;
}

void solve()
{
    memset(f, -1, sizeof(f));
    cin >> a >> b;
    ll ans = 0;
    for (int i = 1; i <= 31; ++i) {
        if (a < (1<<(i-1)) && b < (1<<(i-1))) { continue; }
        bool la = a < (1<<i);
        bool lb = b < (1<<i);
        ll t = dfs(i, la, lb, true);
        ans = add(ans, mul(t, i));
    }
    cout << ans << "\n";
}

int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
	int t = 1;
	cin >> t;
	while (t--) { solve(); }
}
```
