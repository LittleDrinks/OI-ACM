---
tags:
  - 题解
  - 博弈论
aliases:
  - HRPA
  - 斐波那契博弈
---
## [P6487 [COCI 2010/2011 #4 ] HRPA](https://www.luogu.com.cn/problem/P6487)

> [!note] 结论一：$n$ 为斐波那契数时，如果先手不全拿掉，则必败
> $n=1,2$ 时显然
> $n>2$ 时，设 $n=f(i-2)+f(i-1)$，分两类情况讨论。
> ①如果先手拿了大于等于 $f(i-2)$ 颗石头，后手一定可以一步拿完
> ②如果先手拿了小于 $f(i-2)$ 颗石头，此时相当于递归到 $f(i-2)$ 这个子问题。
> 由于 $n=1,2$ 时必败，由数学归纳可知先手必然会在这个子问题中失败，处理 $f(i-1)$ 这个子问题时由于无法一步取完，同理先手必败。因而此时先手必败

> [!note] 结论二（齐肯多夫表示法）：一个数一定可以被表示为若干个不相邻的斐波那契数之和

> [!note] 结论三：当 $n$ 不是斐波那契数时，将其分为若干个 $F$ 之和，最小的 $F$ 即为所求
> 如果先手拿掉了最小的 $F$，对剩下的每一个子问题 $F$，后手都无法一步全部拿掉，因此根据结论一后手必败。
> 如果先手拿了小于最小 $F$ 的石子，自己就落入了子问题 $F$ 这个陷阱，此时先手必败

[***AC 代码***](https://www.luogu.com.cn/record/227932586)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

ll f[1005];

void solve()
{
    ll n;
    cin >> n;
    for (; n; ) {
        ll mx = *prev(upper_bound(f+1, f+101, n));
        if (mx == n) { cout << mx << "\n"; return; }
        else { n -= mx; }
    }
}

int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 

    f[1] = 1;
    f[2] = 2;
    for (int i = 3; i <= 100; ++i) {
        f[i] = f[i-1] + f[i-2];
    }

	int t = 1;
	// cin >> t;
	while (t--) { solve(); }
}
```
