---
tags:
  - 题解
  - 线段树
  - 哈希
aliases:
  - Same Sum
---
## [gym105632G. Same Sum](https://codeforces.com/gym/105632/problem/G)

如果产生 $m$ 对和为 $x$ 的匹配，则 $mx$ 等于区间和。因此如果能匹配，匹配的和一定是二倍区间均值。
可以通过线段树等数据结构维护出区间均值。
记区间均值为 $m$，一定是 $x$ 和 $2m-x$ 匹配，能否匹配等价于询问区间上 $x$ 和 $2m-x$ 的个数是否相同。特别地，只要其他位置可以匹配，$m$ 的个数一定为偶数，$m$ 与 $m$ 匹配不会影响答案。
构造函数 $F(x)=\sum x^{a_i}$ 和 $G(x)=\sum x^{-a_i}$，能否匹配等价于判断区间 $[L,R]$ 上 $F(x)$ 是否等于 $x^{2m}G(x)$，使用哈希判断即可。
线段树维护区间和、区间正向、逆向哈希值，时间复杂度 $O(n\log n)$

[***AC 代码***](https://codeforces.com/gym/105632/submission/336346342)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

ll qpow(ll a, ll b, ll MOD)
{
    ll res = 1;
    for (; b; b >>= 1, a = a * a % MOD) {
        if (b & 1) { res = res * a % MOD; }
    }
    return res;
}

typedef pair<ll,ll> hs;
const ll MOD1 = 1e9+7, MOD2 = 1e9+9;
const hs p = { 117, 131 };
const hs ip = { qpow(p.first, MOD1-2, MOD1), qpow(p.second, MOD2-2, MOD2) };
ostream& operator<< (ostream& os, hs h) { return os << "( " << h.first << ", " << h.second << " )"; }
hs operator+ (hs a, hs b) { return hs{ (a.first+b.first)%MOD1, (a.second+b.second)%MOD2 }; }
hs operator- (hs a, hs b) { return hs{ (a.first-b.first+MOD1)%MOD1, (a.second-b.second+MOD2)%MOD2 }; }
hs operator* (hs a, hs b) { return hs{ a.first*b.first%MOD1, a.second*b.second%MOD2 }; }
hs qpow(hs a, ll b)
{
    hs res = { 1, 1 };
    for (; b; b >>= 1, a = a * a) {
        if (b & 1) { res = res * a; }
    }
    return res;
}

#define lson (p << 1)
#define rson (p << 1 | 1)
#define m ((l+r)>>1)
template<typename Info, typename Lazy>
struct segmentTree {
    int n;
    vector<Info> a;
    vector<Lazy> t;

    segmentTree(int n): n(n), a(4 << __lg(n)), t(4 << __lg(n)) { }
    segmentTree(vector<Info>&& vec): segmentTree(vec.size()) {
        function<void(int,int,int)> build = [&](int p, int l, int r) -> void {
            if (r - l == 1) { a[p] = vec[l]; return; }
            build(lson, l, m);
            build(rson, m, r);
            push_up(p); 
        };
        build(1, 0, n);
    }

    void push_up(int p) {
        a[p] = a[lson] + a[rson];
    }

    void apply(int p, Lazy v) {
        a[p] = a[p] + v;
        t[p] = t[p] + v;
    }

    void spread_down(int p) {
        apply(lson, t[p]);
        apply(rson, t[p]);
        t[p] = Lazy();
    }

    template<typename F>
    Info dfs(int p, int l, int r, int x, int y, F&& op) {
        if (y <= l || r <= x) { return Info(); }
        if (x <= l && r <= y) { op(p,l,r); return a[p]; }
        spread_down(p);
        Info res;
        res = res + dfs(lson, l, m, x, y, op);
        res = res + dfs(rson, m, r, x, y, op);
        push_up(p);
        return res;
    }

    void modify(int x, int y, Lazy v) {
        dfs(1, 0, n, x, y+1, [&](int p, int l, int r){ apply(p, v); });
    }

    Info query(int x, int y) {
        return dfs(1, 0, n, x, y+1, [](int,int,int){});
    }
};
#undef lson
#undef rson
#undef m
struct Info {
    hs h1, h2;
    ll s, len;
    Info(hs h1={0,0}, hs h2={0,0}, ll s=0, ll len=0): h1(h1), h2(h2), s(s), len(len) { }
};
struct Lazy {
    ll a;
    Lazy(): a(0) { }
    Lazy(ll a): a(a) { }
};
Info operator+ (Info u, Info v) {
    return Info(u.h1+v.h1, u.h2+v.h2, u.s+v.s, u.len+v.len);
}
Info operator+ (Info u, Lazy v) {
    return Info(u.h1*qpow(p, v.a), u.h2*qpow(ip, v.a), u.s+v.a*u.len, u.len);
}
Lazy operator+ (Lazy u, Lazy v) {
    return Lazy(u.a + v.a);
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int n, q;
    cin >> n >> q;
    vector<Info> a(n);
    for (int i = 0; i < n; ++i) {
        int x; cin >> x;
        a[i] = Info(qpow(p, x), qpow(ip, x), x, 1);
    }
    segmentTree<Info,Lazy> t(move(a));

    while (q--) {
        int o;
        cin >> o;
        if (o == 1) {
            int L, R, v;
            cin >> L >> R >> v;
            --L; --R;
            t.modify(L, R, Lazy(v));
        } else {
            int L, R;
            cin >> L >> R;
            --L; --R;
            Info val = t.query(L, R);
            ll m = val.s * 2;
            if (m % val.len != 0) {
                cout << "NO\n";
            } else {
                m /= val.len;
                val.h2 = val.h2 * qpow(p, m);
                cout << (val.h1 == val.h2 ? "YES" : "NO") << "\n";
            }
        }
    }
}
```
