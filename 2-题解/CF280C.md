---
tags:
  - 题解
  - 概率与期望
aliases:
  - Game on Tree
---
## [CF280C. Game on Tree](https://codeforces.com/problemset/problem/280/C)

这道题的一些错误想法：

- 第一步有 $n$ 种选法，第二步根据删掉的子树大小不同，剩下的节点数也不同……状态爆炸。
- 既然是树，想用树形 DP？`dp[u]` 表示删掉 $u$ 子树的期望次数？但是删除操作可能来自 $u$ 的祖先，这破坏了子树的独立性。

遇到“期望次数”，并且整体的过程非常复杂，可以考虑每个点的贡献是多少。
什么叫期望次数？我们设一个布尔数组 $I_n$ 表示某个点是否被选择，期望次数实际上就是 $\mathbb E(\sum_{i=1}^n I_i)$
根据期望的线性性，我们可以将它写为 $\sum_{i=1}^n\mathbb E(I_i)$
所以接下来我们需要考虑的是，$I_i=1$ 的条件是什么。
显然当节点 $i$ 被选择时，它的所有祖先节点不能在它之前被选择。不妨设 $i$ 及其所有祖先节点为集合 $S_i$，在任意一种状态下，对于集合 $S_i$ 中每一个元素 $u$，$u$ 被第一个选出来的概率是一样的，那么 $i$ 被第一个选出来的概率当然是 $\dfrac{1}{|S|}=\dfrac{1}{\text{dep}(i)}$
因此，最终的答案是 $\displaystyle \sum_{i=1}^n\dfrac{1}{\text{dep}(i)}$

[***AC 代码***](https://codeforces.com/contest/280/submission/351418577)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

void solve()
{
    int n;
    cin >> n;
    vector G(n + 1, vector<int>());
    for (int i = 1; i < n; ++i) {
        int u, v;
        cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }

    vector<int> dep(n + 1);
    auto dfs = [&](auto &&self, int u, int fa) -> void {
        dep[u] = dep[fa] + 1;
        for (auto v: G[u]) {
            if (v == fa) { continue; }
            self(self, v, u);
        }
    };
    dfs(dfs, 1, 0);

    db ans = 0;
    for (int i = 1; i <= n; ++i) {
        ans += 1.0 / dep[i];
    }
    cout << fixed << setprecision(20) << ans << "\n";
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int t = 1;
    // cin >> t;
    while (t--) { solve(); }
}
```
