---
tags:
  - 题解
aliases:
  - Follow the Sequence
---
## [QOJ14679. Follow the Sequence](https://qoj.ac/contest/2556/problem/14679)

每个循环移动的方向向量是一样的，记作 $\vec{d}$，第 $kn+i$ 步相当于从第 $i$ 步的位置向后移动了 $k\vec{d}$。
每个点沿着 $-\vec{d}$ 向前走若干步，如果和第一轮移动路径有交，那么这个点就可以到达。
特判 $\vec{d}=(0,0)$ 的情况。
一种比较好写的方法是把所有点都归一化到 $[0,dx]$ 或者 $[0,dy]$ 区间内，对第一轮移动路径上每个点 $u$，可以求出它到归一化区间需要走几轮，如果一个询问的点可以通过 $t\ge k$ 步走到同一个位置，那么它就是可以到达的。

[***AC 代码***](https://qoj.ac/submission/1594217)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

struct Point {
    ll x, y;
    Point(ll x = 0, ll y = 0): x(x), y(y) { }
    friend istream& operator>> (istream& is, Point &p) { return is>>p.x>>p.y; }
    bool operator< (const Point &p) const { return (x < p.x) || (x == p.x && y < p.y); }
    bool operator== (const Point &p) const { return x == p.x && y == p.y; }
    Point operator+ (Point p) { return Point(x+p.x, y+p.y); }
};

void solve()
{
    int n, m;
    cin >> n >> m;
    vector<Point> a(n + 1);
    for (int i = 1; i <= n; ++i) {
        char c; cin >> c;
        switch (c) {
            case 'U': a[i] = Point(0, 1); break;
            case 'D': a[i] = Point(0, -1); break;
            case 'L': a[i] = Point(-1, 0); break;
            case 'R': a[i] = Point(1, 0); break;
        }
        a[i] = a[i - 1] + a[i];
    }
    auto [dx, dy] = a[n];
    auto calc = [&](Point p) -> ll {
        if (dx == 0 && dy == 0) {
            return 0;
        } else if (dx != 0) {
            ll M = abs(dx);
            ll des = (p.x % M + M) % M;
            return (des - p.x) / dx;
        } else {
            ll M = abs(dy);
            ll des = (p.y % M + M) % M;
            return (des - p.y) / dy;
        }
    };
    map<Point, ll> step;
    for (int i = 1; i <= n; ++i) {
        ll k = calc(a[i]);
        a[i] = a[i] + Point(k*dx, k*dy);
        step[a[i]] = max(step[a[i]], k);
    }
    int ans = 0;
    for (int i = 1; i <= m; ++i) {
        Point u; cin >> u;
        ll k = calc(u);
        u = u + Point(k*dx, k*dy);
        if (step.count(u) && k <= step[u]) { ++ans; }
    }
    cout << ans << "\n";
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int t = 1;
    cin >> t;
    while (t--) { solve(); }
}
```
