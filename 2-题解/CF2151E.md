---
tags:
  - 题解
  - 线段树
  - DP
aliases:
  - Limited Edition Shop
---
## [CF2151E. Limited Edition Shop](https://codeforces.com/contest/2151/problem/E)

记 $x$ 在 $b$ 中的下标为 $b^{-1}(x)$。
先观察一对 $(a_i,a_j)$ 的选择情况：

- 显然可以都选或者都不选
- 显然可以 $a_i$ 选，$a_j$ 不选
- 如果 $a_i$ 不选，$a_j$ 选，那么必须满足 $b^{-1}(a_i)<b^{-1}(a_j)$，并且 Bob 买到了 $a_i$

这个条件对任意一对 $(i,j)$ 都要满足。
设 $f_i(j)$ 表示考虑 Alice 列表中前 $i$ 件物品，Bob 选的最后一件物品为 $b_j$ 时，Alice 能选到的最大价值。
从 $i=1$ 到 $n$ 枚举 Alice 列表中的物品。
如果 Alice 没选 $a_i$，等价于 Bob 选了 $a_i$，此时需要更新 $f(b^{-1}(a_i))$ 的值，有转移 
$$f_i(b^{-1}(a_i))\leftarrow \max_{j=1}^{b^{-1}(a_i)-1} f_{i-1}(j)$$
如果 Alice 选了 $a_i$，相当于 Bob 没选 $a_i$，此时 Bob 不能选 $b^{-1}(a_i)$ 后方的物品，于是有转移
$$
f_i(j)\leftarrow f_{i-1}(j) + c_{a_i}\ (j < b^{-1}(a_i))
$$
$f$ 需要单点取 $\max$、区间加法、区间求 $\max$，使用线段树维护即可。时间复杂度 $O(n\log n)$。

[***AC 代码***](https://codeforces.com/contest/2151/submission/340293733)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

const ll inf = 1e18;

#define lson (p << 1)
#define rson (p << 1 | 1)
#define m ((l+r)>>1)
template<typename Info, typename Lazy>
struct segmentTree {
    int n;
    vector<Info> a;
    vector<Lazy> t;

    segmentTree(int n): n(n), a(4 << __lg(n)), t(4 << __lg(n)) { }
    segmentTree(vector<Info>&& vec): segmentTree(vec.size()) {
        function<void(int,int,int)> build = [&](int p, int l, int r) -> void {
            if (r - l == 1) { a[p] = vec[l]; return; }
            build(lson, l, m);
            build(rson, m, r);
            push_up(p); 
        };
        build(1, 0, n);
    }

    void push_up(int p) {
        a[p] = a[lson] + a[rson];
    }

    void apply(int p, Lazy v) {
        a[p] = a[p] + v;
        t[p] = t[p] + v;
    }

    void spread_down(int p) {
        apply(lson, t[p]);
        apply(rson, t[p]);
        t[p] = Lazy();
    }

    template<typename F>
    Info dfs(int p, int l, int r, int x, int y, F&& op) {
        if (y <= l || r <= x) { return Info(); }
        if (x <= l && r <= y) { op(p,l,r); return a[p]; }
        spread_down(p);
        Info res;
        res = res + dfs(lson, l, m, x, y, op);
        res = res + dfs(rson, m, r, x, y, op);
        push_up(p);
        return res;
    }

    template<typename F>
    pair<int,Info> findFirst(int p, int l, int r, int x, int y, F&& pred) {
        if (y <= l || r <= x) { return {-1,Info()}; }
        if (x <= l && r <= y && !pred(a[p])) { return {-1,Info()}; }
        if (l == r-1) { return {l,a[p]}; }
        spread_down(p);
        pair<int,Info> res = findFirst(lson, l, m, x, y, pred);
        if (res.first == -1) {
            res = findFirst(rson, m, r, x, y, pred);
        }
        return res;
    }

    void modify_add(int x, int y, ll a) {
        dfs(1, 0, n, x, y+1, [&](int p, int l, int r){ apply(p, Lazy(a)); });
    }

    void chmax(int pos, ll x) {
        dfs(1, 0, n, pos, pos+1, [&](int p, int l, int r){ a[p].mx = max(a[p].mx, x); });
    }

    Info query(int x, int y) {
        return dfs(1, 0, n, x, y+1, [](int,int,int){});
    }
};
#undef lson
#undef rson
#undef m
struct Info {
    ll mx;
    Info(ll mx = -inf): mx(mx) { }
};
struct Lazy {
    ll a;
    Lazy(ll a = 0): a(a) { }
};
Info operator+ (Info u, Info v) {
    return Info(max(u.mx, v.mx));
}
Info operator+ (Info u, Lazy v) {
    return Info(u.mx + v.a);
}
Lazy operator+ (Lazy u, Lazy v) {
    return Lazy(u.a + v.a);
}

void solve()
{
    int n;
    cin >> n;
    vector<int> a(n + 1), b(n + 1), v(n + 1);
    vector<int> id(n + 1);
    for (int i = 1; i <= n; ++i) {
        cin >> v[i];
    }
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
    }
    for (int i = 1; i <= n; ++i) {
        cin >> b[i];
        id[b[i]] = i;
    }
    segmentTree<Info,Lazy> t(n + 1);
    t.chmax(0, 0);
    for (int i = 1; i <= n; ++i) {
        ll mx = t.query(0, id[a[i]]).mx;
        t.chmax(id[a[i]], mx);
        t.modify_add(0, id[a[i]]-1, v[a[i]]);
    }
    cout << t.query(0, n).mx << "\n";
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int t = 1;
    cin >> t;
    while (t--) { solve(); }
}
```
