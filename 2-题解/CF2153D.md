---
tags:
  - 题解
  - DP
aliases:
  - Not Alone
---
## [CF2153D. Not Alone](https://codeforces.com/contest/2153/problem/D)

$b$ 的意思是，序列可以被分成若干组，每组是连续的一段相同的数字，并且长度至少为 $2$。
分组 DP，设 $f (i)$ 表示 $i$ 是某一组的结尾，前 $i$ 个数满足条件的最小代价，则有：
$$
f (i) = min_{j<i} \{f (j) + val (j+1, i)\}
$$
$val$ 的算法是，求出 $[j+1, i]$ 的中位数，所有数都向中位数对齐。
这个 DP 是 $O (n^2 \log n)$ 的。
然后注意到每组的长度大于 $3$ 一定是更劣的，任何一个长度大于 $3$ 的连续段 $a_l\sim a_r$，把 $ar$ 和 $a_{r-1}$ 单独拆出来永远不劣。
每次转移时只需要枚举 $2$ 个 $j$ 即可，同时环上最多有 $3$ 个可能的起点，复杂度 $O (n)$。

[***AC 代码***](https://codeforces.com/contest/2153/submission/343067244)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

void solve()
{
    int n;
    cin >> n;
    vector<ll> a(2 * n);
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
        a[i + n] = a[i];
    }
    auto calc = [&](int l, int r) {
        vector<int> v(a.begin() + l, a.begin() + r + 1);
        sort(v.begin(), v.end());
        ll res = 0;
        for (auto x: v) {
            res += abs(v[v.size() / 2] - x);
        }
        return res;
    };
    if (n <= 3) {
        cout << calc(0, n - 1) << "\n";
        return;
    }
    ll ans = 1e18;
    for (int beg = 0; beg <= 2; ++beg) {
        vector<ll> dp(n, 1e18);
        dp[0] = 0;
        dp[1] = calc(beg, beg + 1);
        dp[2] = calc(beg, beg + 2);
        for (int i = 1; i < n; ++i) {
            for (int j = i + 2; j <= i + 3 && j < n; ++j) {
                dp[j] = min(dp[j], dp[i] + calc(beg + i + 1, beg + j));
            }
        }
        ans = min(ans, dp.back());
    }
    cout << ans << "\n";
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int t = 1;
    cin >> t;
    while (t--) { solve(); }
}
```
