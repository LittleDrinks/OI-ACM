---
tags:
  - 题解
  - 线段树
  - 滑动窗口
aliases:
  - K-Coverage
---
## [QOJ14716. K-Coverage](https://qoj.ac/contest/2563/problem/14716)

移动一个已有区间，等价于删除一个已有区间，然后任选一个区间加一。
我们使用滑动窗口枚举加一的那个区间，考虑如何快速求出应该删除哪个区间。
删除某段区间后，答案的增加量量等于这段区间上 $k+1$ 的个数，答案的减少量等于这段区间上 $k$ 的个数。每次滑动窗口 $[l,r]$ 向右移动，只会改变 $l$ 和 $r+1$ 两个位置的值，只会改变右端点位于 $[l,l+L-1]$ 和 $[r+1,r+L]$ 的若干个区间的答案变化量。
使用线段树，对每个 $i$ 维护 $[i-L+1, i]$ 的答案变化量即可。

[***AC 代码***](https://qoj.ac/submission/1619976)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

#define lson (p << 1)
#define rson (p << 1 | 1)
#define m ((l + r) >> 1)
struct Info {
    int dt;
    Info(int dt = -1e9): dt(dt) {
    }    
};
struct Lazy {
    int a;
    Lazy(int a = 0): a(a) {
    }
};
Info operator+ (const Info &u, const Info &v) {
    return Info(max(u.dt, v.dt));
}
Info operator+ (const Info &u, const Lazy &v) {
    return Info(u.dt + v.a);
}
Lazy operator+ (const Lazy &u, const Lazy &v) {
    return Lazy(u.a + v.a);
}
const int N = 8e5 + 6;
Info a[(N << 4) + 5];
Lazy t[(N << 4) + 5];
void push_up(int p) {
    a[p] = a[lson] + a[rson];
}
void apply(int p, Lazy v) {
    a[p] = a[p] + v;
    t[p] = t[p] + v;
}
void spread_down(int p) {
    apply(lson, t[p]);
    apply(rson, t[p]);
    t[p] = Lazy();
}
void build(int p, int l, int r) {
    if (l == r - 1) {
        a[p] = Info();
        t[p] = Lazy();
        return;
    }
    build(lson, l, m);
    build(rson, m, r);
    push_up(p);
}
void reset(int p, int l, int r, int x, int v) {
    if (r <= x || x + 1 <= l) {
        return;
    }
    if (x <= l && r <= x + 1) {
        a[p] = Info(v);
        return;
    }
    spread_down(p);
    reset(lson, l, m, x, v);
    reset(rson, m, r, x, v);
    push_up(p);
}
void modify(int p, int l, int r, int x, int y, Lazy v) {
    if (r <= x || y <= l) {
        return;
    }
    if (x <= l && r <= y) {
        apply(p, v);
        return;
    }
    spread_down(p);
    modify(lson, l, m, x, y, v);
    modify(rson, m, r, x, y, v);
    push_up(p);
}
Info query(int p, int l, int r, int x, int y) {
    if (r <= x || y <= l) {
        return Info();
    }
    if (x <= l && r <= y) {
        return a[p];
    }
    spread_down(p);
    Info res;
    res = res + query(lson, l, m, x, y);
    res = res + query(rson, m, r, x, y);
    push_up(p);
    return res;
}
#undef lson
#undef rson
#undef m

void solve()
{
    int n, L, k;
    cin >> n >> L >> k;
    vector<int> a(4 * n + 1);
    build(1, 0, 4 * n);
    ++a[0]; --a[L];
    for (int i = 1; i <= n; ++i) {
        int x; cin >> x;
        ++a[x];
        --a[x + L];
        reset(1, 0, 4 * n, x + L - 1, 0);
    }

    int nowans = 0;
    for (int i = 0; i <= 4 * n; ++i) {
        if (i) {
            a[i] += a[i - 1];
        }
        if (a[i] == k + 1) {
            modify(1, 0, 4 * n, i, i + L, Lazy(1));
        }
        if (a[i] == k) {
            ++nowans;
            modify(1, 0, 4 * n, i, i + L, Lazy(-1));
        }
    }

    int ans = nowans + query(1, 0, 4 * n, 0, 4 * n).dt;
    int rl = 0, rr = L;
    while (rr <= 4 * n) {

        auto update = [&](int pos, int dt) {
            if (a[pos] == k) {
                --nowans;
                modify(1, 0, 4 * n, pos, pos + L, Lazy(1));
            }
            if (a[pos] == k + 1) {
                modify(1, 0, 4 * n, pos, pos + L, Lazy(-1));
            }

            a[pos] += dt;

            if (a[pos] == k) {
                ++nowans;
                modify(1, 0, 4 * n, pos, pos + L, Lazy(-1));
            }
            if (a[pos] == k + 1) {
                modify(1, 0, 4 * n, pos, pos + L, Lazy(1));
            }
        };

        update(rl, -1);
        update(rr, 1);
        int add = query(1, 0, 4 * n, 0, 4 * n).dt;
        ans = max(ans, nowans + add);
        ++rl; ++rr;
    }

    cout << ans << "\n";
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
```
