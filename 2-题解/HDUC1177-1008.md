---
tags:
  - 题解
  - DP/状压DP
aliases:
  - cats 的 max
---
## [HDC1177-1008. cats 的 max](https://acm.hdu.edu.cn/contest/problem?cid=1177&pid=1008)

当 $k\ge m$ 的时候，选择令每一列最大的那一行即可。下面认为 $k<m$。
设 $m$ 位二进制数 $S$，$S_i=1$ 表示这一行的第 $i$ 位作为最大值被加入到了答案中。
设 $dp(i,S)$ 表示选择了 $i$ 行，且这 $i$ 行覆盖了答案中 $S_j=1$ 的那些列。
记 $g(S)$ 表示选择某一行，且这一行中 $S_j=1$ 的那些列被计入了答案，这些列之和的最大值是多少。则有状态转移方程
$$
dp(i,S)=\max_{P\in S}\bigg\{dp(i-1,P)+g(S\oplus P)\bigg\}
$$
预处理 $g(S)$ 需要 $O(n2^m)$，枚举子集进行状态转移需要 $O(k3^m)$。
PS：上面这个式子会取到若干个 $P_j=1$ 但实际上前面比 $a_{i,j}$ 小的情况，但只有正确的情况会成为最大值。总结一个经验：写状态的时候不要太执着于“找到”正确的位置转移。

[***AC 代码***](https://acm.hdu.edu.cn/contest/view-code?cid=1177&rid=9075)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

constexpr ll inf = 1e18;

void solve()
{
    int n, m, k;
    cin >> n >> m >> k;
    vector a(n+1, vector<ll>(m+1));
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            cin >> a[i][j];
        }
    }

    if (k >= m) {
        ll ans = 0;
        for (int j = 1; j <= m; ++j) {
            ll mx = 0;
            for (int i = 1; i <= n; ++i) {
                mx = max(mx, a[i][j]);
            }
            ans += mx;
        }
        cout << ans << '\n';
        return;
    }

    vector<ll> g(1<<m);
    for (int i = 1; i <= n; ++i) {
        vector<ll> r(1<<m);
        for (int msk = 1; msk < (1<<m); ++msk) {
            int b = __builtin_ctz(msk);
            r[msk] = r[msk ^ (1 << b)] + a[i][b+1];
        }
        for (int msk = 0; msk < (1<<m); ++msk) {
            g[msk] = max(g[msk], r[msk]);
        }
    }

    vector dp(k+1, vector<ll>(1<<m, -inf));
    dp[0][0] = 0;
    for (int i = 1; i <= k; ++i) {
        for (int msk = 0; msk < (1 << m); ++msk) {
            for (int pre = msk; ; pre = (pre-1) & msk) {
                dp[i][msk] = max(dp[i][msk], dp[i-1][pre] + g[msk^pre]);
                if (pre == 0) { break; }
            }
        }
    }
    cout << dp[k][(1<<m)-1] << "\n";
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int t = 1;
    cin >> t;
    while (t--) { solve(); }
}
```
