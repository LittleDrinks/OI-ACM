---
tags:
  - 题解
  - 博弈论
  - 线性基
  - DP
aliases:
  - Kings Game
---
## [gym105895D. Kings Game](https://codeforces.com/gym/105895/problem/D)

题目的博弈过程等价于选择 $a_i$ 的若干个质因子将其从 $a_i$ 中除去。
记 $b_i$ 表示 $a_i$ 的质因子数量，有 $b_i\le 24$，这其实是在 $b$ 上进行 anti-nim 游戏，先手胜利的条件有两种：①不全为 $1$ 且 SG 异或和不为零；②全为 $1$ 且 SG 异或和为零

不妨假设 $[L,R]$ 中不存在 $0$ 和 $1$，考虑此时的情况①，等价于求异或和不为零的子序列数量。
对于 Easy Version，可以 DP，记 $f(i,x)$ 表示前 $i$ 个数中选择子序列，且异或和为零的方案数，讨论第 $i$ 个数选不选，转移显然，时间复杂度 $O(32nq)$
对于 Hard Version，考虑线性基，考虑将 $1\sim 24$ 在 $[L, R]$ 中出现的数字插入线性基，记线性基的秩为 $rank$，总共有 $tot$ 个数字，则答案为 $2^{tot}-2^{tot-rank}$，时间复杂度 $O(32\times \log_232\times q)$

---

当 $[L,R]$ 中存在 $1$ 时，我们需要考虑子序列全是 $1$ 的情况，我们需要在原来的答案上：①去掉异或和不为零的子序列且全是 $1$ 的情况；②加上异或和为零且全是 $1$ 的情况。
$$
\sum_{i=1}^{cnt_1} (-1)^i {cnt_1\choose i}=-1
$$
即当 $[L,R]$ 中存在 $1$ 时，需要额外减一。

---

最后考虑 $[L,R]$ 中存在 $0$ 的情况，先把 $[L,R]$ 中所有的 $0$ 去掉，按之前的算法求出答案 $x$，再考虑往答案中加上零，最终答案为
$$
2^{cnt_0}\times x + 2^{cnt_0}-1
$$

[***AC 代码***](https://codeforces.com/gym/105895/submission/340901395)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int MOD = 998244353;
ll add(ll x, ll y) {
    return (x + y) % MOD;
}
ll del(ll x, ll y) {
    return add(x, MOD - y);
}
ll mul(ll x, ll y) {
    return (x * y) % MOD;
}
ll qpow(ll a, ll b = MOD - 2) {
    ll res = 1;
    for (; b; b >>= 1, a = mul(a, a)) {
        if (b & 1)
            res = mul(res, a);
    }
    return res;
}

vector<int> sieve(int n) {
    vector<bool> vis(n + 1);
    vector<int> mP(n + 1, 1);
    vector<int> prime;
    vis[1] = 1;
    for (int i = 2; i <= n; ++i) {
        if (!vis[i]) {
            prime.push_back(i);
            mP[i] = i;
        }
        for (auto p : prime) {
            if (i * p > n) {
                break;
            }
            vis[i * p] = 1;
            mP[i * p] = p;
            if (i % p == 0) {
                break;
            }
        }
    }
    return mP;
}
auto mP = sieve(1e7);

struct LinearBasis {
    static const int maxbase = 7;
    bool flag = false;
    ll a[maxbase + 1];
    int tot;
    LinearBasis() {
        memset(a, 0, sizeof(a));
        tot = 0;
    }
    LinearBasis(ll *x, int n) {
        LinearBasis();
        build(x, n);
    }
    void build(ll *x, int n) {
        for (int i = 1; i <= n; ++i) {
            insert(x[i]);
        }
    }
    void clear() {
        memset(a, 0, sizeof(a));
    }
    bool insert(ll t) {
        for (int i = maxbase; i >= 0; --i) {
            if (t & (1LL << i)) {
                if (!a[i]) {
                    a[i] = t;
                    break;
                }
                t ^= a[i];
            }
        }
        if (t == 0) {
            flag = true;
            ++tot;
        }
        return t;
    }
} L;

void solve() {
    int n, q;
    cin >> n >> q;
    vector<int> a(n + 1), b(n + 1);
    vector cnt(32, vector<int>(n + 1));
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        for (int x = a[i]; x > 1; x /= mP[x]) {
            ++b[i];
        }
        ++cnt[b[i]][i];
    }
    for (int i = 0; i < 32; ++i) {
        partial_sum(cnt[i].begin(), cnt[i].end(), cnt[i].begin());
    }
    while (q--) {
        int l, r;
        cin >> l >> r;
        L.clear();
        int rank = 0;
        int tot = 0;
        for (int i = 1; i < 32; ++i) {
            if (cnt[i][r] > cnt[i][l - 1]) {
                rank += L.insert(i);
                tot += (cnt[i][r] - cnt[i][l - 1]);
            }
        }
        ll ans = del(qpow(2, tot), qpow(2, tot-rank));
        if (cnt[1][r] > cnt[1][l - 1]) {
            ans = del(ans, 1);
        }
        int cnt0 = cnt[0][r]-cnt[0][l-1];
        ans = mul(qpow(2, cnt0), ans);
        ans = add(ans, del(qpow(2, cnt0), 1));
        cout << ans << "\n";
    }
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
```
