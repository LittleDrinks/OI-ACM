---
tags:
  - 题解
  - 矩阵快速幂
  - DP
aliases:
  - Lava Layer
---
## [NCC108304I. Lava Layer](https://ac.nowcoder.com/acm/contest/108304/I)

注意到只有最后四位会影响计算结果，按照二进制最后四位进行分类，每类应该具有相同的变化模式。
设 $f(i,S)$ 表示经过 $i$ 次运算后最后四位为 $S$ 的情况数，$g(i,S)$ 表示 $f(i,S)$ 所代表的情况的总和。
最后的答案是
$$
\dfrac{g(n-1,S)}{5^{n-1}k^n}
$$
可以根据上面的状态设计进行 $O(n)$ 的 DP。
注意到这个 DP 是一个线性递推，可以用一个 $32\times32$ 的矩阵 $M$ 描述
$$
\begin{pmatrix}
f(i,S) &\\ 
& g(i,S)
\end{pmatrix}
=
M\times\begin{pmatrix}
f(i-1,S) &\\ 
& g(i-1,S)
\end{pmatrix}
$$
接下来根据不同运算的性质填充矩阵的系数。$f_{i-1}\to f_i$ 的填在 $0\le r\le15,0\le c\le 15$ 的区域，$f_{i-1}\to g_i$ 的填在 $16\le r\le31,0\le c\le15$ 的区域，$g_{i-1}\to g_i$ 的填在 $16\le r\le 31,16\le c\le 31$ 的区域。
$f(i,S)$ 部分的系数是好做的， $M_{y,x}$ 表示前 $i-1$ 次运算结果为 $x$，第 $i$ 次运算结果为 $y$ 的情况数，则
$$
M_{y,x}=\sum_{z}[op(x,z)=y]
$$
接下来讨论 $g(i,S)$ 部分的系数。记 $op(x,z)=y$，讨论。

- $op=+$ 时，$g(i,y)=g(i-1,x)+f(i-1,x)\times z$
- $op=\times$ 时，$g(i,y)=g(i-1,x)\times z$
- $op=\land$ 时，$g(i,y)=f(i-1,x)\times y$
- $op=\lor$ 时，$g(i,y)=g(i-1,y)+f(i-1,x)\times(y-x)$
- $op=\oplus$ 时，$g(i,y)=g(i-1,y)+f(i-1,x)\times(y-x)$

枚举 $x,op,z,y$ 计算系数，使用矩阵快速幂优化，时间复杂度 $O(t\times2^4\times5\times k+t\times \log n\times 32^3)$

[***AC 代码***](https://ac.nowcoder.com/acm/contest/view-submission?submissionId=78686849)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

const int MOD = 998244353;
ll add(ll x, ll y) { return (x + y) % MOD; }
ll del(ll x, ll y) { return add(x, MOD-y); }
ll mul(ll x, ll y) { return (x * y) % MOD; }
ll qpow(ll a, ll b=MOD-2) {
    ll res = 1;
    for (; b; b>>=1, a=mul(a, a)) {
        if (b & 1) { res = mul(res, a); }
    }
    return res;
}

using matrix = vector<vector<ll>>;
matrix IM(int n) {
    matrix I(n, vector<ll>(n));
    for (int i = 0; i < n; ++i) { I[i][i] = 1; }
    return I;
}
matrix operator* (matrix A, matrix B) {
    assert(A.front().size() == B.size());
    int n = A.size(), m = B.size(), k = B.front().size();
    matrix C(n, vector<ll>(m));
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < k; ++j) {
            for (int x = 0; x < m; ++x) {
                C[i][j] = add(C[i][j], mul(A[i][x], B[x][j]));
            }
        }
    }
    return C;
}
matrix qpow(matrix a, ll b) {
    matrix res = IM(a.size());
    for (; b; b>>=1, a=a*a) {
        if (b & 1) { res = res * a; }
    }
    return res;
}

int calc(int x, int op, int y)
{
    switch (op) {
        case 1: 
            return x + y;
        case 2:
            return x * y;
        case 3:
            return (x & y);
        case 4:
            return (x | y);
        case 5:
            return (x ^ y);
        default: assert(false);
    }
}

void solve()
{
    ll n; int k;
    cin >> n >> k;
    vector<int> val(k);
    for (auto &x: val) { cin >> x; }

    matrix M(32, vector<ll>(32));
    for (int i = 0; i < (1<<4); ++i) {
        for (int op = 1; op <= 5; ++op) {
            for (auto j: val) {
                int res = calc(i, op, j);
                res &= 15;  // 保留最低的四位
                M[res][i] = add(M[res][i], 1);
                if (op == 3) {
                    M[16+res][i] = add(M[16+res][i], res);
                } else if (op > 3) {
                    M[16+res][16+i] = add(M[16+res][16+i], 1);
                    M[16+res][i] = add(M[16+res][i], del(res, i));
                } else if (op == 1) {
                    M[16+res][16+i] = add(M[16+res][16+i], 1);
                    M[16+res][i] = add(M[16+res][i], j);
                } else {
                    M[16+res][16+i] = add(M[16+res][16+i], j);
                }
            }
        }
    }

    matrix dp(32, vector<ll>(1));
    for (auto x: val) {
        dp[x][0] = add(dp[x][0], 1);
        dp[16+x][0] = add(dp[16+x][0], x);
    }

    M = qpow(M, n-1);
    dp = M * dp;

    ll A = 0;
    for (int i = 16; i < 32; ++i) {
        A = add(A, dp[i][0]);
    }
    ll B = mul(qpow(k, n), qpow(5, n-1));
    cout << mul(A, qpow(B)) << "\n";
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int t = 1;
    cin >> t;
    while (t--) { solve(); }
}
```
