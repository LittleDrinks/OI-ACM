---
tags:
  - 题解
  - 树的直径与中心
aliases:
  - Apple Tree Traversing
---
## [CF2107D. Apple Tree Traversing](https://codeforces.com/problemset/problem/2107/D)

直接按题意模拟，做法就是每次找到一条树的直径并删除。
难点在于计算复杂度。每次删除一条直径后直径长度最少减少 $2$，删除操作最多需要执行 $O(\sqrt{n})$ 次。

[***AC 代码***](https://codeforces.com/contest/2107/submission/318512339)

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=150015;

int n, f[N], d[N];
vector<int> G[N];
vector<array<int,3>> ans;
bool vis[N];
vector<int> get(int rt, vector<int>& R)
{
    int mxd=0, V=0;
    function<void(int,int,int)> dfs = [&](int u, int fa, int d){
        f[u] = fa;
        if (d > mxd || (d == mxd && u > V)) {
            mxd = d;
            V = u;
        }
        for (auto v: G[u]) {
            if (v != fa && !vis[v]) {
                dfs(v, u, d+1);
            }
        }
    };
    mxd = 0;
    dfs(rt, 0, 1);
    mxd = 0;
    int s = V;
    dfs(V, 0, 1);
    int t = V;
    R.push_back(t);
    while (t != s) {
        t = f[t];
        R.push_back(t);
    }
    return R;
}
void solve()
{
	cin >> n;
    ans.clear();
    for (int i = 1; i <= n; ++i) {
        G[i].clear();
        vis[i] = false;
    }
    for (int i = 1; i < n; ++i) {
        int u, v;
        cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    queue<int> q; q.push(1);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        vector<int> R; get(u, R);
        for (auto v: R) { vis[v] = 1; }
        for (auto v: R) {
            for (auto x: G[v]) {
                if (!vis[x]) { q.push(x); }
            }
        }
        int s=R.front(), t=R.back();
        if (s < t) { swap(s, t); }
        ans.push_back( (array<int,3>){ (int)R.size(), s, t } );
    }
    sort(ans.begin(), ans.end(), greater<>());
    for (auto [t, x, y]: ans) {
        cout << t << " " << x << " " << y << " ";
    }
    cout << "\n";
}
int main()
{
	cin.tie(nullptr)->sync_with_stdio(false);
	int t = 1;
	cin >> t;
	while (t--) { solve(); }
}
```
