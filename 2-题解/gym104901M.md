---
tags:
  - 题解
  - 计算几何/凸包
  - 计算几何/极角排序
aliases:
  - Almost Convex
---
## [gym104901M. Almost Convex](https://codeforces.com/gym/104901/problem/M)

观察样例，不难发现满足条件的多边形只有两种：凸包和凹进去一个点的凹包。
由于不存在三点共线，因此凸包是唯一的。接下来考虑有多少个凹包。
枚举凸包内的点，以这个点为中心对剩下所有点极角排序，如果凸包上相邻的两个点在极角序上相邻，那么就可以从这条边上凹进去。
时间复杂度 $O(n^2\log n)$

[***AC 代码***](https://codeforces.com/gym/104901/submission/342889158)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

const db eps = 1e-8;
const db PI = acos(-1.0);
const db inf = numeric_limits<db>::max();
int sgn(auto x) {
    return (x > eps) - (x < -eps);
}

using T = ll;
struct Point {
    T x, y;
    Point(T x = 0, T y = 0) : x(x), y(y) {
    }
    friend istream &operator>>(istream &is, Point &p) {
        return is >> p.x >> p.y;
    }
    friend ostream &operator<<(ostream &os, Point &p) {
        return os << "( " << p.x << ", " << p.y << " )";
    }
    db ang() {
        return atan2(y, x);
    }
    bool operator==(const Point &p) const {
        return sgn(x - p.x) == 0 && sgn(y - p.y) == 0;
    }
    bool operator<(const Point &p) const {
        return x < p.x || (x == p.x && y < p.y);
    }
    Point operator+(const Point &p) const {
        return Point(x + p.x, y + p.y);
    }
    Point operator-(const Point &p) const {
        return Point(x - p.x, y - p.y);
    }
    Point operator*(const T &k) const {
        return Point(k * x, k * y);
    }
    Point operator/(const T &k) const {
        return Point(x / k, y / k);
    }
    T operator*(const Point &p) const {
        return x * p.x + y * p.y;
    }
    T operator^(const Point &p) const {
        return x * p.y - y * p.x;
    } // 叉乘时打括号
    T len2() {
        return (*this) * (*this);
    }
    db len() {
        return sqrtl(len2());
    } // 等价于 hypotl(x, y)
    Point rot(db ang) {
        return Point(x * cos(ang) - y * sin(ang), x * sin(ang) + y * cos(ang));
    }
    Point trunc(db l) {
        return (*this) * (l / len());
    }
};

pair<vector<Point>, vector<Point>> toConvex(vector<Point> ori) {
    const int n = ori.size();
    if (n <= 2) {
        return {};
    }

    vector<Point> p = ori;
    sort(p.begin(), p.end());

    vector<Point> st;
    st.reserve(n + 1);

    auto check = [&](Point u) {
        const auto p1 = st.back();
        const auto p2 = *prev(st.end(), 2);
        return sgn((p1 - p2) ^ (u - p1)) <= 0;
    };

    // 上凸壳
    for (const auto &u : p) {
        while (st.size() > 1 && check(u)) {
            st.pop_back();
        }
        st.push_back(u);
    }

    // 下凸壳
    size_t k = st.size();
    p.pop_back();
    reverse(p.begin(), p.end());
    for (const Point &u : p) {
        while (st.size() > k && check(u)) {
            st.pop_back();
        }
        st.push_back(u);
    }
    st.pop_back();

    // 筛选不在凸包上的点
    vector<Point> r;
    set<Point> h(st.begin(), st.end());
    for (const auto &u : ori) {
        if (!h.count(u)) {
            r.push_back(u);
        }
    }
    return {st, r};
}

void solve() {
    int n;
    cin >> n;
    vector<Point> p(n);
    for (auto &u : p) {
        cin >> u;
    }
    auto [conv, r] = toConvex(p);
    int ans = 1;
    set<Point> h(conv.begin(), conv.end());
    for (auto &u : r) {
        p.erase(find(p.begin(), p.end(), u));
        sort(p.begin(), p.end(), [&](Point a, Point b) {
            auto quad = [&](const Point &a) {
                if (a.y < u.y) {
                    return 1;
                } else if (a.y > u.y) {
                    return 3;
                } else if (a.x >= u.x) {
                    return 2;
                } else {
                    return 4;
                }
            };
            int qa = quad(a), qb = quad(b);
            if (qa == qb) {
                ll cross = (a - u) ^ (b - u);
                if (cross == 0) {
                    return abs(a.x) > abs(b.x);
                }
                return cross > 0;
            }
            return qa < qb;
        });
        for (int i = 0; i < n - 1; ++i) {
            if (h.count(p[i]) && h.count(p[(i + 1) % (n - 1)])) {
                ++ans;
            }
        }
        p.push_back(u);
    }
    cout << ans << "\n";
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t = 1;
    // cin >> t;
    while (t--) {
        solve();
    }
}
```
