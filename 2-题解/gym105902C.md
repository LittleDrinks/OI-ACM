---
tags:
  - 题解
  - 线段树
  - 哈希
aliases:
  - Sequential Sequence
---
## [gym105902C. Sequential Sequence](https://codeforces.com/gym/105902/problem/C)

可以通过重新排列变成标准序列的条件是：① $\max-\min=r-l$，②区间没有重复的数字
第一个条件可以用线段树维护。
第二个条件可以通过前缀和预处理出标准序列的异或哈希值，通过对比哈希值的方法判断是否有重复。

[***AC 代码***](https://codeforces.com/gym/105902/submission/330917783)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ull = unsigned long long;

mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());
const int N=1e5;
ull msk[N+5], pre[N+5];

#define lson (p << 1)
#define rson (p << 1 | 1)
#define m ((l+r)>>1)
template<typename Info>
struct segmentTree {
    int n;
    vector<Info> a;
    
    void push_up(int p) {
        a[p] = a[lson] + a[rson];
    }

    template<typename F>
    Info dfs(int p, int l, int r, int x, int y, F&& op) {
        if (y <= l || r <= x) { return Info(); }
        if (x <= l && r <= y) { op(p,l,r); return a[p]; }
        Info res;
        res = res + dfs(lson, l, m, x, y, op);
        res = res + dfs(rson, m, r, x, y, op);
        push_up(p);
        return res;
    }

    segmentTree(int n = 0): n(n), a(4 << __lg(n)) { }
    segmentTree(vector<Info>&& b): segmentTree(b.size()) {
        function<void(int,int,int)> build = [&](int p, int l, int r) -> void {
            if (r - l == 1) { a[p] = Info(b[l]); return; }
            build(lson, l, m);
            build(rson, m, r);
            push_up(p);
        };
        build(1, 0, n);
    }

    void modify(int pos, int x) {
        dfs(1, 0, n, pos, pos+1, [&](int p, int l, int r){ a[p] = Info(x); });
    }

    Info query(int l, int r) {
        return dfs(1, 0, n, l, r+1, [](int,int,int){});
    }

    void Debug(int p, int l, int r) {
        cerr << format("a[{}] = [ {}, {}, {}, {}, {} ]\n", p, l, r, a[p].ma, a[p].mi, a[p].sum);
        if (l == r - 1) { return; }
        Debug(lson, l, m);
        Debug(rson, m, r);
    }
    void Debug() { Debug(1, 0, n); }
};
#undef lson
#undef rson
#undef m
struct Info {
    int ma, mi;
    ull sum;
    Info(): ma(0), mi(1e5), sum(0) { }
    Info(int val): ma(val), mi(val), sum(msk[val]) { }
    Info(int ma, int mi, ull sum): ma(ma), mi(mi), sum(sum) { }
    friend Info operator+ (Info u, Info v) {
        int ma = max(u.ma, v.ma);
        int mi = min(u.mi, v.mi);
        ull sum = u.sum ^ v.sum;
        return Info(ma, mi, sum);
    }
};

void solve()
{
    int n, q;
    cin >> n >> q;
    vector<Info> a(n+1);
    for (int i = 1; i <= n; ++i) {
        int x; cin >> x;
        a[i] = Info(x);
    }
    segmentTree<Info> t(move(a));
    while (q--) {
        int op; cin >> op;
        if (op == 1) { 
            int x, y;
            cin >> x >> y;
            t.modify(x, y);
        } else {
            int l, r;
            cin >> l >> r;
            auto [ma, mi, sum] = t.query(l, r);
            if (ma-mi == r-l && (pre[ma]^pre[mi-1]) == sum) {
                cout << "YES\n";
            } else {
                cout << "NO\n";
            }
        }
    }
}

int main()
{
    cin.tie(nullptr)->sync_with_stdio(false);

    for (int i = 1; i <= N; ++i) {
        msk[i] = rng();
        pre[i] = pre[i-1] ^ msk[i];
    }

    int t = 1;
    cin >> t;
    while (t--) { solve(); }
}
```
