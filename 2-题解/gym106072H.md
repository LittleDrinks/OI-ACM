---
tags:
  - 题解
  - 数学
aliases:
  - Tree Shuffling
---
## [gym106072H. Tree Shuffling](https://codeforces.com/gym/106072/problem/H)

### $O (n^2)$

记录一个赛时的想法。
原问题等价于在一条链上选择若干个点进行错位排列。下记 $i$ 个数字进行错排的方案数为 $D(i)$，则有
$$
D(i) = (n-1)\bigg(D(i-1)+D(i-2)\bigg)
$$
我们钦定一条链的两端必选，剩下一共 $L$ 个点，则方案数为
$$
\sum_{i=0}^{L} {L\choose i}\times D(i+2)
$$
这个值可以 $O(n^2)$ 进行预处理。
此时只需要枚举树上的所有链，将这个值累加即可。
实现时可以进行 $n$ 遍 bfs，或者使用“欧拉序+st 表”实现 $O (1)$ LCA，时间复杂度 $O(n^2)$

[***AC 代码***](https://codeforces.com/gym/106072/submission/339397441)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 3000, I = 13;
const int MOD = 998244353;
ll add(ll x, ll y) {
    return (x + y) % MOD;
}
ll mul(ll x, ll y) {
    return (x * y) % MOD;
}
ll qpow(ll a, ll b = MOD - 2) {
    ll res = 1;
    for (; b; b >>= 1, a = mul(a, a)) {
        if (b & 1) {
            res = mul(res, a);
        }
    }
    return res;
}

ll fac[N + 5], Inv[N + 5];
ll D[N + 5], f[N + 5];
ll C(ll n, ll k) {
    return n == 0 ? 1 : fac[n] * Inv[k] % MOD * Inv[n - k] % MOD;
}

template <typename T> struct ST {
    int n = 0, I = 0;
    vector<int> Log;
    vector<vector<T>> st;
    ST() {
    }
    ST(const vector<T> &a) : n(a.size()), Log(n + 1) {
        for (int i = 2; i <= n; ++i) {
            I = Log[i] = Log[i / 2] + 1;
        }
        st.assign(I + 1, vector<T>(n));
        copy(a.begin(), a.end(), st[0].begin());
        for (int i = 1; i <= I; ++i) {
            for (int j = 0; j + (1 << (i - 1)) < n; ++j) {
                st[i][j] = min(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);
            }
        }
    }
    T query(int l, int r) {
        assert(l <= r);
        int s = Log[r - l + 1];
        return min(st[s][l], st[s][r - (1 << s) + 1]);
    }
};

int n, dep[N + 5];
int first[N + 5];
vector<pair<int, int>> eular;
vector<int> G[N + 5];

void dfs(int u, int fa) {
    first[u] = eular.size();
    dep[u] = dep[fa] + 1;
    eular.emplace_back(dep[u], u);
    for (auto v : G[u]) {
        if (v == fa) {
            continue;
        }
        dfs(v, u);
        eular.emplace_back(dep[u], u);
    }
}

ST<pair<int, int>> st;

int LCA(int u, int v) {
    u = first[u];
    v = first[v];
    if (u > v) {
        swap(u, v);
    }
    return st.query(u, v).second;
}

int cnt[N + 5];
void solve() {
    cin >> n;
    for (int i = 1; i < n; ++i) {
        int u, v;
        cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    dfs(1, 0);
    st = ST<pair<int, int>>(eular);
    ll ans = 1;
    for (int i = 1; i <= n; ++i) {
        for (int j = i + 1; j <= n; ++j) {
            int lca = LCA(i, j);
            int len = dep[i] + dep[j] - 2 * dep[lca] - 1;
            ++cnt[len + 2];
            ans = add(ans, f[len]);
        }
    }
    cout << ans << "\n";
    cerr << "\n\n\n";
    for (int i = 2; i <= n; ++i) {
        cerr << cnt[i] << " " << f[i-2] << "\n";
    }
    for (int i = 1; i <= n; ++i) {
        G[i].clear();
        cnt[i] = 0;
    }
    eular.clear();
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    fac[0] = Inv[0] = fac[1] = Inv[1] = 1;
    for (int i = 2; i <= N; ++i) {
        fac[i] = mul(fac[i - 1], i);
        Inv[i] = qpow(fac[i]);
    }

    D[1] = 0;
    D[2] = 1;
    for (int i = 3; i <= N + 2; ++i) {
        D[i] = mul(i - 1, add(D[i - 1], D[i - 2]));
    }
    for (int i = 0; i <= N; ++i) {
        // for (int j = 0; j <= i; ++j) {
        //     f[i] = add(f[i], mul(C(i, j), D[j + 2]));
        // }
        f[i] = mul(fac[i], (1LL * i * i + i + 1) % MOD);
    }

    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
```

### $O(n\log ^2n)$

从 $O(n^2)$ 的解法出发，分两块进行优化。
每一条链的贡献为 $A(L)=\sum_{i=0}^{L}{L\choose i}\times D(i+2)$，这个表达式可以进一步化简为 $L!\times(L^2+L+1)$

> [!note]- 证明
> ## 目标
> 
> 证明：
> 
> $$
> 
> a_i=\sum_{j=0}^i \binom{i}{j}\,D_{j+2}=i!\,(i^2+i+1).
> 
> $$
> 
>   
> 
> ## 步骤 0：错排数的 EGF
> 
> 错排数的经典容斥公式为
> 
> $$
> 
> D_n=n!\sum_{k=0}^{n}\frac{(-1)^k}{k!},
> 
> $$
> 
> 因此其指数型母函数为
> 
> $$
> 
> D(x)=\sum_{n\ge 0} D_n\frac{x^n}{n!}
> 
> =\sum_{n\ge 0}\left(n!\sum_{k=0}^{n}\frac{(-1)^k}{k!}\right)\frac{x^n}{n!}
> 
> =\frac{e^{-x}}{1-x}.
> 
> $$
> 
>   
> 
> ## 步骤 1：下标平移与求导
> 
> EGF 的基本性质：若
> 
> $$
> 
> U(x)=\sum_{n\ge 0}u_n\frac{x^n}{n!},
> 
> $$
> 
> 则
> 
> $$
> 
> U'(x)=\sum_{n\ge 0}u_{n+1}\frac{x^n}{n!},\quad
> 
> U''(x)=\sum_{n\ge 0}u_{n+2}\frac{x^n}{n!}.
> 
> $$
> 
>   
> 
> 因此
> 
> $$
> 
> B(x):=\sum_{j\ge 0}D_{j+2}\frac{x^j}{j!}=D''(x).
> 
> $$
> 
>   
> 
> 对
> 
> $$
> 
> D(x)=\frac{e^{-x}}{1-x}
> 
> $$
> 
> 两次求导，先一次：
> 
> $$
> 
> D'(x)=\frac{d}{dx}\Big(e^{-x}(1-x)^{-1}\Big)
> 
> =-e^{-x}(1-x)^{-1}+e^{-x}(1-x)^{-2}
> 
> =\frac{x\,e^{-x}}{(1-x)^2}.
> 
> $$
> 
> 再一次：
> 
> $$
> 
> \begin{aligned}
> 
> D''(x)
> 
> &=\frac{d}{dx}\left(\frac{x\,e^{-x}}{(1-x)^2}\right)\\
> 
> &=e^{-x}(1-x)^{-2}-x\,e^{-x}(1-x)^{-2}
> 
> +2x\,e^{-x}(1-x)^{-3}\\
> 
> &=e^{-x}(1-x)^{-1}+2x\,e^{-x}(1-x)^{-3}.
> 
> \end{aligned}
> 
> $$
> 
>   
> 
> 故
> 
> $$
> 
> B(x)=D''(x)=e^{-x}\Big((1-x)^{-1}+2x(1-x)^{-3}\Big).
> 
> $$
> 
>   
> 
> ## 步骤 2：二项式卷积与乘以 $e^x$
> 
> 若
> 
> $$
> 
> a_i=\sum_{j=0}^i \binom{i}{j}\,b_j,
> 
> $$
> 
> 则它们的 EGF 满足
> 
> $$
> 
> A(x):=\sum_{i\ge 0}a_i\frac{x^i}{i!}
> 
> =e^x\sum_{j\ge 0}b_j\frac{x^j}{j!}
> 
> =e^x\,B(x).
> 
> $$
> 
>   
> 
> 在本题中 $b_j=D_{j+2}$，即
> 
> $$
> 
> A(x)=e^x\,B(x)=e^x\,D''(x).
> 
> $$
> 
>   
> 
> ## 步骤 3：化简生成函数
> 
> 由上得
> 
> $$
> 
> \begin{aligned}
> 
> A(x)
> 
> &=e^x\cdot e^{-x}\Big((1-x)^{-1}+2x(1-x)^{-3}\Big)\\
> 
> &=(1-x)^{-1}+2x(1-x)^{-3}\\
> 
> &=\frac{(1-x)^2+2x}{(1-x)^3}
> 
> =\frac{1+x^2}{(1-x)^3}.
> 
> \end{aligned}
> 
> $$
> 
>   
> 
> 这里
> 
> $$
> 
> A(x)=\sum_{i\ge 0} a_i\frac{x^i}{i!}
> 
> $$
> 
> 是 EGF，因此 $a_i/i!$ 等于 $A(x)$ 的 $x^i$ 项系数。
> 
>   
> 
> ## 步骤 4：读取系数
> 
> 利用
> 
> $$
> 
> (1-x)^{-m}=\sum_{i\ge 0}\binom{i+m-1}{m-1}x^i,
> 
> $$
> 
> 可得：
> 
>   
> 
> - $(1-x)^{-1}$ 的 $x^i$ 系数为 $1$；
> 
> - $(1-x)^{-3}$ 的 $x^i$ 系数为 $\binom{i+2}{2}$，因此 $2x(1-x)^{-3}$ 的 $x^i$ 系数（$i\ge 1$）为
> 
> $$
> 
> 2\binom{i+1}{2}=i(i+1).
> 
> $$
> 
>   
> 
> 两部分相加：
> 
> $$
> 
> \frac{a_i}{i!}=1+i(i+1)\quad\Longrightarrow\quad
> 
> a_i=i!\,(i^2+i+1).
> 
> $$
> 
>   
> 
> 等价地，从
> 
> $$
> 
> A(x)=\frac{1+x^2}{(1-x)^3}
> 
> =\sum_{i\ge 0}\Big(\binom{i+2}{2}+\binom{i}{2}\Big)x^i
> 
> $$
> 
> 也可读出
> 
> $$
> 
> \binom{i+2}{2}+\binom{i}{2}
> 
> =\frac{(i+2)(i+1)+i(i-1)}{2}
> 
> =i^2+i+1.
> 
> $$
> 
>   
> 
> ## 校验
> 
> - $i=0$：$a_0=D_2=1$；公式给出 $0!\cdot 1=1$。
> 
> - $i=1$：$a_1=\binom{1}{0}D_2+\binom{1}{1}D_3=1+2=3$；公式给出 $1!\cdot 3=3$。
> 
> - $i=2$：$a_2=1+2\cdot 2+9=14$；公式给出 $2!\cdot 7=14$。
> 
>   
> 
> ## 备注（一般化）
> 
> 更一般地，对任意固定整数 $r\ge 0$，
> 
> $$
> 
> a_i^{(r)}=\sum_{j=0}^i \binom{i}{j}\,D_{j+r}
> 
> $$
> 
> 的 EGF 为
> 
> $$
> 
> A_r(x)=e^x D^{(r)}(x)=\frac{\text{某个关于 }x\text{ 的多项式}}{(1-x)^{r+1}},
> 
> $$
> 
> 从而
> 
> $$
> 
> a_i^{(r)}=i!\cdot P_r(i),
> 
> $$
> 
> 其中 $P_r(i)$ 为关于 $i$ 的次数为 $r$ 的多项式。本题即为 $r=2$ 的情形，$P_2(i)=i^2+i+1$。

接下来需要对 $L=0,1,\ldots,n-2$ 求出树上长度为 $L+2$ 的链的数量。
考虑点分治，在树的重心处枚举所有经过它的链。
使用生成函数优化这一过程。从重心向下走，把深度（设直系儿子深度为 $0$）放在指数上，数量放在系数上，记生成函数
$$f(u)=\sum_{d\ge 0,v\in subtree(u)} [dep(v)=d]x^d$$
链相当于选两条向下的路径拼起来，再加上重心这一个点（因为深度从 $0$ 开始），即 $x\times f(i)\times f(j)$，则长度为 $L+2$ 的链数量的生成函数为
$$
g(u) = x\sum_{i}\bigg(f(son_i)\times \sum_{j<i} f(son_j)\bigg)
$$
使用 fft/ntt 优化，点分治一共递归 $O(\log n)$ 层，每层 $O(n)$ 求出 $f$，然后使用 ntt 卷积 $O(\log n)$，时间复杂度 $O(n\log ^2n)$

[***AC 代码***](https://codeforces.com/gym/106072/submission/339400429)

```cpp
#include <bits/stdc++.h>
using namespace std;

#define fp(i, a, b) for (int i = (a), i##_ = (b) + 1; i < i##_; ++i)
#define fd(i, a, b) for (int i = (a), i##_ = (b) - 1; i > i##_; --i)
const int maxn = 2e5 + 5, P = 998244353;
using ll = int64_t;
#define ADD(a, b) (((a) += (b)) >= P ? (a) -= P : 0)
#define SUB(a, b) (((a) -= (b)) < 0 ? (a) += P : 0)
#define MUL(a, b) (ll(a) * (b) % P)
int POW(ll a, int b = P - 2, ll x = 1) {
    for (; b; b >>= 1, a = a * a % P)
        if (b & 1)
            x = x * a % P;
    return x;
}

namespace NTT {
const int g = 3;
vector<int> Omega(int L) {
    int wn = POW(g, P / L);
    vector<int> w(L);
    w[L >> 1] = 1;
    fp(i, L / 2 + 1, L - 1) w[i] = MUL(w[i - 1], wn);
    fd(i, L / 2 - 1, 1) w[i] = w[i << 1];
    return w;
}
auto W = Omega(1 << 21);
void DIF(int *a, int n) {
    for (int k = n >> 1; k; k >>= 1) {
        for (int i = 0, y; i < n; i += k << 1)
            fp(j, 0, k - 1) y = a[i + j + k],
                            a[i + j + k] = MUL(a[i + j] - y + P, W[k + j]),
                            ADD(a[i + j], y);
    }
}
void IDIT(int *a, int n) {
    for (int k = 1; k < n; k <<= 1) {
        for (int i = 0, x, y; i < n; i += k << 1)
            fp(j, 0, k - 1) x = a[i + j], y = MUL(a[i + j + k], W[k + j]),
                            a[i + j + k] = x - y < 0 ? x - y + P : x - y,
                            ADD(a[i + j], y);
    }
    int Inv = P - (P - 1) / n;
    fp(i, 0, n - 1) a[i] = MUL(a[i], Inv);
    reverse(a + 1, a + n);
}
} // namespace NTT
namespace Polynomial {
using Poly = std::vector<int>;
Poly &operator*=(Poly &a, int b) {
    for (auto &x : a)
        x = MUL(x, b);
    return a;
}
Poly operator*(Poly a, int b) {
    return a *= b;
}
Poly operator*(int a, Poly b) {
    return b * a;
}
void DFT(Poly &a) {
    NTT::DIF(a.data(), a.size());
}
void IDFT(Poly &a) {
    NTT::IDIT(a.data(), a.size());
}
int norm(int n) {
    return 1 << (32 - __builtin_clz(n - 1));
}
void norm(Poly &a) {
    if (!a.empty())
        a.resize(norm(a.size()), 0);
}
Poly &dot(Poly &a, Poly &b) {
    fp(i, 0, a.size() - 1) a[i] = MUL(a[i], b[i]);
    return a;
}
Poly operator*(Poly a, Poly b) {
    int n = a.size() + b.size() - 1, L = norm(n);
    if (a.size() <= 8 || b.size() <= 8) {
        Poly c(n);
        fp(i, 0, a.size() - 1) fp(j, 0, b.size() - 1) c[i + j] =
            (c[i + j] + (ll)a[i] * b[j]) % P;
        return c;
    }
    a.resize(L), b.resize(L);
    DFT(a), DFT(b), dot(a, b), IDFT(a);
    return a.resize(n), a;
}
} // namespace Polynomial
using namespace Polynomial;

const int N = 1e5;
int n, siz[N + 5], dep[N + 5];
int ans[N + 5];
bool vis[N];
vector<int> G[N + 5];

void calcsiz(int u, int fa, int sum,
             int &core) { // 求树的重心，sum 表述当前树的大小
    siz[u] = 1;
    int mxz = 0;
    for (auto v : G[u]) {
        if (v != fa && !vis[v]) {
            calcsiz(v, u, sum, core);
            siz[u] += siz[v];
            mxz = max(mxz, siz[v]);
        }
    }
    mxz = max(mxz, sum - siz[u]);
    if (mxz * 2 <= sum) {
        core = u;
    }
}

void calcdis(int u, int fa, Poly& f) {
    dep[u] = dep[fa] + 1;
    if (int(f.size()) <= dep[u]) {
        f.resize(dep[u] + 1);
    }
    ++f[dep[u]];
    for (auto v : G[u]) {
        if (v != fa && !vis[v]) {
            calcdis(v, u, f);
        }
    }
}

void work(int u, int fa) {
    vis[u] = true;
    Poly cnt = {1};
    for (auto v : G[u]) {
        if (v != fa && !vis[v]) {
            Poly formu;
            dep[u] = 0;
            calcdis(v, u, formu);
            Poly res = cnt * formu;
            for (int i = 0; i < int(res.size()); ++i) {
                ADD(ans[i + 1], res[i]);
            }
            if (cnt.size() < formu.size()) {
                cnt.resize(formu.size());
            }
            for (int i = 1; i < int(formu.size()); ++i) {
                ADD(cnt[i], formu[i]);
            }
        }
    }
    for (auto v : G[u]) {
        if (v != fa && !vis[v]) {
            int sum = siz[v];
            int core = 0;
            calcsiz(v, u, sum, core);
            calcsiz(core, u, sum, core); // 第二次调用更新 siz[]
            work(core, u);
        }
    }
}

void solve() {
    cin >> n;
    for (int i = 1; i < n; ++i) {
        int u, v;
        cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    int core = 0;
    calcsiz(1, 0, n, core);
    calcsiz(core, 0, n, core);
    work(core, 0);
    ll val = 1;
    ll fac = 1;
    for (int k = 2; k <= n; ++k) {
        if (k - 2 > 0) {
            fac = fac * (k - 2) % P;
        }
        ll f = (1LL*(k-2)*(k-2)+(k-2)+1) % P * fac % P;
        ADD(val, (f*ans[k]%P));
    }
    cout << val << "\n";
    for (int i = 1; i <= n; ++i) {
        ans[i] = 0;
        vis[i] = 0;
        G[i].clear();
    }
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
```