---
tags:
  - 题解
  - DP
aliases:
  - Iron Bars Cutting
---
## [NCC108298I. Iron Bars Cutting](https://ac.nowcoder.com/acm/contest/108298/I)

DP。
设 $dp(l,r,x)$ 表示第一刀把区间 $[l,r]$ 切成 $[l,x]$ 和 $[x+1,r]$ 的最小花费。
记不平衡度为 $D(l,r,x)$，每次操作的花费为 $C(l,r,x)$，则有状态转移方程
$$
dp(l,r,x)=\min_{D(l,r,x)\ge D(l,x,i),D(x+1,r,j)}\bigg\{ dp(l,x,i) + dp(x+1,r,j)+C(l,r,x) \bigg\}
$$
不考虑不平衡度的限制，作为一个朴素的区间 DP，应该从小区间往大区间转移。加上不平衡度的限制，实际上是进一步规定了转移的先后顺序。如果小区间的不平衡度大于大区间，那么这个转移是非法的。为了保证不进行上述转移，我们需要优先对不平衡度小的大区间进行转移，此时不平衡度大的小区间仍然是 $\infty$，也就是不会进行上述转移。
换句话说，把所有区间及切割方案 $(l,r,x)$ 优先按照 $D(l,r,x)$ 从小到大排序，再按照区间长度 $r-l+1$ 从小到大排序，按照这个顺序进行转移即可。时间复杂度 $O(n^3\log n)$。

[***AC 代码***](https://ac.nowcoder.com/acm/contest/view-submission?submissionId=78248754)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

constexpr ll inf = 1e18;

struct node {
    ll diff;
    int l, r, x;
    
    friend bool operator< (node a, node b) {
        if (a.diff == b.diff) { return a.r-a.l+1 < b.r-b.l+1; }
        return a.diff < b.diff;
    }
} p[20000007];

ll a[421], dp[421][421], ans[421];

void solve()
{
	int n;
	cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
    }
    partial_sum(a+1, a+n+1, a+1);

    int tot = 0;
    for (int l = 1; l <= n; ++l) {
        for (int r = l + 1; r <= n; ++r) {
            dp[l][r] = inf;
            for (int x = l; x < r; ++x) {
                ll l1 = a[x] - a[l - 1];
                ll l2 = a[r] - a[x];
                ll diff = abs(l1 - l2);
                ll cost = min(l1, l2) * ceil(log2(l1 + l2));
                int len = r - l + 1;
                p[++tot] = { diff, l, r, x };
            }
        }
    }
    sort(p+1, p+tot+1);

    for (int i = 1; i <= n; ++i) {
        ans[i] = inf;
        dp[i][i] = 0;
    }
    for (int i = 1; i <= tot; ++i) {
        auto [diff, l, r, x] = p[i];
        ll l1 = a[x] - a[l - 1];
        ll l2 = a[r] - a[x];
        ll cost = dp[l][x] + dp[x+1][r] + min(l1, l2) * ceil(log2(l1 + l2));
        dp[l][r] = min(dp[l][r], cost);
        if (l == 1 && r == n) {
            ans[x] = min(ans[x], cost);
        }
    }
    for (int i = 1; i < n; ++i) {
        cout << (ans[i] == inf ? -1 : ans[i]) << " \n"[i == n - 1];
    }
}

int main()
{
	cin.tie(nullptr)->sync_with_stdio(false);
	int t = 1;
	cin >> t;
	while (t--) { solve(); }
}

```
