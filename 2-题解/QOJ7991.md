---
tags:
  - 题解
  - 最短路
  - 拓扑排序
aliases:
  - 最小环
---
## [QOJ7991. 最小环](https://qoj.ac/contest/1464/problem/7991)

前置知识是 $O(nm\log m)$ 的有向图最小环做法。枚举起点跑最短路，如果有一条由 $t$ 指向 $s$ 的边，那么 $s$ 到 $t$ 的最短路加上这条边就是最小环。
最特征的条件是 $m-n\le 1500$，相当于在树上加上极少的边后成环。
可想而知需要枚举的起点只有 $n'=2(m-n)$ 个。但是后半部分最短路的复杂度还是难以接受。
显然这 $n'$ 个点之间如果靠链连接，那么这条链可以被压成一条边。同时如果原图上一个点只有入度或只有出度，那么它必然不可能在环上。这些点和边是冗余的，使用拓扑排序删除即可。
将他们删除后，所有点的度数均大于 $3$，满足不等式 $2m'\ge 3n'$，同时每删除一个点，必然删除至少一条边，因此 $m'-n'\le 1500$，解得 $n'\le 3000,\ m'\le 4500$，再在这个上面跑 $O(n'm'\lg m')$ 的最小环算法即可。

[***AC 代码***](https://qoj.ac/submission/1335761)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 3e5;
const ll inf = 1e18;
int n, m;
int ind[N + 5], oud[N + 5];
bool del[N + 5];
vector<array<ll, 4>> E;
vector<int> G[N + 5];

bool check(int u) {
    return (ind[u] == 1 && oud[u] == 1) || (ind[u] == 0) || (oud[u] == 0);
}

ll ans = inf;
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= m; ++i) {
        int u, v;
        ll w;
        cin >> u >> v >> w;
        ++oud[u];
        ++ind[v];
        if (u == v) {
            ans = min(ans, w);
        }
        G[u].push_back(E.size());
        G[v].push_back(E.size());
        E.push_back({u, v, w, 0});
    }
    queue<int> q;
    for (int u = 1; u <= n; ++u) {
        if (check(u)) {
            q.push(u);
        }
    }
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        if (del[u]) {
            continue;
        }
        del[u] = 1;
        int s, t;
        ll ww = 0;
        for (auto id : G[u]) {
            auto &[x, y, w, del] = E[id];
            if (del) {
                continue;
            }
            if (x == y) {
                ans = min(ans, w);
            }
            del = 1;
            ww += w;
            if (x == u) {
                t = y;
                --ind[y];
            } else {
                s = x;
                --oud[x];
            }
        }
        if (ind[u] == 1 && oud[u] == 1) {
            ++oud[s];
            ++ind[t];
            G[s].push_back(E.size());
            G[t].push_back(E.size());
            E.push_back({s, t, ww, 0});
        }
        for (auto id : G[u]) {
            auto &[x, y, w, _] = E[id];
            if (!del[x] && check(x)) {
                q.push(x);
            }
            if (!del[y] && check(y)) {
                q.push(y);
            }
        }
    }
    for (int s = 1; s <= n; ++s) {
        if (del[s]) {
            continue;
        }
        vector<ll> dis(n + 1, inf);
        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<>> q;
        q.emplace(0, s);
        dis[s] = 0;
        while (!q.empty()) {
            auto [_, u] = q.top();
            q.pop();
            for (auto id : G[u]) {
                auto [x, y, w, del] = E[id];
                if (x != u || del) {
                    continue;
                }
                if (dis[y] > dis[u] + w) {
                    dis[y] = dis[u] + w;
                    q.emplace(dis[y], y);
                }
                if (y == s) {
                    ans = min(ans, dis[u] + w);
                }
            }
        }
    }
    cout << (ans == inf ? -1 : ans) << "\n";
}
```
