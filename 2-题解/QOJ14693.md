---
tags:
  - 题解
  - 观察
  - DP
aliases:
  - Mystique as Iris
---
## [QOJ14693. Mystique as Iris](https://qoj.ac/contest/2558/problem/14693)

写暴力观察。记 $\texttt{X}$ 为大于等于 $n$ 的数字，不合法的条件是：①序列两端都是 $\texttt{X}$ 的连续段，②中间不存在两个连续的 $\texttt{1}$，③不存在 $[2,n-1]$ 上的数字。也就是只有 $\texttt{XX1XX1XX}$ 这种是不合法的。
*TODO：这个结论不是很会证明*
DP 求非法序列的数量。设第 $i$ 位是 $1$ 或者大于等于 $n$ 的数，前 $i$ 位的方案数分别为 $f(i,0 / 1)$，转移显然。
需要特判 $n=1$ 和全一的情况。

[***AC 代码***](https://qoj.ac/submission/1623828)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

const int MOD = 1e9+7;
ll add(ll x, ll y) { return (x + y) % MOD; }
ll del(ll x, ll y) { return add(x, MOD - y); }
ll mul(ll x, ll y) { return x * y % MOD; }

void solve()
{
    int n, m;
    cin >> n >> m;
    if (n == 1) { cout << "0\n"; return; }
    vector<int> a(n + 1);
    ll ans = 1;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        if (a[i] == -1) { ans = mul(ans, m); }
    }
    vector f(n + 1, vector<ll>(2));
    f[0][1] = 1;
    for (int i = 1; i <= n; ++i) {
        if (a[i] == -1) {
            if (i > 1) { f[i][0] = f[i-1][1]; }
            f[i][1] = mul(max(0, m - n + 1), add(f[i-1][0], f[i-1][1]));
        } else {
            if (a[i] == 1) {
                f[i][0] = (i == 1 ? 0: f[i-1][1]);
            } else if (a[i] < n) {
                f[i][0] = f[i][1] = 0;
            } else {
                f[i][1] = add(f[i-1][0], f[i-1][1]);
            }
        }
    }
    ans = del(ans, f[n][1]);
    if (n % 2 == 1 && all_of(a.begin()+1, a.end(), [&](int x){ return x==1 || x==-1; })) {
        ans = del(ans, 1);
    }
    cout << ans << "\n";
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int t = 1;
    // cin >> t;
    while (t--) { solve(); }
}

```
