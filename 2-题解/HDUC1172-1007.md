---
tags:
  - 题解
  - DP/树形DP
  - 莫比乌斯反演
  - DP/SOSDP
  - DP/状压DP
aliases:
  - jin
---
## [HDUC1172-1007. 树上LCM](https://acm.hdu.edu.cn/contest/problem?cid=1172&pid=1007)

### 方法一：树 DP

设 $f(u, d)$ 表示从 $u$ 往下走一条链，且这条链的 LCM 等于 $d$ 的方案数。状态转移方程 
$$f(u,d)=\sum_{\mathrm{lcm}(a_u,d')=d} f(v,d')$$
考虑如何统计答案。首先 $f(i,x)$ 肯定都要加入答案，接下来考虑两条链拼起来的答案。
考虑枚举到 $u$ 的一个子树 $v$ 时，记一个前缀和 $s(d)$ 表示从 $u$ 往前面的子树走一条链，并且 LCM 等于 $d$ 的方案数，答案需要加上
$$\sum_{\mathrm{lcm}(d,d')=x}s(d)\times f(v,d')$$
记 $D$ 是 $x$ 的因子个数，这是一个 $O(nD^2)$ 的转移，但是 $\mathrm{lcm}(d,d')=x$ 的组数远远小于 $D^2$，可以通过预处理减小常数通过本题。

[***AC 代码***](https://acm.hdu.edu.cn/contest/view-code?cid=1172&rid=27676)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

const int N = 1e5+105, MD = 500;
int n, D, a[N+5];
ll X;
int LCM[N+5][MD+5];
ll d[MD+5];
vector<int> G[N+5];
vector<int> T[MD+5];
vector<ll> f[N+5];
ll ans;

void dfs(int u, int fa)
{
    f[u].assign(D+5, 0);
    vector<ll> s(D+5, 0);

    if (LCM[u][1] != -1) {
        f[u][LCM[u][1]] = 1;
    }
    
    for (auto v: G[u]) {
        if (v == fa) { continue; }
        dfs(v, u);

        for (int ix = 1; ix <= D; ++ix) {
            int x = d[ix];

            int iL = LCM[u][ix];
            if (iL == -1) { continue; }

            // 转移
            f[u][iL] += f[v][ix];

            // 以 u 为根往下走两条路径的答案
            for (auto iy: T[ix]) {
                ans += s[iy] * f[v][ix];
            }
        }

        // 累加入前缀和
        for (int ix = 1; ix <= D; ++ix) {

            int iL = LCM[u][ix];
            if (iL == -1) { continue; }

            s[iL] += f[v][ix];
        }
    }

    // 以 u 为根往下走一条路径的答案
    ans += f[u][D];
}

void solve(bool out)
{
    ans = 0;
	cin >> n >> X;
    for (int i = 1; i < n; ++i) {
        int u, v;
        cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
    }
    
    // 预处理因数
    for (ll y = 1; y * y <= X; ++y) {
        if (X % y == 0) {
            d[++D] = y;
            if (y * y != X) { d[++D] = X / y; }
        }
    }
    sort(d+1, d+D+1);
    for (int i = 1; i <= D; ++i) {
        for (int j = i+1; j <= D; ++j) {
            ll a = d[i];
            ll b = d[j];
            int ia = lower_bound(d+1, d+D+1, a) - d;
            int ib = lower_bound(d+1, d+D+1, b) - d;
            if (lcm(a, b) == X) {
                T[ia].push_back(ib);
                T[ib].push_back(ia);
            }
        }
    }
    T[D].push_back(D);

    // 预处理 LCM
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= D; ++j) {
            LCM[i][j] = -1;
            ll v = lcm(a[i], d[j]);
            auto it = lower_bound(d+1, d+D+1, v);
            if (*it == v) {
                LCM[i][j] = it - d;
                assert(1 <= LCM[i][j] && LCM[i][j] <= D);
            }
        }
    }

    // 
    dfs(1, 0);
    cout << ans;

    // 清空
    for (int i = 1; i <= n; ++i) {
        G[i].clear();
    }
    for (int i = 1; i <= D; ++i) {
        d[i] = 0;
        T[i].clear(); 
    }
    D = 0;
}

signed main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
	int t = 1;
	cin >> t;
	for (int i = 1; i <= t; ++i) {
        solve(0);
        if (i < t) { cout << "\n"; }
    }
}

```

### 方法二 ：莫比乌斯反演

LCM 恰好等于 $x$ 的方案数 $f(x)$ 难以直接求出，但是 LCM 为 $x$ 因数的方案数 $g(x)$ 很好求出。
对 $x$ 的所有因数 $d$ 求出 $g(d)$。做法是在并查集上合并相邻且点权值满足 $a_u\mid d$ 的点对，最后
$$
g(d)=\sum_{siz} {siz\choose 2}
$$
使用莫比乌斯反演进行容斥。从小到大遍历因数，有转移方程
$$
f(n)=g(n)-\sum_{d\mid n} f(d)
$$
时间复杂度 $O(nD+D^2)$

[***AC 代码***](https://acm.hdu.edu.cn/contest/view-code?cid=1172&rid=27680)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

struct DSU {
    int n;
    vector<int> f, siz;
    DSU(int n): n(n), f(n+1), siz(n+1, 1) { iota(f.begin(), f.end(), 0); }
    int find(int x) {
        return f[x]==x? f[x]: f[x]=find(f[x]);
    }
    void merge(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) { return; }
        f[x] = y;
        siz[y] += siz[x];
        siz[x] = 0;
    }
};

void solve()
{
	int n, x;
	cin >> n >> x;
    vector<pair<int,int>> E(n-1);
    for (auto& [x, y]: E) { cin >> x >> y; }
    vector<int> a(n+1);
    for (int i = 1; i <= n; ++i) { cin >> a[i]; }

    vector<int> fac;
    for (ll i = 1; i * i <= x; ++i) {
        if (x % i == 0) {
            fac.push_back(i);
            if (i * i != x) { fac.push_back(x / i); }
        }
    }
    sort(fac.begin(), fac.end());
    const int d = fac.size();

    vector<ll> dp(d);
    for (int i = 0; i < d; ++i) {
        DSU d(n);
        for (auto [x, y]: E) {
            if (fac[i] % a[x] == 0 && fac[i] % a[y] == 0) {
                d.merge(x, y);
            }
        }
        for (int j = 1; j <= n; ++j) {
            if (fac[i] % a[j] == 0 && d.find(j) == j) {
                dp[i] += 1LL * d.siz[j] * (d.siz[j]+1) / 2;
            }
        }
    }
    for (int i = 0; i < d; ++i) {
        for (int j = 0; j < i; ++j) {
            if (fac[i] % fac[j] == 0) {
                dp[i] -= dp[j];
            }
        }
    }
    cout << dp.back() << "\n";
}

int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
	int t = 1;
	cin >> t;
	while (t--) { solve(); }
}
```

### 方法三：状压+高维前缀和

