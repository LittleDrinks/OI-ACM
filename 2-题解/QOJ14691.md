---
tags:
  - 题解
  - 网络流/最大流
aliases:
  - Killing Bits
---
## [QOJ14691. Killing Bits](http://qoj.ac/contest/2562/problem/14691)

想要 $a_i\to b_i$，必要条件是每一步操作，$b_i$ 中为 $1$ 的位置不能动，或者说 $a_i$ 和 $p_i$ 都是 $b_i$ 的超集。
形式化地，对于每一步操作，合法的条件是：
$$
\begin{cases}
a_i\& b_i=b_i\\
p_i\&b_i=b_i
\end{cases}
$$
由于 $p_i$ 是 $b_i$ 的超集，所以 $b_i\le p_i\le n$，因此 $b_i$ 必然在 $p$ 中出现过，不妨设 $p_j=b_i$。
我们发现：① $b_j\subseteq p_j=b_i\subseteq p_i$；② $b_i=p_j\Rightarrow b_i\subseteq p_j$。因此，交换 $p_i$ 和 $p_j$ 形成的 $p'$ 仍然合法，并且使用 $p'$ 可以把 $a_i\to b_i$，我们可以重复 $n$ 次这样的操作，将 $a$ 完全变为 $b$。
综上：$\begin{cases}a_i\& b_i=b_i\\p_i\&b_i=b_i\end{cases}$ 是 $a$ 能转化为 $b$ 的充要条件。
第一个条件很好维护。
第二个条件可以看作每个 $b_i$ 匹配一个 $x\ (0\le x\le n - 1)$。
考虑网络流。每个 $b_i$ 直接向其所有超集连边，总共需要 $O(n^2)$ 条边，复杂度爆炸。
优化建图，每个数 $x$ 向其二进制位中缺少一位的子集连容量为 $\infty$ 的边，源点 $S$ 向 $x: 0\sim n-1$ 连容量为 $1$ 的边，$b_i$ 向汇点 $T$ 连容量为 $1$ 的边，这样只需要 $O(n\log n)$ 条边即可。

[***AC 代码***](http://qoj.ac/submission/1743075)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

template<typename T>
struct Flow {
    struct _edge {
        int to;
        T cap;
        _edge(int to, T cap): to(to), cap(cap) { }
    };

    const static int inf = numeric_limits<T>::max();
    int n;
    vector<_edge> e;
    vector<vector<int>> g;
    vector<int> cur, h;

    Flow() { }
    Flow(int n): n(n), e(), g(n + 1), cur(n + 1), h(n + 1) { }

    bool bfs(int s, int t) {
        h.assign(n + 1, -1);
        queue<int> que;
        h[s] = 0;
        que.push(s);
        while (!que.empty()) {
            const int u = que.front(); que.pop();
            for (auto i: g[u]) {
                auto [v, c] = e[i];
                if (c > 0 && h[v] == -1) {
                    h[v] = h[u] + 1;
                    if (v == t) {
                        return true;
                    }
                    que.push(v);
                }
            }
        }
        return false;
    }

    T dfs(int u, int t, T f) {
        if (u == t) { return f; }
        auto r = f;
        for (int &i = cur[u]; i < int(g[u].size()); ++i) {
            const int j = g[u][i];
            auto [v, c] = e[j];
            if (c > 0 && h[v] == h[u] + 1) {
                auto a = dfs(v, t, min(r, c));
                e[j].cap -= a;
                e[j ^ 1].cap += a;
                r -= a;
                if (r == 0) {
                    return f;
                }
            }
        }
        return f - r;
    }

    void add_edge(int u, int v, T c) {
        g[u].push_back(e.size());
        e.emplace_back(v, c);
        g[v].push_back(e.size());
        e.emplace_back(u, 0);
    }

    T maxFlow(int s, int t) {
        T ans = 0;
        while (bfs(s, t)) {
            cur.assign(n + 1, 0);
            ans += dfs(s, t, numeric_limits<T>::max());
        }
        return ans;
    }
};

void solve()
{
    int n;
    cin >> n;

    vector<int> a(n), b(n);
    for (int i = 0; i < n; ++i) { cin >> a[i]; }
    for (int i = 0; i < n; ++i) { cin >> b[i]; }

    if (a == b) {
        cout << "Yes\n"; return;
    }

    for (int i = 0; i < n; ++i) {
        if ((a[i] & b[i]) != b[i]) {
            cout << "No\n"; return;
        }
    }

    Flow<int> G(n + 1);
    int s = n, t = n + 1;
    for (int i = 0; i < n; ++i) {
        G.add_edge(b[i], t, 1);
        G.add_edge(s, i, 1);
        for (int j = 0; j < 17; ++j) {
            if (i >> j & 1) {
                G.add_edge(i, (i^(1<<j)), Flow<int>::inf);
            }
        }
    }

    int mf = G.maxFlow(s, t);
    cout << (mf == n ? "Yes": "No") << "\n";
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int t = 1;
    cin >> t;
    while (t--) { solve(); }
}
```
