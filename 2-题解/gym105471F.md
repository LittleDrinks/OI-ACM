---
tags:
  - 题解
  - DP
  - 离散对数
  - lucas
aliases:
  - An Easy Counting Problem
---
## [gym105471F. An Easy Counting Problem](https://codeforces.com/gym/105471/problem/F)

模数较小的情况下计算组合数可以使用 lucas定理，将 $a\choose b$ 不断按 lucas 展开，等价于将 $a,b$ 表示为 $p$ 进制的数字然后计算组合数连乘，即
$$
\begin{align}
&(a_1a_2\ldots a_k)_p=a \\
&(b_1b_2\ldots b_k)_p=b \\
&{a\choose b}\bmod p = \prod_{i=1}^k {a_i\choose b_i}\bmod p
\end{align}
$$
使用类似数位 DP 的思想，考虑每一位应该填什么数字。
设 $dp(i,x)$ 表示前 $i$ 位结果为 $x$ 的方案数，则有
$$
\begin{align}
& dp(1,x)=\sum_{i=0}^{p-1}\sum_{j=0}^i\Bigg[{i\choose j} = x\Bigg] \\
& dp(i, x) = \sum_{y\times z\equiv x\pmod p}dp(i-1, y)\times dp(1, z)
\end{align}
$$
其中 $dp(1,x)$ 容易在 $O(p^2)$ 的时间内预处理。
使用矩阵快速幂的思想，将转移方程改写为
$$
dp(2^i, x) = \sum_{y\times z\equiv x\pmod p}dp(2^{i-1}, y)\times dp(2^{i-1}, z)
$$
时间复杂度 $O(p^2\log_2 k)$
记 $\log x$ 表示对 $x$ 取离散对数。对 $x,y,z$ 取离散对数就可以转化为卷积的形式。
$$
dp(2^i, \log x) = \sum_{\log y + \log z = \log x}dp(2^{i-1}, \log y)\times dp(2^{i-1}, \log z)
$$
在本题的数据范围下，原根可以直接 $O(p^2)$ 暴力求。使用 ntt 进行转移，时间复杂度 $O(p\log_2 p\log_2 k)$

[***AC 代码***](https://codeforces.com/gym/105471/submission/341698590)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 2e5 + 5, MOD = 998244353;
ll add(ll x, ll y) {
    return (x + y) % MOD;
}
ll del(ll x, ll y) {
    return add(x, MOD - y);
}
ll mul(ll x, ll y) {
    return x * y % MOD;
}
ll qpow(ll a, ll b = MOD - 2) {
    ll res = 1;
    for (; b; b >>= 1, a = mul(a, a)) {
        if (b & 1) {
            res = mul(res, a);
        }
    }
    return res;
}

namespace NTT {
const int g = 3;
vector<int> Omega(int L) {
    int wn = qpow(g, MOD / L);
    vector<int> w(L);
    w[L >> 1] = 1;
    for (int i = L / 2 + 1; i <= L - 1; ++i) {
        w[i] = mul(w[i - 1], wn);
    }
    for (int i = L / 2 - 1; i; --i) {
        w[i] = w[i << 1];
    }
    return w;
}
auto W = Omega(1 << 21);
void DIF(int *a, int n) {
    for (int k = n >> 1; k; k >>= 1) {
        for (int i = 0, y; i < n; i += k << 1) {
            for (int j = 0; j < k; ++j) {
                y = a[i + j + k];
                a[i + j + k] = mul(del(a[i + j], y), W[k + j]);
                a[i + j] = add(a[i + j], y);
            }
        }
    }
}
void IDIT(int *a, int n) {
    for (int k = 1; k < n; k <<= 1) {
        for (int i = 0, x, y; i < n; i += k << 1) {
            for (int j = 0; j < k; ++j) {
                x = a[i + j];
                y = mul(a[i + j + k], W[k + j]);
                a[i + j + k] = del(x, y);
                a[i + j] = add(a[i + j], y);
            }
        }
    }
    int Inv = MOD - (MOD - 1) / n;
    for (int i = 0; i < n; ++i) {
        a[i] = mul(a[i], Inv);
    }
    reverse(a + 1, a + n);
}
} // namespace NTT
namespace Polynomial {
using Poly = std::vector<int>;
Poly &operator*=(Poly &a, int b) {
    for (auto &x : a) {
        x = mul(x, b);
    }
    return a;
}
Poly operator*(Poly a, int b) {
    return a *= b;
}
Poly operator*(int a, Poly b) {
    return b * a;
}
void DFT(Poly &a) {
    NTT::DIF(a.data(), a.size());
}
void IDFT(Poly &a) {
    NTT::IDIT(a.data(), a.size());
}
int norm(int n) {
    return 1 << (32 - __builtin_clz(n - 1));
}
void norm(Poly &a) {
    if (!a.empty()) {
        a.resize(norm(a.size()), 0);
    }
}
Poly &dot(Poly &a, Poly &b) {
    for (int i = 0; i < int(a.size()); ++i) {
        a[i] = mul(a[i], b[i]);
    }
    return a;
}
Poly operator*(Poly a, Poly b) {
    int n = a.size() + b.size() - 1, L = norm(n);
    if (a.size() <= 8 || b.size() <= 8) {
        Poly c(n);
        for (int i = 0; i < int(a.size()); ++i) {
            for (int j = 0; j < int(b.size()); ++j) {
                c[i + j] = add(c[i + j], mul(a[i], b[j]));
            }
        }
        return c;
    }
    a.resize(L);
    b.resize(L);
    DFT(a);
    DFT(b);
    dot(a, b);
    IDFT(a);
    a.resize(n);
    return a;
}
} // namespace Polynomial
using namespace Polynomial;

int order(int x, int p) {
    int ord = 0, tmp = 1;
    do {
        ++ord;
        tmp = 1LL * tmp * x % p;
    } while (tmp != 1);
    return ord;
}

void solve() {
    string k;
    int p, x;
    cin >> k >> p >> x;

    vector C(p + 1, vector<int>(p + 1));
    C[0][0] = 1;
    for (int i = 1; i < p; ++i) {
        C[i][0] = 1;
        for (int j = 1; j <= i; ++j) {
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % p;
        }
    }
    vector<int> cnt(p);
    for (int i = 0; i < p; ++i) {
        for (int j = 0; j <= p; ++j) {
            cnt[C[i][j]]++;
        }
    }

    int g = -1;
    int phi = p - 1;
    for (int a = 1; a < p; ++a) {
        if (gcd(a, p) == 1 && order(a, p) == phi) {
            g = a;
            break;
        }
    }
    assert(g != -1);
    vector<int> id(p + 1);
    for (int i = 1, tmp = 1; i < phi; ++i) {
        tmp = 1LL * tmp * g % p;
        id[tmp] = i;
    }
    id[1] = 0;

    Poly a(p);
    for (int i = 1; i < p; ++i) {
        a[id[i]] = cnt[i];
    }

    Poly ans(phi);
    ans[0] = 1;
    reverse(k.begin(), k.end());
    for (auto b: k) {
        if (b == '1') {
            ans = ans * a;
        }
        a = a * a;
        for (int i = phi; i < int(a.size()); ++i) {
            a[i % phi] = add(a[i % phi], a[i]);
        }
        for (int i = phi; i < int(ans.size()); ++i) {
            ans[i % phi] = add(ans[i % phi], ans[i]);
        }
        a.resize(phi);
        ans.resize(phi);
    }

    cout << ans[id[x]] << "\n";
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t = 1;
    // cin >> t;
    while (t--) {
        solve();
    }
}
```
