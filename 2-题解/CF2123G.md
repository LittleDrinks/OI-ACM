---
tags:
  - 题解
  - 数论
aliases:
  - Modular Sorting
---
## [CF2123G. Modular Sorting](https://codeforces.com/problemset/problem/2123/G)

下记 $d = \gcd(k, m)$，$D(m)$ 为 $m$ 的因数个数。

> [!note] 结论：$a_i$ 若干步操作后可能的取值构成一个公差为 $d$ 的等差数列，或者说 $a_i\mod d$ 是一个定值
> 
> 考虑在 $m$ 个点的圆环上不断跳跃，最后落到的点的位置是有限的。
> 
> 考虑 $k=d$ 的情况。由于 $\dfrac{m}{d}\times d\equiv 0\pmod m$，因此每跳 $\dfrac{m}{d}$ 步就会重新回到起点，相邻两项的差值为 $d$，因此此时能跳到的点集构成一个公差为 $d$ 的等差数列。
> 
> 拓展到 $k>d$ 的情况。其实就是上一种情况每次多跳了几步。不妨设跳跃次数为 $x$，解同余方程
> 
> $$x\times \dfrac{k}{d}\equiv1\pmod {\dfrac{m}{d}}$$
> 
> 得到结论：每走 $x=\left(\dfrac{d}{k}\mod \dfrac{m}{d}\right)$ 步，$a_i\leftarrow a_i+d$。

不限制操作步数，最优的策略肯定是让序列头上的数字尽可能小。因此只有当 $a_{i-1}\mathrm{\ mod\ } d > a_i\mathrm{\ mod\ } d$ 时，才令后一项增大一步。
因此，存在调整方案当且仅当 $ans[d] \cdot d < m$，其中 $ans[d]$ 表示数组在模 $d$ 意义下的相邻逆序对数量（即满足 $a_{i-1} \mod d > a_i \mod d$ 的相邻对数）。
对于一次询问 $k$，我们只关心所有数在模 $d$ 意义下的相对大小。一共有 $D(m)$ 种本质不同的询问，而每次单点修改操作只会影响它与相邻两项的相对大小。因此我们可以在 $O(D(m))$ 的时间内与处理出 $ans[d]$ 然后 $O(1)$ 回答询问。
复杂度 $O((n+q) \cdot D(m))$。

[***AC 代码***](https://codeforces.com/contest/2123/submission/331856731)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

const int X=5e5;
vector<int> fac[X+5];
ll ans[X+5];

void solve()
{
	int n, m, q;
	cin >> n >> m >> q;
    vector<int> a(n+1);
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
    }
    for (auto x: fac[m]) {
        for (int j = 2; j <= n; ++j) {
            if (a[j-1] % x > a[j] % x) { ++ans[x]; }
        }
    }

    while (q--) {
        int op; cin >> op;
        if (op == 1) {
            int p, y;
            cin >> p >> y;
            for (auto x: fac[m]) {
                if (p > 1 && a[p-1] % x > a[p] % x) { --ans[x]; }
                if (p < n && a[p] % x > a[p+1] % x) { --ans[x]; }
                if (p > 1 && a[p-1] % x > y % x) { ++ans[x]; }
                if (p < n && y % x > a[p+1] % x) { ++ans[x]; }
            }
            a[p] = y;
        } else {
            int x; cin >> x;
            x = gcd(x, m);
            cout << (ans[x]*x < m ? "YES": "NO") << "\n";
        }
    }

    for (auto x: fac[m]) { ans[x] = 0; }
}

int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 

    for (int i = 1; i <= X; ++i) {
        for (int j = i; j <= X; j += i) {
            fac[j].push_back(i);
        }
    }

	int t = 1;
	cin >> t;
	while (t--) { solve(); }
}
```
