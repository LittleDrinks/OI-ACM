---
tags:
  - 题解
  - 数论
aliases:
  - Modular Sorting
---
## [CF2123G. Modular Sorting](https://codeforces.com/problemset/problem/2123/G)

考虑在 $m$ 个点的圆环上不断跳跃，最后落到的点的位置是有限的。
模 $m$ 的加法群中，从某个数加 $x$ 形成的子群，其元素是 $d=\gcd(m,x)$ 的等差数列。因为每走 $1/\frac{x}{\gcd(x,m)}\pmod {\frac{m}{\gcd(x,m)}}$ 步，$a$ 会增大为 $a+\gcd(x,m)$。
不限制操作步数，肯定让序列头上的数字尽可能小。因此只有当 $a_{i-1}\mathrm{\ mod\ } x > a_i\mathrm{\ mod\ } x$ 时，才令后一项增大一步，即 $a_i:=a_i+\gcd(m,x)$。
对于一次询问 $x$，我们只关心所有数在模 $\gcd(x,m)$ 意义下的相对大小。一共有 $d(m)$ 种本质不同的询问，每次单点修改操作只会影响两项的相对大小。因此我们可以在 $O(d(m))$ 的时间内与处理出所有询问的答案，然后 $O(1)$ 回答。

[***AC 代码***](https://codeforces.com/contest/2123/submission/331856731)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

const int X=5e5;
vector<int> fac[X+5];
ll ans[X+5];

void solve()
{
	int n, m, q;
	cin >> n >> m >> q;
    vector<int> a(n+1);
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
    }
    for (auto x: fac[m]) {
        for (int j = 2; j <= n; ++j) {
            if (a[j-1] % x > a[j] % x) { ++ans[x]; }
        }
    }

    while (q--) {
        int op; cin >> op;
        if (op == 1) {
            int p, y;
            cin >> p >> y;
            for (auto x: fac[m]) {
                if (p > 1 && a[p-1] % x > a[p] % x) { --ans[x]; }
                if (p < n && a[p] % x > a[p+1] % x) { --ans[x]; }
                if (p > 1 && a[p-1] % x > y % x) { ++ans[x]; }
                if (p < n && y % x > a[p+1] % x) { ++ans[x]; }
            }
            a[p] = y;
        } else {
            int x; cin >> x;
            x = gcd(x, m);
            cout << (ans[x]*x < m ? "YES": "NO") << "\n";
        }
    }

    for (auto x: fac[m]) { ans[x] = 0; }
}

int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 

    for (int i = 1; i <= X; ++i) {
        for (int j = i; j <= X; j += i) {
            fac[j].push_back(i);
        }
    }

	int t = 1;
	cin >> t;
	while (t--) { solve(); }
}
```
