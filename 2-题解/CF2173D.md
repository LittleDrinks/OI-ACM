---
tags:
  - 题解
  - DP
aliases:
  - Taiga's Carry Chains
---
## [CF2173D. Taiga's Carry Chains](https://codeforces.com/contest/2173/problem/D)

由于 $n\ge1$，每次操作至少会产生一次进位，多的进位来自于最低 $30$ 位已有的 $1$。
当 $k\ge30$ 时，我们可以从低往高遍历每一个二进制位，遇到 $1$ 就加一，最后的答案为
$$
\mathrm{popcount}(n)+k-1
$$
否则，我们模仿加法器的工作方式，设 $f(i,j)$ 和 $g(i,j)$ 表示最低 $i$ 位花了 $j$ 次操作，有/无来自低位的进位，最多有多少次进位。
如果没有低位进位，也不操作，下一位会继承之前的答案。
$$
f(i,j)\overset{\max}{\to} f(i+1,j)
$$
当 $n$ 的第 $i$ 位是 $1$ 时，如果有进位就会向高位进位，否则，可以手动操作让它进位。
$$
\begin{align}
f(i,j) + 1\overset{\max}{\to} g(i+1,j+1)  \\
g(i,j) + 1\overset{\max}{\to} g(i+1,j)
\end{align}
$$
当 $n$ 的第 $i$ 位是 $0$ 时，如果有进位且手动加一才会向高位进位，否则不会进位。
$$
\begin{align}
g(i,j)\overset{\max}{\to} f(i+1,j)  \\
g(i,j) + 1\overset{\max}{\to} g(i+1,j+1)
\end{align}
$$
时间复杂度 $O(T\log^2(n))$

[***AC 代码***](https://codeforces.com/contest/2173/submission/352180961)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

template<typename T>
bool chmax(T &x, T y) {
    if (y > x) { x = y; return true; }
    return false;
}

const int I = 31;
const int inf = 1e9;

void solve()
{
    int n, k;
    cin >> n >> k;
    int dif = (1 << (__lg(n) + 1)) - n;
    if (popcount((unsigned)(dif)) <= k) {
        cout << popcount((unsigned)(n))+k-1 << "\n";
        return;
    }

    vector f(I + 1, vector<int>(k + 2, -inf)), g(f);
    fill(f[0].begin(), f[0].end(), 0);
    for (int i = 0; i < I; ++i) {
        for (int j = 0; j <= k; ++j) {
            chmax(f[i + 1][j], f[i][j]);
            if (n >> i & 1) {
                chmax(g[i + 1][j + 1], f[i][j] + 1);
                chmax(g[i + 1][j], g[i][j] + 1);
            } else {
                chmax(f[i + 1][j], g[i][j]);
                chmax(g[i + 1][j + 1], g[i][j] + 1);
            }
        }
    }
    cout << max(f[I][k], g[I][k]) << "\n";
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int t = 1;
    cin >> t;
    while (t--) { solve(); }
}
```
