---
tags:
  - 题解
  - 构造
aliases:
  - Middle Point
---
## [gym105632C. Middle Point](https://codeforces.com/gym/105632/problem/C)

通过 $k$ 步能构造出的点集为
$$
S_k = \left\{\dfrac{Ax}{2^k}, \dfrac{By}{2^k} \ \Bigg|\  0\le x,y< 2^k\right\}
$$
这个结论可以通过计算 $S_{k+1}=\dfrac{S_k+\{(iA,jB)\}}{2}$ 归纳证明。
记 $T_k=S_k\cap\lnot S_{k-1}$。如果目标点在集合 $T_k$ 中，则其至少需要 $k$ 步才能完成构造。
接下来考虑逼近下界的构造方式。
点集 $T_k$ 中一定存在一点 $(x,y)$，使得 $\dfrac{(x,y)+(iA,jB)}{2}\in T_{k+1}$。递归构造即可。

[***AC 代码***](https://codeforces.com/gym/105632/submission/336323696)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

set<pair<ll,ll>> S;
vector<array<ll, 4>> ans;
ll a, b, x, y;

void op(ll e, ll f, ll g, ll h)
{
    assert(S.count({e,f}));
    assert(S.count({g,h}));
    assert((e+g) % 2 == 0);
    assert((f+h) % 2 == 0);
    S.insert({(e+g)/2, (f+h)/2});
    ans.push_back( { e, f, g, h } );
}

bool solve(ll u, ll v, int dep)
{
    if (dep > 60) {
        return false;
    }
    if ((u == 0 || u == a) && (v == 0 || v == b)) {
        return true;
    }
    ll c = 0, d = 0;
    if ((u *= 2) > a) { c += a; u -= a; }
    if ((v *= 2) > b) { d += b; v -= b; }
    bool valid = solve(u, v, dep + 1);
    if (valid) {
        op(c, d, u, v);
    }
    return valid;
}

int main() {
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    cin >> a >> b >> x >> y;
    S.insert({0,0});
    S.insert({0,b});
    S.insert({a,0});
    S.insert({a,b});
    bool valid = solve(x, y, 0);
    if (!valid) {
        cout << "-1\n";
        return 0;
    }
    cout << ans.size() << "\n";
    for (int i = 0; i < int(ans.size()); ++i) {
        for (auto x : ans[i]) {
            cout << x << " ";
        }
        cout << "\n";
    }
}
```
