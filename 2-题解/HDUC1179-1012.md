---
tags:
  - 题解
aliases:
  - 最多变的序列
---
## [HDUC1179-1012. 最多变的序列](https://acm.hdu.edu.cn/contest/problem?cid=1179&pid=1012)

先考虑什么样的序列能成为答案。对 $[l,r]$ 操作后肯定是每一段区间 $[l,r]$ 都等于原来区间 $[l,r]$ 的最小值。
设 $f(i)$ 表示把 $a_1\sim a_i$ 填到区间 $[1,i]$ 的方案数。枚举 $a_i$ 最远能填到的区间 $[l,r]$，则
$$
f'(j)\leftarrow \sum_{i=1}^j f(i) , \ j\in[l,r])
$$

[***AC 代码***](https://acm.hdu.edu.cn/contest/view-code?cid=1179&rid=14146)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

const int MOD = 998244353;
ll add(ll x, ll y) { return (x + y) % MOD; }

void solve()
{
    int n;
    cin >> n;
    vector<int> a(n+1), f(n+1);
    for (int i = 1; i <= n; ++i) { cin >> a[i]; }
    f[0] = 1;
    for (int i = 1; i <= n; ++i) {
        int L = i, R = i;
        while (L > 1 && a[L - 1] > a[i]) { --L; }
        while (R < n && a[R + 1] > a[i]) { ++R; }
        ll sum = f[L - 1];
        for (int j = L; j <= R; ++j) {
            f[j] = sum = add(sum, f[j]);
        }
    }
    cout << f[n] << "\n";
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int t = 1;
    cin >> t;
    while (t--) { solve(); }
}

```
