---
tags:
  - 题解
  - 哈希
  - 倍增
aliases:
  - Array Similarity
---
## [QOJ10970. Array Similarity](https://qoj.ac/contest/2071/problem/10970)

设每个位置右边第一个不小于它的位置为 $f_i$，两个子序列实际上是在比较 $f_L-L,\ f_{f_L}-f_L,\ \ldots$
使用倍增计算哈希值比较即可。

[***AC 代码***](https://qoj.ac/submission/1661863)

```cpp
#include <bits/stdc++.h>
using ll = long long;
using hs = std::pair<ll,ll>;
hs p = { 117, 131 };
const ll MOD1 = 1e9+7, MOD2 = 1e9+9;
hs operator+ (const hs &u, const hs &v) { return hs{(u.first+v.first)%MOD1, (u.second+v.second)%MOD2}; }
hs operator* (const hs &u, const hs &v) { return hs{(u.first*v.first)%MOD1, (u.second*v.second)%MOD2}; }

const int N = 2e5 + 5, I = 20;
int n, q;
int a[N + 5], f[I + 5][N + 5];
hs g[I + 5][N + 5], hash[N + 5];

int main()
{
    std::ios::sync_with_stdio(0); std::cin.tie(0); std::cout.tie(0);
    std::cin >> n >> q;
    for (int i = 1; i <= n; ++i) {
        std::cin >> a[i];
    }

    for (int i = 1; i <= n + 1; ++i) {
        f[0][i] = n + 1;
    }

    std::vector<int> stk;
    for (int i = 1; i <= n; ++i) {
        while (!stk.empty() && a[stk.back()] <= a[i]) {
            f[0][stk.back()] = i;
            stk.pop_back();
        }
        stk.push_back(i);
    }

    for (int i = 1; i <= n + 1; ++i) {
        g[0][i] = {f[0][i] - i, f[0][i] - i};
    }

    hash[0] = p;
    for (int i = 1; i <= I; ++i) {
        hash[i] = hash[i-1] * hash[i-1];
        for (int j = 1; j <= n + 1; ++j) {
            f[i][j] = f[i-1][ f[i-1][j] ];
            if (f[i][j] == 0) { f[i][j] = n + 1; }
            g[i][j] = g[i-1][j] * hash[i-1] + g[i-1][ f[i-1][j] ];
        }
    }

    while (q--) {
        int L1, R1, L2, R2;
        std::cin >> L1 >> R1 >> L2 >> R2;
        int u = L1, v = L2;
        hs a, b;
        for (int i = I; i >= 0; --i) {
            if (f[i][u] <= R1) {
                a = a * hash[i] + g[i][u];
                u = f[i][u];
            }
            if (f[i][v] <= R2) {
                b = b * hash[i] + g[i][v];
                v = f[i][v];
            }
        }

        std::cout << (a == b ? "Yes": "No") << "\n"; 
    }
}
```
