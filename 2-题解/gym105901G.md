---
tags:
  - 题解
  - 根号分治
  - DP
  - 容斥原理
aliases:
  - Path Summing Problem
---
## [gym105901G. Path Summing Problem](https://codeforces.com/gym/105901/problem/G)

前置题 [[CF559C]]
每个数字的贡献是：至少包含一次这个数字的路径数量。
考虑容斥，求出路径上不包含这个数字的方案数。这个问题有两种做法。

> [!note] 做法一
> 设 $dp(i,j)$ 表示走到 $(i,j)$ 的方案数，则有
> $$
> dp(i,j)=\begin{cases} 
> 0 & a_{i,j}=x \\
> dp(i-1,j)+dp(i,j-1) & else
> \end{cases}
> $$
> 时间复杂度 $O(nm)$
> 

> [!note] 做法二
> 同 [[CF559C]]
> 对于每一个 $a_{i,j}=x$ 的位置，设 $f(i,j)$ 表示以 $(i,j)$ 为路径终点，并且只有 $a_{i,j}$ 这一个 $x$ 的方案数。
> 转移时考虑容斥，总方案数是 $i+j-2\choose i-1$，钦定路径上的第一个 $x$ 所在的位置 $(a,b)$ 减去，则有
> $$
> f(i,j)={i+j-2\choose i-1}-\sum_{a\le i,b\le j} f(a,b)\times{i-a+j-b\choose i-a}
> $$
> 时间复杂度 $O(k^2)$，其中 $k$ 为 $x$ 出现的次数。

考虑根号分治，当 $x$ 出现次数大于 $\sqrt{nm}$ 时使用做法一，否则使用做法二，时间复杂度 $O(nm\sqrt{nm})$。

[***AC 代码***](https://codeforces.com/gym/105901/submission/341212929)

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 5;
const int MOD = 998244353;
int add(int x, int y) {
    return (x + y) % MOD;
}
int del(int x, int y) {
    return add(x, MOD - y);
}
int mul(int x, int y) {
    return 1LL * x * y % MOD;
}
int qpow(int a, int b = MOD - 2) {
    int res = 1;
    for (; b; b >>= 1, a = mul(a, a)) {
        if (b & 1) {
            res = mul(res, a);
        }
    }
    return res;
}
int fac[N + 5], Inv[N + 5];
int C(int n, int k) {
    return k > n ? 0 : mul(fac[n], mul(Inv[k], Inv[n - k]));
}

void solve() {
    int n, m;
    cin >> n >> m;
    vector a(n, vector<int>(m));
    vector pos(n * m + 1, vector<pair<int, int>>());
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            cin >> a[i][j];
            pos[a[i][j]].emplace_back(i, j);
        }
    }
    auto work1 = [&](int col) {
        vector dp(n, vector<int>(m));
        dp[0][0] = (a[0][0] != col);
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (a[i][j] == col) {
                    continue;
                }
                if (i - 1 >= 0) {
                    dp[i][j] = add(dp[i][j], dp[i - 1][j]);
                }
                if (j - 1 >= 0) {
                    dp[i][j] = add(dp[i][j], dp[i][j - 1]);
                }
            }
        }
        int res = C(n+m-2, n-1);
        res = del(res, dp[n-1][m-1]);
        return res;
    };
    auto work2 = [&](int col) {
        int res = C(n+m-2, n-1);
        if (a[n-1][m-1] == col) {
            return res;
        }
        pos[col].emplace_back(n-1, m-1);
        int cnt = pos[col].size();
        vector<int> dp(cnt);
        for (int i = 0; i < cnt; ++i) {
            auto [x, y] = pos[col][i];
            dp[i] = C(x+y, x);
            for (int j = 0; j < i; ++j) {
                auto [a, b] = pos[col][j];
                if (a <= x && b <= y) {
                    dp[i] = del(dp[i], mul(dp[j], C(x-a+y-b, x-a)));
                }
            }
        }
        res = del(res, dp.back());
        return res;
    };
    int siz = sqrt(n * m) + 1; 
    int ans = 0;
    for (int col = 1; col <= n * m; ++col) {
        if (int(pos[col].size()) <= siz) {
            ans = add(ans, work2(col));
        } else {
            ans = add(ans, work1(col));
        }
    }
    cout << ans << "\n";
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    fac[0] = Inv[0] = 1;
    for (int i = 1; i <= N; ++i) {
        fac[i] = mul(fac[i - 1], i);
    }
    Inv[N] = qpow(fac[N]);
    for (int i = N - 1; i; --i) {
        Inv[i] = mul(Inv[i + 1], i + 1);
    }
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
```
