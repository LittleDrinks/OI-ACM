---
tags:
  - 题解
  - DP/数位DP
aliases:
  - windy 数（加强版）
---
## [P13085 [SCOI2009] windy 数（加强版）](https://www.luogu.com.cn/problem/P13085)

下文钦定 $0$ 是 windy 数。
如果原来的数字 $x$ 有 $len$ 位，不妨设第 $len+1$ 位填了一个前导零。设 $f(p,last)$ 表示填了 $[p,len+1]$，并且 $p+1$ 位填的是 $last$ 的答案数量。
在记忆化搜索中额外维护两个状态 $limit$ 和 $lead0$ 表示这一位是否受到上界限制，以及第 $p$ 位是否为前导零，如果这一位是前导零，接下来的填数没有限制，否则需要下一位 $i$ 满足 $|i-last|\ge 2$。$f$ 中只记录第 $p$ 位不受上界限制且不是前导零时的答案。

[***AC 代码***](https://www.luogu.com.cn/record/226196174)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

const int L=18;
int a[L+5];
ll f[L+5][15];
ll dfs(int p, bool limit, bool lead0, int last)
{
	if (!p) { return 1; }
	auto& now = f[p][last];
	if (!limit && !lead0 && ~now) {
		return now;
	}
	int up = limit ? a[p] : 9;
	ll res = 0;
	for (int i = 0; i <= up; ++i) {
		if (!lead0 && abs(last-i) < 2) { continue; }
		res += dfs(p-1, limit&&(i==up), lead0&&(i==0), i);
	}
	if (!limit && !lead0) {
		now = res;
	}
	return res;
}
ll query(ll x)
{
	int len = 0;
	for (; x; x /= 10) {
		a[++len] = x % 10;
	}
	return dfs(len, true, true, 0);
}

void solve()
{
	ll a, b;
	cin >> a >> b;
	cout << query(b) - query(a-1) << "\n";
}

int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
	memset(f, -1, sizeof(f));
	int t = 1;
	// cin >> t;
	while (t--) { solve(); }
}
```
