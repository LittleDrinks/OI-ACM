---
tags:
  - 题解
  - 数学
  - 容斥原理
aliases:
  - "810975"
---
## [gym103428M. 810975](https://codeforces.com/gym/103428/problem/M)

$n-m$ 个 $\texttt{0}$ 隔出 $n-m+1$ 个空位，每个空位可以放 $[0,k]$ 个 $\texttt{1}$，并且需要有至少一个空位恰好放 $k$ 个。
如果不限制每个空位放多少，是经典的隔板法，答案为
$$
m+n-m\choose n-m
$$
加上限制条件，考虑容斥。记 $f(k)$ 表示每个空位 $1$ 个数最大不超过 $k$ 的方案数，答案为 $f(k)-f(k-1)$
接下来考虑 $f(k)$ 如何求出。继续容斥。
记 $g_k(i)$ 表示至少有 $i$ 个位置大于 $k$ 的方案数。相当于从 $m$ 个位置中选出 $k$ 个先放上 $k+1$，然后再继续隔板法，即
$$
g_k(i)={m-i\times(k+1)+n-m\choose n-m}
$$
利用 $g_k(i)$ 容斥求出 $f(k)$，表达式为
$$
f(k) = \sum_{i\ge0,\ \ i\times(k+1)\le m,\ \ i\le n-m+1} g_k(i)
$$

[***AC 代码***](https://codeforces.com/gym/103428/submission/337212003)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

const int MOD = 998244353;
ll add(ll x, ll y) {
    return (x + y) % MOD;
}
ll del(ll x, ll y) {
    return add(x, MOD - y);
}
ll mul(ll x, ll y) {
    return (x * y) % MOD;
}
ll qpow(ll a, ll b = MOD - 2) {
    ll res = 1;
    for (; b; b >>= 1, a = mul(a, a)) {
        if (b & 1) {
            res = mul(res, a);
        }
    }
    return res;
}

const int N = 1e5;
ll fac[N + 5], Inv[N + 5];

ll C(ll n, ll k) {
    return n >= k ? mul(fac[n], mul(Inv[k], Inv[n - k])) : 0;
}

int n, m, k;
ll f(ll k) {
    ll ans = 0;
    for (ll i = 0; i * (k + 1) <= m && i <= n - m + 1; ++i) {
        ll t = mul(C(m - i * (k + 1) + n - m, n - m), C(n - m + 1, i));
        if (i & 1) {
            t = del(0, t);
        }
        ans = add(ans, t);
    }
    return ans;
}

void solve() {
    cin >> n >> m >> k;
    cout << del(f(k), f(k - 1)) << "\n";
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    fac[0] = 1;
    Inv[0] = 1;
    for (int i = 1; i <= N; ++i) {
        fac[i] = mul(fac[i - 1], i);
        Inv[i] = qpow(fac[i]);
    }

    int t = 1;
    // cin >> t;
    while (t--) {
        solve();
    }
}
```
