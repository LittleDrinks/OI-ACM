---
tags:
  - 题解
aliases:
  - Loopy Laggon
---
## [NCC108304A. Loopy Laggon](https://ac.nowcoder.com/acm/contest/108304/A)

一次置换操作可以分解为若干次的交换操作。对一个排列，一次交换操作一定会改变逆序数的奇偶性。
$$
\begin{pmatrix}
\color{red}1 & \color{orange}2 & \color{blue}3 & \color{red}4 \\
\color{blue}5 & \color{green}6 & \color{green}7 & \color{orange}8 \\
\color{orange}9 & \color{green}10 & \color{green}11 & \color{blue}12 \\
\color{red}13 & \color{blue}14 & \color{orange}15 & \color{red}16
\end{pmatrix}
$$
将一次旋转操作看作上面这个矩阵中颜色相同位置之间的轮换，而一次四个位置的轮换可以看作三次对换。因此完成一次上面的置换等价于 $12$ 次对换，逆序数奇偶性不变。进行 $10^6$ 次操作后，将矩阵展开后的逆序数仍然是偶数。
因此，在一组 $k$ 个玩具中至少存在一个逆序数为奇数时，可以判断这套玩具一定被 Bob 破坏了。
奇排列和偶排列的个数是相同的，因此随机插入数字形成偶排列的概率为 $\dfrac{1}{2}$，可以用以下的代码验证。
```python
n = 100
f = [[0.0, 0.0] for _ in range(n+1)]
f[0][0] = 1.0
f[0][1] = 0.0
for i in range(1, n+1):
    p = n//2  # 偶数个逆序对
    q = n-p   # 奇数个逆序对
    f[i][0] = f[i-1][0] * p / n + f[i-1][1] * q / n
    f[i][1] = f[i-1][1] * p / n + f[i-1][0] * q / n

print(f[n][0])
```
一组被破坏的玩具逆序数全为偶数的概率为 $2^{-10}$，因此被破坏的玩具没有被找出的概率是 $2^{-10}$，足以通过本题。

[***AC 代码***](https://ac.nowcoder.com/acm/contest/view-submission?submissionId=78704187)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

struct BIT {
    int n;
    vector<int> t;
    BIT(int n): n(n), t(n+1) { }
    int lowbit(int x) { return x & -x; }
    void modify(int x, int d) {
        for (; x <= n; x += lowbit(x)) { t[x] += d; }
    }
    int query(int x) {
        int res = 0;
        for (; x; x -= lowbit(x)) { res += t[x]; }
        return res;
    }
};

void solve()
{
    int id, m, k, n;
    cin >> id >> m >> k >> n;
    for (int i = 1; i <= m; ++i) {
        bool valid = true;
        for (int j = 1; j <= k; ++j) {
            BIT t(n*n);
            vector<int> p;
            for (int x = 1; x <= n; ++x) {
                for (int y = 1; y <= n; ++y) {
                    int val; cin >> val;
                    p.push_back(val);
                }
            }
            int res = 0;
            for (auto x: p) {
                res += t.query(n*n)-t.query(x);
                t.modify(x, 1);
            }
            valid &= (res % 2 == 0);
        }
        cout << (valid ? "0" : "1");
    }
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int t = 1;
    // cin >> t;
    while (t--) { solve(); }
}

```
