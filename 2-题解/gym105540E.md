---
tags:
  - 题解
  - 分类讨论
aliases:
  - The Chariot
---
## [gym105540E. The Chariot](https://codeforces.com/gym/105540/problem/E)

用 $\texttt{*}$ 表示一直重复直到收费将要溢出。
一旦付了 $k$ 笔起步费，肯定是走满 $kA$ 米最优。记 $f(k)$ 表示只付 $k$ 笔起步费的前提下，走完 $D$ 米最少需要花多少钱，可以用以下流程计算：
①花 $kA$ 走 $kX$ 米
②如果还能走，接下来只能先走一段 $B$
③如果还能走，并且 $B<C$，则应该继续走 $(k-1)Y$，否则跳过该步
④剩下路程 $d$ 只能花 $dC$ 走完
感性理解。当 $D>>X,Y$ 时先把“大段路程”走完，“大段路程”只有 $\texttt{A*|(AB*)|ABC}$ 三种走法。而当“打断路程”走完后，即 $D\sim X,Y$ 时，$k$ 的有效取值范围非常有限。因此直接在 $\dfrac{D}{X}$、$\dfrac{D}{X+Y}$、$1$ 的邻域内枚举即可。
高精度，使用 Python 实现会简单很多。

[***AC 代码***](https://codeforces.com/gym/105540/submission/335704126)

```python
def f(k):
    # 先计算必须走的 k*X
    res = k * A
    d = D - k * X
    if d <= 0:
        return res
    
    # 必须走一段 Y
    if d <= Y:
        return res + d * B
    res += Y*B
    d -= Y

    # 全用 B 最优，用到不能用为止
    if B < C:
        res += min(d, (k-1)*Y) * B
        d -= min(d, (k-1)*Y)
    
    # 剩下全用 C 最优
    return res + d * C

r = 2
def calc(k):
    return min( [f(i) for i in range(max(L, k-r), min(R, k+r)+1)] ) 

T = int(input())
for _ in range(T):
    A, B, C, X, Y, D = map(int,input().split())
    L = 1
    R = (D+X-1) // X
    ans = min( calc(1), calc(D // X), calc(D // (X+Y)) )
    print(ans)
```
