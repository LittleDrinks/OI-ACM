---
tags:
  - 题解
  - DP
  - 数学
aliases:
  - gym104787F
---
## [gym104787F. Mystery of Prime](https://codeforces.com/gym/104787/problem/F)

除了 $2$ 以外所有的素数都是奇数，因为序列都是正整数，所以 $2$ 只能由 $1+1$ 凑出，其他情况下相邻的两个数必须奇偶性不同。
考虑三个数的情况。可以通过打表验证：对于任意奇偶性相同的 $x,y$，均存在 $z$ 使得 $(x+z,y+z)$ 都是素数。
推广到四个数的情况，对于 $x,y,z,p$，想让 $z+p\in\mathbb{P}$，存在若干种情况。

- $p=1$，$z=1$
- $p=1$，$z$ 是偶数，$y=1$
- $p=1$，$z$ 是偶数，$y$ 是大于 $1$ 的奇数
- $p$ 是偶数，$z$ 是奇数
- $p$ 是大于 $1$ 的奇数，$z$ 是偶数

根据之前的结论，上述每种情况都可以完成调整。
推广到若干个数字，之前的思考这启发我们将最后一个数的若干种情况压入状态。用 $f_{0/1/2/3}(i)$ 表示将前 $i$ 个数字修改合法，并且最后一个数字“没修改/改成 1/改成偶数/改成非 $1$ 奇素数”的最小花费。
$$
f_0(i)=\min 
\begin{cases}
f_0(i-1) & a_i+a_{i-1}\in\mathbb{P} \\
f_1(i-1) & a_i + 1\in\mathbb{P} \\
f_2(i-1) & a_i\bmod2 = 1 \\
f_3(i-1) & a_i\bmod2 = 0
\end{cases}
$$
$$
f_1(i)=[a_i\ne 1] + \min
\begin{cases}
f_0(i-1) & a_{i-1} + 1\in\mathbb{P} \\
f_1(i-1) & all\\
f_2(i-1) & all
\end{cases}
$$
$$
f_2(i) = 1 + \min
\begin{cases}
f_0(i-1) & a_{i-1}\bmod 2 = 1 \\
f_1(i-1) & all\\
f_3(i-1) & all
\end{cases}
$$
$$
f_3(i) = 1  +\min
\begin{cases}
f_0(i-1) & a_{i-1} \bmod 2 = 0 \\
f_2(i-1) & all
\end{cases}
$$

[***AC 代码***]()

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5, A = 2e5;
const int inf = 0x3f3f3f3f;
int n, a[N + 5], f[N + 5][4];
bool vis[A + 5];

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> n;
    for (int i = 2; i <= A; ++i) {
        if (vis[i]) {
            continue;
        }
        for (int j = 2 * i; j <= A; j += i) {
            vis[j] = 1;
        }
    }
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        f[i][1] = (a[i] != 1);
        f[i][2] = f[i][3] = 1;
        if (i > 1) {
            int x = a[i], y = a[i - 1];
            f[i][0] += min({!vis[x + y] ? f[i - 1][0] : inf,
                            !vis[x + 1] ? f[i - 1][1] : inf,
                            f[i - 1][((x & 1) ^ 1) + 2]});
            f[i][1] += min(
                {!vis[y + 1] ? f[i - 1][0] : inf, f[i - 1][1], f[i - 1][2]});
            f[i][2] += min({y & 1 ? f[i - 1][0] : inf, f[i - 1][1], f[i - 1][3]});
            f[i][3] += min({y & 1 ? inf : f[i - 1][0], f[i - 1][2]});
        }
    }
    cout << *min_element(f[n], f[n] + 4) << "\n";
}
```
