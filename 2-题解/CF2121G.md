---
tags:
  - 题解
aliases:
  - Gangsta
---
## [CF2121G. Gangsta](https://codeforces.com/problemset/problem/2121/G)

看作 $(0,0)$ 到 $(c_0,c_1)$ 的切比雪夫距离，转为曼哈顿距离
$$
\max(c_0,c_1)= \dfrac{c_0+c_1}{2}+\left| \dfrac{c_0-c_1}{2}\right|
$$
先考虑所有子区间的 $c_0+c_1$ 怎么做。长度为 $len$ 的区间，$c_0+c_1=len$，因此有
$$
\sum_{l=1}^n\sum_{r=l}^{m} \bigg(c_0+c_1\bigg)=\sum_{l=1}^n\sum_{r=l}^{m}\bigg(r-l+1\bigg)=\sum_{len=1}^{n}len\times(n-len+1)
$$
然后考虑 $|c_0-c_1|$，把 $\texttt{0}$ 看作 $-1$，把 $\texttt{1}$ 看作 $+1$，求前缀和 $s$，则 $|c_0-c_1|=|s_r-s_{l-1}|$
$$
\sum_{l=1}^n\sum_{r=l}^{m} \bigg|c_0-c_1\bigg|=\sum_{l=1}^n\sum_{r=l}^{m} \bigg|s_r-s_{l-1}\bigg|
$$
观察到求和式中 $s_0\sim s_n$ 中每一项都会与剩余 $n$ 项组合，把绝对值拆了，根据 $s_i$ 的相对大小确定 $\pm s_i$ 在求和式中分别出现了几次即可快速计算。
时间复杂度 $O(n\log n)$

[***AC 代码***](https://codeforces.com/contest/2121/submission/332060421)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

void solve()
{
	int n;
    string s;
	cin >> n >> s;
    vector<ll> a(n+1);
    for (int i = 1; i <= n; ++i) {
        a[i] = (s[i-1]=='1' ? 1 : -1);
    }
    partial_sum(a.begin(), a.end(), a.begin());
    ll ans = 0;
    for (int len = 1; len <= n; ++len) {
        ans += 1LL * len * (n-len+1);
    }
    sort(a.begin(), a.end());
    for (int i = 0; i <= n; ++i) {
        ans += i * a[i];
        ans -= (n-i) * a[i];
    }
    cout << ans / 2 << "\n";
}

int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
	int t = 1;
	cin >> t;
	while (t--) { solve(); }
}
```
