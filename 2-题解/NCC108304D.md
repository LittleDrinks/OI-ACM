---
tags:
  - 题解
  - DP
  - 最短路/传递闭包
aliases:
  - Lost Woods
---
## [NCC108304D. Lost Woods](https://ac.nowcoder.com/acm/contest/108304/D)

方差一个经典的转化，详见 [[P10389]]，化简后的结果为
$$
k^2\sigma^2 = k\sum_{i=1}^k(v_i^2)-(\sum_{i=1}^k(v_i))^2
$$
我们只关心三个量：经过的路径数、路径权值和、路径权值平方和。
本题数据范围很小，考虑高维 DP，把路径数、权值和都压入状态。
先考虑 DAG 的做法。记 $f(x,y,s,w)$ 表示起点为 $x$，终点为 $y$，路径数为 $s$，权值和为 $w$ 时，路径权值平方和的最小值。因为是 DAG，路径数 $s$ 不会超过 $n$，总状态数 $O(n^3mW)$。参考 Bellman-Ford 的方式，枚举路径数 $s$ 进行转移即可，最终答案为 $\min_{s,w}\{f(1,n,s,w)\}$。
考虑环的情况。只在环上绕若干圈方差不会改变。当一个环可以同时到达 $1,n$ 两个点时，如果这个环的方差大于直接从 $1$ 走到 $n$，那肯定不会走这个环，反之我们就可以在环上一直绕圈逼近这个方差，并最终将这个值计入答案。因此我们需要用传递闭包维护 $1\to i$ 和 $i\to n$ 的可达性，并获取图上所有环的方差。因为环的长度也不会超过 $n$，后面一步可以化归为上面的那个 DP 转移方法。最终答案为 $\min_{s,w}\{f(i,i,s,w)\}$

---

总结一下，做这题需要有的几个认知。
①进度误差小到了 $10^{-9}$，基本不可能乱搞通过。
②环是不方便直接枚举的。当我们需要求出环上某个参数的最小值时，应该考虑 DP（Bellman-Ford）。

[***AC 代码***]()

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

constexpr int inf = 1e9;

void solve()
{
    int n, m;
    cin >> n >> m;
    vector<tuple<int,int,int>> e(m);
    vector<bitset<31>> r(n+1);
    for (auto& [u, v, w]: e) {
        cin >> u >> v >> w;
        r[u][v] = 1;
    }
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (r[j][i]) { r[j] |= r[i]; }
        }
    }

    db ans = 1e18;
    vector f(n+1, vector(n+1, vector<ll>(n*20+1, inf)));
    for (int i = 1; i <= n; ++i) { f[i][i][0] = 0; }
    for (int step = 1; step <= n; ++step) {
        vector nf(n+1, vector(n+1, vector<ll>(n*20+1, inf)));
        for (int i = 1; i <= n; ++i) {
            for (auto& [u, v, w]: e) {
                for (int j = 0; j <= (step-1)*20; ++j) {
                    nf[i][v][j+w] = min(nf[i][v][j+w], f[i][u][j]+w*w);
                }
            }
        }
        f = move(nf);
        for (int j = 0; j <= step*20; ++j) {
            if (f[1][n][j] != inf) {
                ans = min(ans, (db)(f[1][n][j]*step-j*j)/(step*step));
            }
        }
        for (int i = 1; i <= n; ++i) {
            for (int j = 0; j <= step*20; ++j) {
                if (r[1][i] && r[i][n] && f[i][i][j] != inf) {
                    ans = min(ans, (db)(f[i][i][j]*step-j*j)/(step*step));
                }
            }
        }
    }
    if (ans == 1e18) {
        cout << "-1\n";
    } else {
        cout << fixed << setprecision(15) << ans << "\n";
    }
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int t = 1;
    // cin >> t;
    while (t--) { solve(); }
}
```
