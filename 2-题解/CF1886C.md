---
tags:
  - 题解
  - 栈/单调栈
---
## [CF1886C Decreasing String](https://www.luogu.com.cn/problem/CF1886C)

前置题：[[P1106]]

### 如何从 $s_{i-1}$ 得到 $s_i$

记 $s[i]$ 表示字符串 $s$ 中的第 $i$ 个字符（下标从 1 开始），与题目中的 $s_i$ 区分。

我们先观察：当 $s[i]$ 被删去时，后方所有的字符都将向前移动一个位置，其字典序的变化情况如下：

- 当 $s[i]$ 不是字符串 $s$ 中最后一个字符时：
	- 如果 $s[i]>s[i+1]$，那么删去 $s[i]$，字符串 $s$ 的字典序**必然减小，并且 $i$ 越小，减小得越多**；
	- 如果 $s[i]=s[i+1]$，字典序的变化取决于后方的字符（**对于相等的情况，需要看后方的字符，所以在当前这个位置可以直接不用管**）；
	- 如果 $s[i]<s[i+1]$，那么在字符串 $s$ 的字典序**必然增大**；
- 当 $s[i]$ 是字符串 $s$ 中的最后一个字符时，删去它，字符串 $s$ 的字典序**必然减小，但应该是上一种情况中减少得多**。

比如对于 `daacb`，从左向右遍历：

- 由于 `'d'>'a'`，所以删去 `'d'` 必然会使字典序变小；
- 由于 `'a'='a'`、又因为第二个 `'a'<'c'`，所以删去第一个 `'a'`，得到的 `'dacb'` 字典序会变大；
- 由于 `'a'<'c'`，所以删去第二个 `'a'` 会使字典序变大。此外，删去第二个 `'a'` 和删去第一个 `'a'` 得到的结果一样；
- 删去末尾字符 `'b'` 会使字典序变小，但不如删去 `'d'` 来得小。

又因为想要得到字典序最小的 $s_i$，需要从 $s_{i-1}$ 中删去一个字符，使得字典序减小得最多。所以可以得到从 $s_{i-1}$ 构造 $s_i$ 的方法：**扫描 $s_{i-1}$，找到最小的 $k<s.length()$，满足 $s[k]>s[k+1]$，把 $s[k]$ 删去。如果没有，那么删去末尾字符。**

### 实现方式

注意每次删去后字符串都会变化，【每找到一个 $k$ 就从头扫描】的朴素实现时间复杂度是 $O(n^2)$。

假设此时扫描到 $s[i]$，所有可以删去的 $j\ (j<i)$，都满足：

- $s[j]$ 尚未被删去；
- $s[j]>s[i]$。

满足这种条件，我们可以用**单调栈**进行维护。

具体而言，设当前的字符串长度为 $n$，此时仍然需要向后延伸的位置为 $p$。从左向右枚举 $s[i]$：

- 如果栈中为空，或者 $s[i]$ 大于等于栈顶元素，那么直接入栈；
- 如果 $s[i]$ 比栈顶元素小，那么不断出栈，每出栈一次，相当于进行一次上文所说的【删除 $s[k]$ 的操作】，$p\leftarrow p-n,\ n\leftarrow n-1$。如果某次出栈后 $p<n$，那么就找到了题目中所求的 $pos$ 所在的字符串，输出答案即可。

不要忘记在枚举完后将栈中所有元素取出，即上文所说的【找不到满足条件的 $k$，删除末尾字符】。

为了方便最后一步取出，实现时可以用 `vector` 模拟 `stack`。

[AC 代码提交记录](https://www.luogu.com.cn/record/129302311)

```cpp
#include <bits/stdc++.h>

using namespace std;

int t;
long long p, n;
string s;

int main()
{
	cin >> t;
	while (t--) {
		cin >> s >> p;
		n = s.length();
		s = " " + s + " ";
		vector <char> stk;
		bool done = (p<=n);
		for (int i = 1; i <= s.length()+1; ++i) {
			while ( (!done) && (!stk.empty()) && (stk.back() > s[i]) ) {
				stk.pop_back();
				p -= (n--);
				done = (p<=n);
			}
			stk.push_back(s[i]);
		}
		cout << stk[p-1];
	}
	return 0;
}
```
