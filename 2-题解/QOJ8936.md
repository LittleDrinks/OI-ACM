---
tags:
  - 题解
  - 拆分数
  - 贪心
aliases:
  - Team Arrangement
---
## [QOJ8936. Team Arrangement](https://qoj.ac/contest/1780/problem/8936)

假设已经知道每组有多少人，如何判定可行性。
按人数从小到大考虑每个组，应该选择 $L\le cnt$ 的人中 $r$ 最小的那些人。
枚举每组有多少人的部分是拆分数板子，记 $n$ 的拆分数为 $P(n)$，时间复杂度 $O(nP(n))$

[***AC 代码***](https://qoj.ac/submission/1279199)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 60;
const ll inf = numeric_limits<ll>::max();
int n, id[N + 5], L[N + 5], R[N + 5], cnt[N + 5];
ll w[N + 5], ans = -inf;

void calc(int siz) {
    priority_queue<int,vector<int>,greater<>> q;
    ll res = 0;
    for (int i = 1, j = 1; i <= siz; ++i) {
        while (j <= n && L[id[j]] <= cnt[i]) {
            q.push(R[id[j++]]);
        }
        while (!q.empty() && q.top() < cnt[i]) {
            q.pop();
        }
        if (q.size() < cnt[i]) {
            return;
        }
        res += w[cnt[i]];
        for (int k = 1; k <= cnt[i]; ++k) {
            q.pop();
        }
    }
    ans = max(ans, res);
}

void dfs(int u, int n) {
    if (n <= 0) {
        if (n == 0) {
            calc(u - 1);
        }
        return;
    }
    for (cnt[u] = cnt[u - 1]; cnt[u] <= n; ++cnt[u]) {
        dfs(u + 1, n - cnt[u]);
    }
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> L[i] >> R[i];
    }
    for (int i = 1; i <= n; ++i) {
        cin >> w[i];
    }
    iota(id + 1, id + n + 1, 1);
    sort(id + 1, id + n + 1, [&](int x, int y) {
        return L[x] < L[y] || (L[x] == L[y] && R[x] < R[y]);
    });
    cnt[0] = 1;
    dfs(1, n);
    if (ans == -inf) {
        cout << "impossible\n";
    } else {
        cout << ans << "\n";
    }
}
```
