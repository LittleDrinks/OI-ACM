---
tags:
  - 题解
  - 概率与期望
  - DP
aliases:
  - Ilya and Escalator
---
## [CF518D. Ilya and Escalator](https://codeforces.com/problemset/problem/518/D)

期望最基本的算法是 $\mathbb{E}=\sum_{j=1}^{n} p(j)\times j$
如果试图用组合数学推导“$t$ 秒后恰好有 $k$ 个人的期望”，公式会相当复杂。
从 $n,t\le 2000$ 切入，考虑 DP 求概率。
设 $dp(i,j)$ 表示 $i$ 时刻有 $j$ 个人的概率，我们使用刷表法进行 DP，有状态转移方程
$$
\begin{align}
&dp(i,j) \times (1-p)\to dp(i+1,j) \\
&dp(i,j)\times p\to dp(i + 1, j + 1)
\end{align}
$$
时间复杂度 $O(nt)$

[***AC 代码***](https://codeforces.com/contest/518/submission/351413511)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

void solve()
{
    int n, t;
    db p;
    cin >> n >> p >> t;
    vector dp(t + 1, vector<db>(n + 1));
    dp[0][0] = 1;
    for (int i = 0; i < t; ++i) {
        for (int j = 0; j <= n; ++j) {
            if (j == n) {
                dp[i + 1][j] += dp[i][j];
            } else {
                dp[i + 1][j] += dp[i][j] * (1 - p);
                dp[i + 1][j + 1] += dp[i][j] * p;
            }
        }
    }
    db ans = 0;
    for (int j = 1; j <= n; ++j) {
        ans += dp[t][j] * j;
    }
    cout << fixed << setprecision(10) << ans << "\n";
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int t = 1;
    // cin >> t;
    while (t--) { solve(); }
}
```
