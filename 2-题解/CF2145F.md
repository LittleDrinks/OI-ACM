---
tags:
  - 题解
  - DP
aliases:
  - Long Journey
---
## [CF2145F. Long Journey](https://codeforces.com/contest/2145/problem/F)

一共只有 $n$ 种有用的时刻，一共只有 $\mathrm{lcm}\{a\}\le 2520$ 种有用的位置。
考虑 DP，设 $dp(i,x,y)$ 表示进行 $i$ 次操作，当前是第 $x$ 轮操作，当前的位置是 $y$，这 $i$ 次操作中最多有多少次可以向前。
考虑到 $i\le m$ 比较大，使用二进制优化，将 DP 的状态改为进行 $2^i$ 次操作，则有状态转移方程
$$
dp(i,x,y)=dp(i-1,x,y) + dp\bigg(i-1,(x+2^{i-1})\bmod n, (y+dp(i-1,x,y))\bmod 2520\bigg)
$$
最后从大往小倍增地往前走即可。
时间复杂度 $O(\log m\cdot n\cdot \mathrm{{lcm}}\{a\})$

[***AC 代码***](https://codeforces.com/contest/2145/submission/345201466)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

const int I = 50;
const int N = 10;
const int L = 2520;
int n, a[N + 5], b[N + 5];
ll m;
ll dp[I + 5][N + 5][L + 5];

void solve()
{
    cin >> n >> m;
    for (int i = 0; i < n; ++i) { cin >> a[i]; }
    for (int i = 0; i < n; ++i) { cin >> b[i]; }
    for (int x = 0; x < n; ++x) {
        for (int y = 0; y < L; ++y) {
            assert(a[x] != 0);
            dp[0][x][y] = ((y + 1) % a[x] != b[x]);
        }
    }
    for (int i = 1; i <= I; ++i) {
        for (int x = 0; x < n; ++x) {
            for (int y = 0; y < L; ++y) {
                dp[i][x][y] = dp[i-1][x][y] + dp[i-1][(x+(1LL<<(i-1))) % n][(y + dp[i-1][x][y]) % L];
            }
        }
    }
    if (dp[I][0][0] < m) {
        cout << "-1\n";
        return;
    }
    ll now = 0, ans = 0;
    for (int i = I; i >= 0; --i) {
        auto st = dp[i][ans % n][now % L];
        if (now + st < m) {
            now += st;
            ans += (1LL << i);
        }
    }
    cout << ans + 1 << "\n";
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int t = 1;
    cin >> t;
    while (t--) { solve(); }
}
```
