---
tags:
  - 题解
  - 概率与期望
aliases:
  - A. Little Pony and Expected Maximum
---
## [CF453A. Little Pony and Expected Maximum](https://codeforces.com/problemset/problem/453/A)

最大值 $X$ 的定义是：所有数都不超过 $X$，并且至少有一个数等于 $X$。
第二个条件不好维护，我们使用第一个条件容斥，设 $f(j)$ 表示所有数不超过 $j$ 的概率，则
$$
f(j)=\left(\dfrac{j}{m}\right)^n
$$
思路一：最大值恰好为 $j$ 的概率为 $f(j)-f(j-1)$，根据期望定义计算 $\sum j\times f(j)$ 即可。
思路二：把 $j$ 看作 $\underbrace{1+1+\dots+1}_{j\text{个}1}$，最大值有 $1-f(j-1)$ 的概率大于等于 $j$，这些情况相对于 $j-1$ 要加一，于是答案等于
$$
\sum_{j=1}^{m} \bigg(1-f(j-1)\bigg)^n
$$

[***AC 代码***](https://codeforces.com/contest/453/submission/351424085)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

db qpow(db a, int b) {
    db res = 1;
    for (; b; b >>= 1, a = a * a) {
        if (b & 1) { res = res * a; }
    }
    return res;
}

void solve()
{
    int m, n;
    cin >> m >> n;
    vector<db> p(m + 1, 1);
    p[0] = 0;
    for (int j = 1; j <= m; ++j) {
        p[j] = qpow(1.0 * j / m, n);
    }
    db ans = 0;
    for (int j = m; j > 0; --j) {
        p[j] -= p[j - 1];
        ans += j * p[j];
    }
    cout << fixed << setprecision(12) << ans << "\n";
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int t = 1;
    // cin >> t;
    while (t--) { solve(); }
}
```
