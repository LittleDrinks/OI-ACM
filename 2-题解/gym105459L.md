---
tags:
  - 题解
  - 概率与期望
aliases:
  - A Game On Tree
---
## [gym105459L. A Game On Tree](https://codeforces.com/gym/105459/problem/L)

总共有 ${n\choose 2}^2$ 种选法，我们只需要计算所有选法的 $X^2$ 之和即可。
设两条路径的公共边集为 $E=\{e_i\}_{i=1}^k$，则 $\sum (X^2)$ 可以改写为
$$
\sum_E\Bigg(\sum_{i=1}^k |e_i|^2 + \sum_{1\le i,j\le k}|e_i|\cdot |e_j|\Bigg)
$$
交换求和顺序进行求解。
另一种思考方式是将 $\sum_{E}|E|^2$ 看作 $\sum_E\sum_{i=1}^{n-1}\sum_{j=1}^{n-1}[i\in E\land j\in E]$，等价于在树上任选两条边（可能重合），求他们在路径交集上的方案数。
下记 $u$ 的子树大小为 $siz(u)$，$u$ 子树内 $\displaystyle\sum_{v\in subtree(u),v\ne u} siz^2(v)$ 记为 $sum(u)$

---

对于第一部分，即求
$$
\sum_{i=1}^{n-1}\sum_E [e_i\in E]
$$
枚举每一条边 $(u,v)$，他能成为公共边当且仅当双方选的节点均位于 $u,v$ 两侧，则有
$$
\bigg(siz(v)\times (n-siz(v))\bigg)^2
$$

---

对于第二部分，即求
$$
2\sum_{1\le i <j< n} \sum_E[e_i\in E\land e_j\in E]
$$
为了不重不漏地枚举每一组有序对 $(e_i,e_j)$，我们钦定这两条边所有端点的 LCA 等于 $u$。则有两种情况。
第一种情况，两条边在 $v$ 的同一子树分支，即一条边为 $(u,v)$，另一条边 $(x,p)$ 在 $v$ 的子树内。此时双方必须选择 $u$ 外侧的一点和 $p$ 下方的一点，情况数为
$$
2\times \sum_{p\in subtree(v),p\ne v} \bigg(siz(p)\times(n-siz(v))\bigg)^2=2\times(n-siz(v))^2\times sum(v)
$$
第二种情况，两条边在 $v$ 的不同子树分支，答案为
$$
2\times \sum_{v_1,v_2\in subtree(u)} \bigg(sum(v_1)+siz^2(v_1)\bigg)\times\bigg(sum(v_2)+siz^2(v_2)\bigg)
$$

[***AC 代码***](https://codeforces.com/gym/105459/submission/334997675)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

const int MOD = 998244353;
ll add(ll x, ll y) { return (x + y) % MOD; }
ll mul(ll x, ll y) { return (x * y) % MOD; }
ll sq(ll x) { return mul(x, x); }
ll qpow(ll a, ll b = MOD - 2) {
    ll res = 1;
    for (; b; b >>= 1, a = mul(a, a)) {
        if (b & 1) res = mul(res, a);
    }
    return res;
}

void solve()
{
    int n;
    cin >> n;
    vector G(n+1, vector<int>());
    for (int i = 1; i < n; ++i) {
        int u, v;
        cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }

    ll ans = 0;
    vector<ll> siz(n+1, 1), sum(n + 1);
    function<void(int,int)> dfs = [&](int u, int fa) -> void {
        ll s = 0;
        for (auto v: G[u]) {
            if (v == fa) { continue; }
            dfs(v, u);
            siz[u] += siz[v];
            ll x = add(sum[v], sq(siz[v]));
            sum[u] = add(sum[u], x);
            ans = add(ans, mul(2, mul(sq(n-siz[v]), sum[v])));
            ans = add(ans, mul(2, mul(s, x)));
            s = add(s, x);
        }
        ans = add(ans, sq(mul(siz[u], n-siz[u])));
    };
    dfs(1, 0);

    ll base = sq(1LL*n*(n-1)/2%MOD);
    cout << mul(ans, qpow(base)) << "\n";
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int t = 1;
    cin >> t;
    while (t--) { solve(); }
}
```
