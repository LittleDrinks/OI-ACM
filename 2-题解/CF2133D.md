---
tags:
  - 题解
  - DP
aliases:
  - Chicken Jockey
---
## [CF2133D. Chicken Jockey](https://codeforces.com/contest/2133/problem/D)

观察最终的操作序列，有如下观察：①如果想对 $i$ 向造成超过两点的摔落伤害，$i-1$ 必须是被砍死的；②如果有两个不相邻位置 $i,j\ (i+1 <j)$ 受到了摔落伤害，最优的方法是先摔 $j$ 再摔 $i$；③不能让相邻的两个怪兽从原序列中摔下，只能先摔较低的一个，再让较高的一个受到一点摔落伤害。
设 $dp(i)$ 表示将 $[1,i]$ 的怪物全部杀死需要的最少步数。
对 $i$ 位置上的怪物，有三种方法对其造成伤害。①把 $i-1$ 位置上的怪物砍死，对 $i$ 造成 $i-1$ 点伤害；②把更低的怪物砍死，然后一连串 $h=1$ 的怪物摔死，最终对 $i$ 造成 $1$ 点伤害；③不摔，直接砍。
记 $pre_i$ 表示 $i$ 前方第一个 $h>1$ 的位置，特别地，$pre_1=1$。则有状态转移方程
$$
dp(i)=\min\begin{cases}
dp(i-2)+h_{i-1}+\max(0,h_i-i+1) \\ 
dp(pre_i)+h_i-1 \\
dp(i-1)+h_i
\end{cases}
$$
这个式子已经可以通过本题，但其实转移还可以进一步简化。
综合观察①②③，或者第二和第三个式子可以发现，原序列中不应该存在三个以上不受摔落伤害的位置，直接做出“不摔”的决策是劣的，选择不摔只能是因为想摔后一个位置上的怪物。状态转移方程可以简化为
$$
dp(i)=\min\begin{cases}
dp(i-2)+h_{i-1}+\max(0,h_i-i+1) \\ 
dp(i-1)+h_i-1
\end{cases}
$$
时间复杂度 $O(n)$

[***AC 代码***](https://codeforces.com/contest/2133/submission/335593705)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

void solve()
{
    int n;
    cin >> n;
    vector<int> h(n+1);
    for (int i = 1; i <= n; ++i) {
        cin >> h[i];
    }
    vector<ll> dp(n+1);
    dp[1] = h[1];
    for (int i = 2; i <= n; ++i) {
        dp[i] = min(dp[i-1]+h[i]-1, dp[i-2]+h[i-1]+max(0,h[i]-i+1));
    }
    cout << dp[n] << "\n";
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int t = 1;
    cin >> t;
    while (t--) { solve(); }
}
```
