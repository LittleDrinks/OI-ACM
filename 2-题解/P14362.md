---
tags:
  - 题解
  - 最小生成树
aliases:
  - 道路修复
---
## [P14362 [CSP-S 2025] 道路修复 / road](https://www.luogu.com.cn/problem/P14362)

暴力的做法是：枚举选了哪些乡镇，对一共 $m+kn$ 条边跑最小生成树，复杂度 $O(2^k m\log m)$
注意到这 $m+kn$ 条边中，最小生成树以外的边一定会在后续的 kruskal 过程中被排除。
对最开始 $m$ 条边跑一遍 kruskal 得到 $n-1$ 条边，然后跑暴力，复杂度 $O(2^k n\log n)$，有点极限。
可以在一开始就把 $n-1+kn$ 条边全部放在一起排序，如果当次没有选到这个乡镇，那么跳过这些边，就可以把 $\log$ 压掉，复杂度 $O(2^k n)$，算下来正好 $10^8$，民间数据实测 1.1s 左右 

[***AC 代码***](https://www.luogu.com.cn/record/244794335)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

struct DSU {
    int n;
    vector<int> f;
    DSU(int n): n(n), f(n+1) {
        iota(f.begin(), f.end(), 0);
    }
    int find(int x) {
        return f[x] == x ? f[x]: f[x] = find(f[x]);
    }
    bool same(int x, int y) {
        return find(x) == find(y);
    }
    void merge(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) { return; }
        f[x] = y;
    }
};

void solve()
{
    int n, m, k;
    cin >> n >> m >> k;
    vector<array<int,3>> e(m), t;
    for (auto &[w, u, v]: e) {
        cin >> u >> v >> w;
    }
    {
        DSU d(n + 1);
        sort(e.begin(), e.end());
        for (auto &[w, u, v]: e) {
            if (!d.same(u, v)) {
                d.merge(u, v);
                t.push_back({w,u,v});
            }
        }
    }
    vector<ll> c(k);
    auto ee(t);
    for (int i = 0; i < k; ++i) {
        cin >> c[i];
        for (int j = 0; j < n; ++j) {
            int w;
            cin >> w;
            int u = n + i + 1;
            int v = j + 1;
            ee.push_back({w, u, v});
        }
    }
    sort(ee.begin(), ee.end());
    ll ans = 1e18;
    for (int s = 0; s < (1 << k); ++s) {
        ll cur = 0;
        for (int i = 0; i < k; ++i) {
            if (s >> i & 1) {
                cur += c[i];
            }
        }
        DSU d(n + k + 1);
        for (auto &[w, u, v]: ee) {
            if (u > n && (~s >> (u - n - 1) & 1)) { continue; }
            if (d.same(u, v)) { continue; }
            d.merge(u, v);
            cur += w;
        }
        ans = min(ans, cur);
    }
    cout << ans << "\n";
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int t = 1;
    // cin >> t;
    while (t--) { solve(); }
}
```
