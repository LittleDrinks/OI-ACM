---
tags:
  - 题解
  - 最短路
  - 凸壳
aliases:
  - Highway Upgrade
---
## [NCC108299H. Highway Upgrade](https://ac.nowcoder.com/acm/contest/108299/H)

由于题目保证任意一条边不会被减到负数，显然应该挑一条边一直减。
记 $d_1(u)$ 表示从 $1$ 走到 $u$ 的最短路，$d_n(v)$ 表示从 $v$ 走到 $n$ 的最短路。如果一条边 $u\to v$ 被减了 $x$ 次，从 $1$ 到 $n$ 新的最短路应该是 $d_1(u)+d_n(v)+t-w_ix$。
注意到这个式子是一个关于 $x$ 的一次函数，或者说一条线段。每次询问实际上是求横坐标为 $x$ 时所有线段中最小的 $y$ 值。
对于所有线段，只有位于下凸壳上的那些线段可能成为答案。把所有线段按照从缓到陡排序，斜率相同的按照截距从大到小排序。按照这个顺序每次加入一条线段，会和已有下凸包有若干个交点，并且从这个交点处往下凹。
两条直线 $(k_1,b_1)$ 和 $(k_2,b_2)$ 的交点横坐标有公式
$$
x=\dfrac{b_2-b_1}{k_1-k_2}
$$
记凸包后加入的两条线段为 $c_1,c_2$，尝试向凸包中加入线段 $l$ 时，有两种情况会将 $c_2$ 弹出：

1. 由于 $k_l\le k_{c_2}$，当 $b_l\le b_{c_2}$ 时，$l$ 整条线段都在 $c_2$ 下方
2. $c_1,c_2$ 交点的横坐标 $x_1$ 和 $c_2,l$ 交点的横坐标 $x_2$ 满足关系 $x_2\le x_1$，此时 $l$ 必然会在先于 $x_1$ 处下凹

![[NCC108299H图示]]

按照上述规则维护下凸壳即可，整体是一个从右往左建凸壳的过程。时间复杂度 $O(n)$
记凸壳上相邻线段交点横坐标 $x$ 构成的集合为 $X$，处理询问时，实际上是在找 $X$ 中第一个大于等于 $qx$ 的交点，然后选择其左侧的那条线段，时间复杂度 $O(\log n)$

[***AC 代码***](https://ac.nowcoder.com/acm/contest/view-submission?submissionId=78315243)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

constexpr ll inf = 1e18;

void solve()
{
	int n, m;
	cin >> n >> m;

    vector<ll> w(m + 1);
    vector<tuple<int,int,ll>> E(m);
    for (int i = 1; i <= m; ++i) {
        auto& [u, v, t] = E[i-1];
        cin >> u >> v >> t >> w[i];
    }

    auto Dijkstra = [&](int s) -> vector<ll> {
        vector G(n+1, vector<pair<int,ll>>());
        for (auto [u, v, t]: E) {
            G[u].emplace_back(v, t);
        }

        vector<bool> vis(n + 1);
        vector<ll> dis(n + 1, inf);
        priority_queue<pair<ll,int>,vector<pair<ll,int>>,greater<>> q;
        dis[s] = 0;
        q.emplace(0, s);
        while (!q.empty()) {
            auto [d, u] = q.top(); q.pop();
            if (vis[u]) { continue; }
            vis[u] = 1;
            for (auto [v, t]: G[u]) {
                if (dis[v] > dis[u] + t) {
                    dis[v] = dis[u] + t;
                    if (!vis[v]) { q.emplace(dis[v], v); }
                }
            }
        }
        return dis;
    };

    auto d1 = Dijkstra(1);
    for (auto& [u, v, w]: E) { swap(u, v); }
    auto d2 = Dijkstra(n);

    vector<pair<ll,ll>> line;
    for (int i = 1; i <= m; ++i) {
        auto& [u, v, t] = E[i-1];
        swap(u, v);
        line.emplace_back(-w[i], d1[u]+d2[v]+t);
    }

    auto interx = [](pair<ll,ll> a, pair<ll,ll> b) -> ll {
        return (a.second-b.second) / (b.first-a.first);
    };

    sort(line.rbegin(), line.rend());
    vector<pair<ll,ll>> stk;
    for (auto l: line) {
        while (!stk.empty()) {
            if (stk.back().second >= l.second) {
                stk.pop_back();
            } else if (stk.size() >= 2 && interx(*prev(stk.end(),2), stk.back()) >= interx(stk.back(), l)) {
                stk.pop_back();
            } else {
                break;
            }
        }
        stk.push_back(l);
    }

    int q;
    cin >> q;
    while (q--) {
        ll x; cin >> x;
        ll L = 0, R = stk.size();
        while (L + 1 < R) {
            ll m = (L + R) >> 1;
            if (interx(stk[m-1], stk[m]) < x) {
                L = m;
            } else {
                R = m;
            }
        }
        auto [k, b] = stk[R - 1];
        cout << k * x + b << "\n"; 
    }
}

int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
	int t = 1;
	cin >> t;
	while (t--) { solve(); }
}
```
