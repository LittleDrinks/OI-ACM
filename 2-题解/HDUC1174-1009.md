---
tags:
  - 题解
  - 概率与期望
  - DP
aliases:
  - 线段染色
---
## [HDUC1174-1009. 线段染色](https://acm.hdu.edu.cn/contest/problem?cid=1174&pid=1009)

设 $dp(i,j)$ 表示右端点在 $[1,i]$ 的所有区间都被染色，并且最后一个染色的位置在 $j$ 的概率。
记 $L_i$ 表示右端点在 $[1,i]$ 的所有区间，左端点的最大值。
考虑 $dp(i,j)$ 如何从 $dp(i-1)$ 转移得到。
①如果 $L_i\le j<i$，则概率为 $dp(i-1,j)$ 再乘上 $i$ 不被染色的概率。
②如果 $j=i$，枚举上一个被染色的点 $k$ 求和，再乘上 $i$ 被染色的概率。
③如果 $j<L_i$ 或 $j>i$，不合法。
写成状态转移方程为：
$$
dp(i,j)=\begin{cases}
dp(i-1,j)\times(1-p_i) & L_i\le j<i\\ 
p_i\displaystyle\sum_{k=0}^{j-1} dp(i-1,k) & j=i \\
0 & j<L_i\lor j>i
\end{cases}
$$
$\sum_{j=0}^ndp(n,j)$ 即为所求。
这是一个 $O(n^2)$ 的 DP。注意到每次转移会把一大段东西都乘上 $1-p_i$，再求个和。可以用线段树维护（但官解说会 TLE）。以下是一种更优秀的优化方法：
利用两个性质：
① $L_i\le j<i$ 的部分都要乘上 $i-p_1$；
② $L_i$ 递增。考虑把所有 $1-p_i$ 放到最后再乘
即求
$$f(j)=\dfrac{dp(i,j)}{\prod_{k=1}^{i}(1-p_k)}$$
每次在 $i$ 转移时 $L_i\le j<i$ 的 $f(j)$ 不会动，设一个双指针把 $j<L_i$ 的部分清零，可以均摊 $O(n)$ 地求出 $\sum f(j)$，在求 $f(i)$ 时令
$$
f(i)\leftarrow p_i\sum_{k=L_i}^{i-1}f(k)
$$
$n$ 轮转移后 $f$ 即为 $dp(n)$，求和后乘上 $\prod_{i=1}^n(1-p_i)$ 即可，时间复杂度 $O(\sum n + \sum m)$。

[***AC 代码***](https://acm.hdu.edu.cn/contest/view-code?cid=1174&rid=26527)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

const int MOD=1e9+7;
ll add(ll x, ll y) { return (x+ y) % MOD; }
ll del(ll x, ll y) { return add(x, MOD-y); }
ll mul(ll x, ll y) { return (x * y) % MOD; }
ll qpow(ll a, ll b = MOD - 2) {
    ll res = 1;
    for (; b; b >>= 1) {
        if (b & 1) { res = mul(res, a); }
        a = mul(a, a);
    }
    return res;
}

void solve()
{
	int n, m;
	cin >> n >> m;
    vector<int> p(n+1), q(n+1);
    for (int i = 1; i <= n; ++i) {
        cin >> p[i];
        p[i] = mul(p[i], qpow(10));
        q[i] = del(1, p[i]);
    }
    vector<int> mxL(n+1);
    for (int i = 1; i <= m; ++i) {
        int l, r;
        cin >> l >> r;
        mxL[r] = max(mxL[r], l);
    }

    vector<int> dp(n+1);
    int pt = 0;
    int sum = 1;
    dp[0] = 1;
    for (int i = 1; i <= n; ++i) {
        if (p[i] == 1) { dp[i]=sum; pt=i;}
        else {
            dp[i] = mul(sum, mul(p[i], qpow(q[i])));
            sum = add(sum, dp[i]);
            while (mxL[i] > pt) { sum = del(sum, dp[pt++]); }
        }
    }
    for (int i = 1; i <= n; ++i) {
        if (p[i] != 1) { sum = mul(sum, q[i]); }
    }
    cout << sum << "\n";
}

int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
	int t = 1;
	cin >> t;
	while (t--) { solve(); }
}

```
