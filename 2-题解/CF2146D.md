---
tags:
  - 题解
aliases:
  - Max Sum OR
---
## [CF2146D. Max Sum OR (Hard Version)](https://codeforces.com/contest/2146/problem/D2)

为了让或尽可能大，最优的方法是将两个二进制位不同的数放在一起。
答案的上界是每一个位置的 $1$ 都计入答案，即 $2\sum_{i=l}^r i$。
从高到低考虑每一个二进制位。
区间 $[l, r]$ 上这个二进制位的分布一定是 $\texttt{000}...\texttt{111}...$，相邻两个 $\texttt{01}$ 的整块整体翻转后，浪费的 $1$ 一定是最少的。

[***AC 代码***](https://codeforces.com/contest/2146/submission/339825231)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

void solve()
{
    int l, r;
    cin >> l >> r;
    int n = r - l + 1;
    vector<int> a(n);
    iota(a.begin(), a.end(), l);
    int x = 0, y = n;
    for (int i = 29; i >= 0; --i) {
        int u = x;
        while (u < y && (~a[u] >> i & 1)) {
            ++u;
        }
        if (u - x < y - u) {  // 0 少
            int m = 2 * u - x;
            reverse(a.begin() + x, a.begin() + m);
            x = m;
        } else {  // 1 少
            int m = 2 * u - y;
            reverse(a.begin() + m, a.begin() + y);
            y = m;
        }
    }
    ll ans = 0;
    for (int i = 0; i < n; ++i) {
        ans += (a[i] | (l + i));
    }
    cout << ans << "\n";
    for (int i = 0; i < n; ++i) {
        cout << a[i] << " \n"[i == n - 1];
    }
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int t = 1;
    cin >> t;
    while (t--) { solve(); }
}

```
