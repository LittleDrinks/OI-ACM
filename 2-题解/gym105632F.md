---
tags:
  - 题解
aliases:
  - Infinite Loop
---
## [gym105632F. Infinite Loop](https://codeforces.com/gym/105632/problem/F)

把第一天最后一个任务和第二天前 $n-1$ 个任务看作一组。
当 $\displaystyle\sum_{i=1}^n b_i\le k$ 时，第二天肯定存在一个时刻 $t$，使 $t$ 前和 $t$ 后的任务不会相互影响。此时第 $i$ 天的任务只可能在 $i$ 或 $i+1$ 天完成，并且同一个任务的完成时间构成一个公差为 $k$ 的等差数列。
当 $\displaystyle\sum_{i=1}^n b_i > k$ 时，前一天会影响后一天，并且任务会不断堆积，从第三天开始就会没有休息时间地一直干活，同一任务的完成时间构成一个公差为 $\displaystyle\sum_{i=1}^n b_i$ 的等差数列。
模拟前两天的任务，根据上述两类情况计算后续的答案即可。

[***AC 代码***](https://codeforces.com/gym/105632/submission/336233841)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

const int N=1e5+5;
int n, q, a[N], b[N];
ll k, ans[3][N], s;

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    cin >> n >> k >> q;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i] >> b[i];
        s += b[i];
    }
    ll u = 0;
    for (int i = 1; i <= 2; ++i) {
        for (int j = 1; j <= n; ++j) {
            u = max(u, 1LL*(i-1)*k+a[j]);
            u += b[j] - 1;
            ans[i][j] = u;
            ++u;
        }
    }
    while (q--) {
        int x, y;
        cin >> x >> y;
        ll t = x <= 2 ? ans[x][y] : ans[2][y] + (x-2) * max(k, s);
        cout << (t-1)/k+1 << " " << (t-1)%k+1 << "\n";
    }
}
```
