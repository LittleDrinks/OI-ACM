---
tags:
  - 题解
  - 线段树
aliases:
  - Yet Another MEX Problem
---
## [CF2146E. Yet Another MEX Problem](https://codeforces.com/contest/2146/problem/E)

设 $last_x$ 为 $x$ 最后一次出现的位置，$g(i,x)$ 表示 $[last_x+1,i]$ 中大于 $x$ 的数的个数。
先考虑暴力怎么做。
在 $i$ 处枚举 $\mathrm{mex} = x$，如果 $[last_x+1,i]$ 中小于的数字都至少出现一次，则 $x$ 可能成为 mex，此时的答案为 $g(i,x)$。最终所求为 $\max \{g(i,x)\}$
复杂度的瓶颈在于筛选满足“所有小于 $x$ 的数字都至少出现一次”的 $x$。一种思路是证明在不满足这一条件时答案必然更劣，因此不用筛选。
$x$ 不能成为 mex，当且仅当存在一个 $y<x$，满足 $last_y<last_x$，不难发现此时 $g(i,y)$ 更优。
因此，不合法的 mex 不会影响答案，我们只需要维护 $g(i,x)$ 即可。发现右端点从 $i$ 移动到 $i+1$ 时
$$
g(i+1,x)=
\begin{cases}
g(i,x) + 1 & x < a_{i + 1} \\
0 & x = a_{i + 1} \\
g(i,x) & x > a_{i + 1}
\end{cases}
$$
问题转化为区间加法、单点清空、全局最值，对 mex 的值域开线段树即可，时间复杂度 $O(n\log n)$。
总结：遇到“先筛选后取 $max$”时，可以思考一下也许不用筛选。

[***AC 代码***](https://codeforces.com/contest/2146/submission/339842661)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

#define lson (p << 1)
#define rson (p << 1 | 1)
#define m ((l + r) >> 1)
template <typename Info, typename Lazy> struct segmentTree {
    int n;
    vector<Info> a;
    vector<Lazy> t;

    segmentTree(int n) : n(n), a(4 << __lg(n)), t(4 << __lg(n)) {
    }
    segmentTree(vector<Info> &&vec) : segmentTree(vec.size()) {
        function<void(int, int, int)> build = [&](int p, int l, int r) -> void {
            if (r - l == 1) {
                a[p] = vec[l];
                return;
            }
            build(lson, l, m);
            build(rson, m, r);
            push_up(p);
        };
        build(1, 0, n);
    }

    void push_up(int p) {
        a[p] = a[lson] + a[rson];
    }

    void apply(int p, Lazy v) {
        a[p] = a[p] + v;
        t[p] = t[p] + v;
    }

    void spread_down(int p) {
        apply(lson, t[p]);
        apply(rson, t[p]);
        t[p] = Lazy();
    }

    template <typename F> Info dfs(int p, int l, int r, int x, int y, F &&op) {
        if (y <= l || r <= x) {
            return Info();
        }
        if (x <= l && r <= y) {
            op(p, l, r);
            return a[p];
        }
        spread_down(p);
        Info res;
        res = res + dfs(lson, l, m, x, y, op);
        res = res + dfs(rson, m, r, x, y, op);
        push_up(p);
        return res;
    }

    template <typename F>
    pair<int, Info> findFirst(int p, int l, int r, int x, int y, F &&pred) {
        if (y <= l || r <= x) {
            return {-1, Info()};
        }
        if (x <= l && r <= y && !pred(a[p])) {
            return {-1, Info()};
        }
        if (l == r - 1) {
            return {l, a[p]};
        }
        spread_down(p);
        pair<int, Info> res = findFirst(lson, l, m, x, y, pred);
        if (res.first == -1) {
            res = findFirst(rson, m, r, x, y, pred);
        }
        return res;
    }

    void modify(int x, int y, Lazy v) {
        dfs(1, 0, n, x, y + 1, [&](int p, int l, int r) { apply(p, v); });
    }

    Info query(int x, int y) {
        return dfs(1, 0, n, x, y + 1, [](int, int, int) {});
    }

    void reset(int x) {
        dfs(1, 0, n, x, x + 1, [&](int p, int l, int r) { a[p] = Info(); });
    }
};
#undef lson
#undef rson
#undef m
struct Info {
    int mx;
    Info(int mx = 0) : mx(mx) {
    }
};
struct Lazy {
    int a;
    Lazy(int a = 0) : a(a) {
    }
};
Info operator+(Info u, Info v) {
    return Info(max(u.mx, v.mx));
}
Info operator+(Info u, Lazy v) {
    return Info(u.mx + v.a);
}
Lazy operator+(Lazy u, Lazy v) {
    return Lazy(u.a + v.a);
}

void solve() {
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
    }
    segmentTree<Info, Lazy> t(n + 1);
    for (int i = 0; i < n; ++i) {
        t.reset(a[i]);
        t.modify(0, a[i] - 1, Lazy(1));
        cout << t.query(0, n).mx << " \n"[i == n - 1];
    }
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
```
