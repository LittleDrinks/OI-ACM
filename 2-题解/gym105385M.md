---
tags:
  - 题解
  - 计算几何/凸包
  - DP
aliases:
  - Palindromic Polygon
---
## [gym105385M. Palindromic Polygon](https://codeforces.com/gym/105385/problem/M)

考虑在一个已有的回文串（初始时是空串或者单个字符）两侧加上一对相同的字符。
直接贪心地向两侧延伸是错误的，因为可能有若干组相交的顺序对。
考虑 DP。一个直观的想法是设 $dp(i,j)$ 表示当前回文串的两端是 $a_i$ 和 $a_j$，但是这样转移的时候顺序会很难确定，此时我们可以为 $i\to j$ 钦定一个方向。
设 $dp(i,j)$ 表示 $a_i=a_j$ 时，考虑 $i\to j$ 这一段逆时针的点的最大面积。每次考虑这段区间内的一组顺序点对 $(x,y)$，有转移
$$
\begin{cases} 
dp(i,i) = 0 & \forall 0\le i\le n-1\\
dp(i,(i+1)\bmod n) = 0 & a_i=a_{(i+1)\bmod n}\\
dp(i,j)=\max_{a_x=a_y}\{dp(x,y) + S(p_i,p_j,p_x,p_y)\} & a_i=a_j\land i\to x\to y\to j
\end{cases}
$$
直接转移的时间复杂度是 $O(n^4)$ 的。
根据凸包的性质，如果 $i\to x$ 和 $y\to j$ 两段上存在 $a$ 相同的点，那么把这两个点选上必然更优，因此我们可以钦定 $x$ 是 $i$ 后的第一个点，或者钦定 $y$ 是 $j$ 前的第一个点，这样对于每个 $a$，只需要进行 $2cnt$ 次转移，复杂度降至 $O(n^3)$。
注意 $i\to j$ 的顺序已经确定了，不要写 $dp(\min(i,j),\max(i,j))$ 这种鬼东西。

[***AC 代码***](https://codeforces.com/gym/105385/submission/342900741)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

const db eps=1e-8;
const db PI=acos(-1.0);
const db inf = numeric_limits<db>::max();
int sgn(auto x) { return (x > eps) - (x < -eps); }

using T = ll;
struct Point {
	T x, y;
    Point(T x=0, T y=0): x(x), y(y) {}
	friend istream& operator>> (istream& is, Point& p) { return is>>p.x>>p.y; }
	friend ostream& operator<< (ostream& os, Point p) { return os<<"( "<<p.x<<", "<<p.y<<" )"; }
	db ang() { return atan2(y, x); }
	bool operator== (const Point &p) const { return sgn(x-p.x)==0 && sgn(y-p.y)==0; }
	bool operator< (const Point &p) const { return x<p.x || (x==p.x && y<p.y); }
	Point operator+ (const Point &p) const { return Point(x+p.x, y+p.y); }
    Point operator- (const Point &p) const { return Point(x-p.x, y-p.y); }
	Point operator* (const T &k) const { return Point(k*x, k*y); }
	Point operator/ (const T &k) const { return Point(x/k, y/k); }
	T operator* (const Point &p) const { return x*p.x + y*p.y; }
	T operator^ (const Point &p) const { return x*p.y - y*p.x; }  // 叉乘时打括号
	T len2() { return (*this)*(*this); }
	db len() { return sqrtl(len2()); }  // 等价于 hypotl(x, y)
	Point rot(db ang) { return Point(x*cos(ang)-y*sin(ang), x*sin(ang)+y*cos(ang)); }
	Point trunc(db l) { return (*this) * (l/len()); }
};

T area(Point a, Point b, Point c)
{
    return abs((a-b)^(a-c));
}

T area(Point a, Point b, Point c, Point d)
{
    return area(a, b, c) + area(b, c, d);
}

void solve()
{
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
    }
    vector<Point> p(n);
    for (auto &u: p) {
        cin >> u;
    }
    
    vector dp(n, vector<ll>(n, -1));
    for (int i = 0; i < n; ++i) {
        dp[i][i] = 0;
        int j = (i + 1) % n;
        if (a[i] == a[j]) {
            dp[i][j] = 0;
        }
    }
    ll ans = 0;
    for (int len = 2; len < n; ++len) {
        for (int i = 0; i < n; ++i) {
            map<int,vector<int>> id;
            int x = i;
            int y = (i + len) % n;
            if (a[x] != a[y]) {
                continue;
            }
            dp[x][y] = 0;
            for (int j = (x + 1) % n; j != y; j = (j + 1) % n) {
                id[a[j]].push_back(j);
            }
            for (auto& [_, vec]: id) {
                auto work = [&](int p1, int dir) {
                    for (auto p2: vec) {
                        auto& f = dir? dp[p2][p1]: dp[p1][p2];
                        if (~f) {
                            ll A = dir? area(p[x], p[y], p[p2], p[p1]): area(p[x], p[y], p[p1], p[p2]);
                            dp[x][y] = max(dp[x][y], f + A);
                            ans = max(ans, dp[x][y]);
                        }
                    }
                };
                work(vec[0], 0);
                work(vec.back(), 1);
            }
        }
    }
    cout << ans << "\n";
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int t = 1;
    cin >> t;
    while (t--) { solve(); }
}
```
