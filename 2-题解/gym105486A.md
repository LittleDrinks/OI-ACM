---
tags:
  - 题解
  - 构造
aliases:
  - Arrow a Row
---
## [gym105486A. Arrow a Row](https://codeforces.com/gym/105486/problem/A)

根据箭头形态，显然有三个必要条件：①以 $\texttt{>}$ 开头；②以 $\texttt{>>>}$ 结尾；③中间存在至少一个 $\texttt{-}$
由于每次操作都会覆盖之前的字符串，因此上一个操作必然包含下一个操作序列。
先把右侧的连续 $\texttt{>>>}\ldots$ 处理掉，然后把箭头的末端放在连续串的开头处，开头的字符从左到右和 $\texttt{>}$ 对齐即可。

[***AC 代码***](https://codeforces.com/gym/105486/submission/335791456)

```cpp
#include <bits/stdc++.h>
using namespace std;

void solve()
{
    string s;
    cin >> s;
    int n = s.size();
    if (s[0] == '-' || s[n-1] == '-' || s[n-2] == '-' || s[n-3] == '-') {
        cout << "No\n"; return;
    }
    if (all_of(s.begin(), s.end(), [](char x){ return x == '>'; })) {
        cout << "No\n"; return;
    }

    vector<pair<int,int>> ans;
    int now = n - 2;
    for (int i = n - 2; i; --i) {
        if (s[i-1] == '>') {
            now = i+2;
            ans.emplace_back(1, i+2);
        } else {
            break;
        }
    }
    for (int i = 2; i + 4 <= now; ++i) {
        if (s[i-1] == '>') {
            ans.emplace_back(i, now-i+1);
        }
    }

    cout << "Yes " << ans.size() << "\n";
    for (auto [x, y]: ans) {
        cout << x << " " << y << "\n";
    }
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    int t = 1;
    cin >> t;
    while (t--) { solve(); }
}
```
