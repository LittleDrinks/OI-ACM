---
tags:
  - 题解
  - 辗转相除法
aliases:
  - Ivory
---
## [NCC108304J. Ivory](https://ac.nowcoder.com/acm/contest/108304/J)

设 $e=\gcd(a,b)$，$a=xe$，$b=ye$，则
$$
\gcd(a^b,c^d)=\gcd(x^be^b,y^de^d)=e^b\gcd(x^b,y^de^{d-b})
$$
由于 $\gcd(x,y)=1$，因此
$$
\gcd(a^b,c^d)=e^b\gcd(x^b,e^{d-b})
$$
递归计算。每次 $a$ 至少除以二，有 $a\ge 2x$，因此至多递归 $O(\log V)$ 层，每层计算 GCD 需要 $O(\log V)$ 的时间，时间复杂度 $O(\log^2V)$

[***AC 代码***](https://ac.nowcoder.com/acm/contest/view-submission?submissionId=78700639)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

const int MOD = 998244353;
ll add(ll x, ll y) { return (x + y) % MOD; }
ll mul(ll x, ll y) { return (x * y) % MOD; }
ll qpow(ll a, ll b = MOD - 2) {
    a %= MOD;
    ll res = 1;
    for (; b; b>>=1, a=mul(a,a)) {
        if (b & 1) { res = mul(res, a);} 
    }
    return res;
}

void solve()
{
    ll a, b, c, d;
    cin >> a >> b >> c >> d;
    function<ll(ll,ll,ll,ll)> f = [&](ll a, ll b, ll c, ll d) -> ll {
        if (b > d) { swap(a, c); swap(b, d); }
        ll g = gcd(a, c);
        if (g == 1) { return 1; }
        if (b == 0 || d == 0) { return 1; }
        ll ans = qpow(g, b);
        ans = mul(ans, f(a / g, b, g, d-b));
        return ans;
    };
    cout << f(a, b, c, d) << "\n";
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int t = 1;
    cin >> t;
    while (t--) { solve(); }
}

```
