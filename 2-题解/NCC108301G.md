---
tags:
  - 题解
  - 概率与期望
aliases:
  - Ghost in the Parentheses
---
## [NCC108301G. Ghost in the Parentheses](https://ac.nowcoder.com/acm/contest/108301/G)

括号序列最经典的思路，把 $\texttt{(}$ 看作 $+1$，把 $\texttt{)}$ 看作 $-1$，序列前缀和非负，且总和为 $0$。
有限集期望的本质是计数问题，原问题等价于：$2^n$ 种混淆方案中，有多少种方案能唯一确定原括号序列。
唯一确定原括号序列这个条件依然很模糊，需要继续转换题意。
从前缀和这个思路出发，假设有一个 $\texttt{(}$ 和一个 $\texttt{)}$ 变成 $\texttt{?}$，因为总和为零，对方一定知道 $\texttt{?}$ 中有一对括号，因此把这对括号交换后的序列可能与原序列产生混淆。此时可以发现，如果这两个括号在原序列中的相对顺序为 $\texttt{)(}$，一定无法唯一确定。
题目转化为从原序列中挑出一个 $\texttt{(((}\ldots\texttt{))}$ 子序列变成 $\texttt{?}$ 且能唯一确定的方案数。此时已经满足总和为 $0$ 这个条件了，需要进一步满足前缀和非负。


[***AC 代码***](https://ac.nowcoder.com/acm/contest/view-submission?submissionId=78462416)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

const int MOD = 998244353;
ll add(ll x, ll y) { return (x + y) % MOD; }
ll mul(ll x, ll y) { return (x * y) % MOD; }
ll qpow(ll a, ll b = MOD - 2) {
    ll res = 1;
    for (; b; b >>= 1) {
        if (b & 1) { res = mul(res, a); }
        a = mul(a, a);
    }
    return res;
}

void solve()
{
	string s;
    cin >> s;
    int n = s.length();
    vector<ll> sum(n+2), pre(n+2), suf(n+2);
    for (int i = 1; i <= n; ++i) {
        sum[i] = sum[i-1] + (s[i-1] == '(' ? 1 : -1);
    }
    for (int i = 1; i <= n; ++i) {
        pre[i] = pre[i-1] + (s[i-1]=='(');
    }
    for (int i = n; i > 0; --i) {
        suf[i] = suf[i+1] + (s[i-1]==')');
    }
    int j = 1;
    ll ans = 0;
    for (int i = 1; i <= n; ++i) {
        j = max(i, j);
        while (j <= n && sum[j] > 1) { ++j; }
        if (s[i-1] == '(') {
            ans = add(ans, mul(qpow(2, pre[i-1]), qpow(2, suf[j+1])));
        }
    }
    ans = add(ans, qpow(2, n/2));
    cout << mul(ans, qpow(qpow(2), n)) << "\n";
}

int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
	int t = 1;
	// cin >> t;
	while (t--) { solve(); }
}
```
