---
tags:
  - 题解
  - 概率与期望
aliases:
  - Ghost in the Parentheses
---
## [NCC108301G. Ghost in the Parentheses](https://ac.nowcoder.com/acm/contest/108301/G)

考虑一个括号序列能唯一还原的充要条件。
长 $2n$ 的括号序列必然包括 $n$ 对括号，如果只删除左右括号中的一种，必然可以唯一还原。
考虑同时删除一个左括号和一个右括号的情况。此时括号序列能唯一还原，等价于交换这对左右括号所产生的新括号序列非法。不妨设左括号位于 $S_1$，右括号位于 $S_2$。
括号序列最经典的思路，把 $\texttt{(}$ 看作 $+1$，把 $\texttt{)}$ 看作 $-1$。括号序列合法的条件为：序列前缀和 $\displaystyle\sum_{j=1}^i s_j$ 非负，且总和为 $0$。
当 $S_1>S_2$ 时，交换 $S_1$ 和 $S_2$ 会使区间 $[S_1,S_2]$ 上的前缀和加 $2$，此时交换后必然合法。
当 $S_1<S_2$ 时，只有 $\displaystyle\min_{i=S_1}^{S_2}\left(\sum_{j=1}^{i}s_j\right)<2$ 时交换后不合法。
考虑删除了多个左右括号的情况。首先 $\texttt{)))(((}$ 一定不能唯一还原，删除的括号序列必须形如 $\texttt{((()))}$。
根据 $\displaystyle\min_{i=S_1}^{S_2}\left(\sum_{j=1}^{i}s_j\right)<2$ 这个条件，只要交换第一个左括号和最后一个右括号后括号序列非法，交换中间的括号也一定非法。我们考虑枚举最后一个被删除的左括号的位置 $i$，记 $i$ 往后第一个前缀和小于 $2$ 的位置为 $R_i$，那么 $(i,2n]$ 上的左括号不能删除、$[1,R_i]$ 上的右括号不能删除。
我们可以用双指针在 $O(n)$ 的时间内求出 $R_i$，记 $[i,n]$ 上左括号的数量为 $suf(i)$，$[1,i]$ 上右括号的数量为 $pre(i)$。我们分为【不删除左括号】和【删除至少一个左括号】两部分统计答案，则答案为
$$
\left(\dfrac{1}{2}\right)^{n}+ \sum_{1\le i\le n,s_i=\texttt{(}} \Bigg(\left(\dfrac{1}{2}\right)^{pre(R_i)}\times \left( \dfrac{1}{2}\right)^{suf(i)}\Bigg)
$$

[***AC 代码***](https://ac.nowcoder.com/acm/contest/view-submission?submissionId=78923122)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

const int MOD = 998244353;
ll add(ll x, ll y) { return (x + y) % MOD; }
ll mul(ll x, ll y) { return (x * y) % MOD; }
ll qpow(ll a, ll b = MOD - 2) {
    ll res = 1;
    for (; b; b >>= 1) {
        if (b & 1) { res = mul(res, a); }
        a = mul(a, a);
    }
    return res;
}

void solve()
{
    string s;
    cin >> s;
    int n = s.size() / 2;
    vector<int> pre(2*n+2), suf(2*n+2), sum(2*n+2);
    for (int i = 1; i <= 2*n; ++i) {
        sum[i] = (s[i-1] == '(' ? 1 : -1);
        pre[i] = (s[i-1] == ')');
        suf[i] = (s[i-1] == '(');
    }
    partial_sum(sum.begin(), sum.end(), sum.begin());
    partial_sum(pre.begin(), pre.end(), pre.begin());
    partial_sum(suf.rbegin(), suf.rend(), suf.rbegin());

    const ll base = qpow(2);
    ll ans = qpow(base, n);
    for (int i = 1, j = 1; i <= 2*n; ++i) {
        j = max(i, j);
        while (j <= 2*n && sum[j] >= 2) { ++j; }
        if (s[i-1] == '(') {
            ans = add(ans, mul(qpow(base, pre[j]), qpow(base, suf[i])));
        }
    }
    cout << ans << "\n";
}

int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
	int t = 1;
	// cin >> t;
	while (t--) { solve(); }
}

```
