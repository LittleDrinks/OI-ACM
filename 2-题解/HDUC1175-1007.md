---
tags:
  - 题解
  - 线段树
  - 树状数组
aliases:
  - 咖啡的罪恶
---
## [HDUC1175-1007. 咖啡的罪恶](https://acm.hdu.edu.cn/contest/problem?cid=1175&pid=1007)

> [!note]- 结论：设序列 $a_0,a_1,\ldots,a_n$ 为咖啡序列，仅有以下四类满足条件的咖啡序列</br> $\texttt{2 0 2 0}$</br>$\texttt{1 2 1 0}$</br>$\texttt{2 1 2 0 0}$</br>$\texttt{n-3 2 1 0 0 ... 1 0 0 0}$
> 
> 因为 $a_i$ 表示出现次数，其和应该等于序列长度，即 $$\displaystyle\sum_{i=0}^na_i=n+1$$
> 考虑除去 $a_0$ 以外的位置，其和应该为
> $$\displaystyle\sum_{i=1}^{n}a_i=n+1-a_0$$
> 而一共有 $n-a_0$ 个非零数，因此这些位置中一定有且仅有一个 $\texttt{2}$，剩下（可能无）全是 $\texttt{1}$。
> 因此序列中只有 $a_0,2,(1),0$ 二/三/四种数，$1\le n-a_0\le 3$，据此讨论。
> 显然 $i\ge3$ 的位置上不能填 $2$，再根据 $a_1=2$ 和 $a_2=2$ 分类讨论。
> 
> - 当 $n-a_0=1$ 时，序列中只有 $0,2$ 两种数字，并且 $[1,n]$ 有且仅有一个非零数 $2$
> 	- $a_0=0$ 矛盾
> 	- $a_0=2$ 时，$n=3$，因为没有 $1,3$，所以 $a_1=a_3=0$，只能 $a_2=2$，序列为 $\color{red}\texttt{2 0 2 0}$
> - 当 $n-a_0=2$ 时，序列中只有 $0,1,2$ 三种数字，并且有且仅有两个非零数 $1,2$
> 	- $a_0=0$ 矛盾
> 	- $a_0=1$，$n=3$，$a_3$ 必须填 $0$，序列为 $\color{red}\texttt{1 2 1 0}$
> 	- $a_0=2$，$n=5$，$a_3,a_4$ 必须填 $0$，有 $\texttt{2 x x 0 0}$
> 		- $a_1=2$ 时，序列为 $\texttt{2 2 1 0 0}$，矛盾
> 		- $a_2=2$ 时，序列为 $\color{red}\texttt{2 1 2 0 0}$
> - 当 $n-a_0=3$，并且序列中只有 $0,1,2$ 三种数字，并且有且仅有一个 $2$ 两个 $1$
> 	- $a_0=0$，矛盾
> 	- $a_0=1$，$n=4$，$a_3,a_4$ 必须填 $0$，矛盾
> 	- $a_0=2$，$n=5$，$a_3,a_4,a_5$ 必须填 $0$，矛盾
> - 当 $n-a_0=3$，并且序列中有 $n-3,2,1,0$ 四种数字时，$n>6$，序列为 $\color{red}\texttt{n-3 2 1 0 ... 1 0 0 0}$

初始时，可以在一次 $O(n)$ 的扫描中求出所有咖啡序列的位置。
注意到 $n\ge4$ 的两种咖啡序列无交集，分两类维护。
对于一次修改，分为删除原先的数字，和新增数字两步操作。
*考虑删除*
对于 $n=3$ 的两类咖啡序列，删除 $a_p$ 最多两个咖啡序列，在 `std::set` 中找到左侧若干个 $n=3$ 的咖啡序列的起点，判一下 $a_p$ 是否位于其中即可。
对于 $n\ge4$ 的两类咖啡序列，由于其无交集，最多破坏一个咖啡序列，同样在 `std::set` 中找左侧最后一个咖啡序列的起点，判一下 $a_p$ 是否位于其中即可。
*考虑新增*
对于 $n=3$ 的咖啡序列，在 $[p-3,p]$ 中枚举一下起点就可以了。
对于 $\texttt{2 1 2 0 0}$，同上在 $[p-4,p]$ 中枚举一下起点。
对于 $\texttt{n-3 2 1 0 ... 1 0 0}$，在 `std::set` 中找到 $a_p$ 左侧第一个大于 $2$ 的数字，以它作为起点，判断 $2,1$ 所在的位置是否正确，再用树状数组维护一下前缀和看看是不是等于 $n+1$。
*考虑查询*
首先判断 $[l,r]$ 里面是否有 $n=3$ 的咖啡序列
$n\ge4$ 会有很多边界条件要判断，一种比较好写的做法是用线段树维护动态 RMQ，把答案标记在咖啡序列的右端点上，找到起点大于等于 $l$ 的第一个咖啡序列的右端点 $wr$，求 $[wr,r]$ 的区间最值。
维护四个 `std::set`，一个树状数组，一个线段树，时间复杂度 $O(n\log n)$

[***AC 代码***](https://acm.hdu.edu.cn/contest/view-code?cid=1175&rid=14059)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

struct BIT {
	int n;
    vector<ll> t;
    BIT(int n): n(n), t(n+1) { }
    int lowbit(int x) { return x&-x; }
    void modify(int x, ll d) {
        for (; x <= n; x += lowbit(x)) { t[x] += d; }
    }
    ll query(int x) {
        ll res = 0;
        for (; x; x -= lowbit(x)) { res += t[x]; }
        return res;
    }
};

#define lson (p << 1)
#define rson (p << 1 | 1)
#define m ((l+r)>>1)
template<typename Info>
struct segmentTree {
    int n;
    vector<Info> a;
    
    void push_up(int p) {
        a[p] = a[lson] + a[rson];
    }

    template<typename F>
    Info dfs(int p, int l, int r, int x, int y, F&& op) {
        if (y <= l || r <= x) { return Info(); }
        if (x <= l && r <= y) { op(p,l,r); return a[p]; }
        Info res;
        res = res + dfs(lson, l, m, x, y, op);
        res = res + dfs(rson, m, r, x, y, op);
        push_up(p);
        return res;
    }

    segmentTree(int n = 0): n(n), a(4 << __lg(n)) { }
    segmentTree(vector<Info>&& b): segmentTree(b.size()) {
        function<void(int,int,int)> build = [&](int p, int l, int r) -> void {
            if (r - l == 1) { a[p] = Info(b[l]); return; }
            build(lson, l, m);
            build(rson, m, r);
            push_up(p);
        };
        build(1, 0, n);
    }

    void modify(int pos, int x) {
        dfs(1, 0, n, pos, pos+1, [&](int p, int l, int r){ a[p].mx = x; });
    }

    int query(int l, int r) {
        return dfs(1, 0, n, l, r+1, [](int,int,int){}).mx;
    }
};
#undef lson
#undef rson
#undef m
struct Info {
    int mx;
    Info(int mx = 0): mx(mx) { }
    friend Info operator+ (Info u, Info v) {
        return Info( max(u.mx, v.mx) );
    }
};

void solve()
{
	int n, q;
	cin >> n >> q;
    vector<ll> a(n+1);
    BIT t(n);
    
    auto check = [&](int st, int len) -> bool {
        if (st <= 0 || st+len-1 > n) { return false; }
        if (len == 4) {
            if (a[st]==2 && a[st+1]==0 && a[st+2]==2 && a[st+3]==0) { return true; }
            if (a[st]==1 && a[st+1]==2 && a[st+2]==1 && a[st+3]==0) { return true; }
        }
        if (len == 5) {
            if (a[st]==2 && a[st+1]==1 && a[st+2]==2 && a[st+3]==0 && a[st+4]==0) { return true; }
        }
        if (len > 5) {
            bool valid = true;
            valid &= (a[st] == len-4);
            valid &= (a[st+1] == 2);
            valid &= (a[st+2] == 1);
            valid &= (a[st+len-4] == 1);
            valid &= t.query(st+len-1) - t.query(st-1) == len;
            return valid;
        }
        return false;
    };
    
    segmentTree<Info> ans(n+1);
    set<int> sl, sr, gre2, le;
    auto update = [&](int p, ll x) -> void {
        // del prev
        auto itL = sl.upper_bound(p);
        if (itL != sl.begin()) {
            itL = prev(itL);
            auto itR = sr.upper_bound(*itL);
            if (*itL <= p && p <= *itR) {
                ans.modify(*itR, 0);
                sl.erase(itL);
                sr.erase(itR);
            }
        }
        auto it4 = le.upper_bound(p);
        if (it4 != le.begin()) {
            it4 = prev(it4);
            while (it4 != le.end() && *it4 <= p && p <= (*it4)+3) {
                it4 = le.erase(it4);
                if (le.empty()) { break; }
                it4 = prev(it4);
            }
        }
        t.modify(p, -a[p]);
        if (a[p] > 2) { gre2.erase(p); }
        a[p] = x;
        t.modify(p, a[p]);
        if (a[p] > 2) { gre2.insert(p); }

        //.len = 4
        for (int i = p-3; i <= p; ++i) {
            if (check(i, 4)) {
                le.insert(i);
            }
        }

        // len = 5
        for (int i = p-4; i <= p; ++i) {
            if (check(i, 5)) {
                sl.insert(i);
                sr.insert(i+4);
                ans.modify(i+4, 5);
            }
        }
        
        // len > 5, find last > 2
        auto it = gre2.upper_bound(p);
        if (it != gre2.begin()) {
            it = prev(it);
            int l = *it;
            if (a[l] > 2 && check(l, a[l]+4)) {
                int r = l+a[l]+3;
                sl.insert(l);
                sr.insert(r);
                ans.modify(r, r-l+1);
            }
        }
    };

    for (int i = 1; i <= n; ++i) {
        ll x; cin >> x;
        update(i, x);
    }

    while (q--) {
        int op; cin >> op;
        if (op == 1) {
            int x, p;
            cin >> x >> p;
            update(x, p);
        } else {
            int l, r;
            cin >> l >> r;
            int res = 0;
            {
                auto it = le.lower_bound(l);
                if (it != le.end() && (*it) + 3 <= r) {
                    res = 4;
                }
            }
            {
                auto itL = sl.lower_bound(l);
                if (itL != sl.end()) {
                    int wl = *itL;
                    int wr = *sr.lower_bound(wl);
                    if (wr <= r) {
                        res = max(res, ans.query(wr, r));
                    }
                }
            }
            cout << res << "\n";
        }
    }
} 

int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
	int t = 1;
	cin >> t;
	while (t--) { solve(); }
}

```
