---
tags:
  - 题解
aliases:
---
## [HDUC1181-1002. Multiple and Factor](https://acm.hdu.edu.cn/contest/problem?cid=1181&pid=1002)

记 $S$ 表示 $[1,B]$ 组成的集合，不在 $S$ 中的数的倍数个数至多为 $\dfrac{n}{B}$。
记 $S$ 中元素排除懒标记后，操作 4 的答案为 $ans$。

- 操作 2，因数个数不会超过 $\sqrt n$ 个，可以直接暴力修改
	- 枚举 $S$ 中的每个元素 $y$，它会加上 $D\left(\dfrac{x}{y}\right)\cdot k$
	- 时间复杂度 $O(\sqrt{n} + B)$
- 操作 1
	- 不在 $S$ 中的元素可以 $O(\dfrac{n}{B})$ 修改，时间复杂度 $O\left(\dfrac{n}{B}\right)$
	- 对于 $S$ 中的一个元素 $y$
		- 如果 $y$ 是 $x$ 的因数，所有 $x$ 的倍数都是 $y$ 的倍数，$ans_y$ 加上 $\left\lfloor\dfrac{n}{x}\right\rfloor\cdot k$
		- 如果 $y$ 是 $x$ 的倍数，所有 $y$ 的倍数都是 $x$ 的倍数，$ans_y$ 加上 $\left\lfloor\dfrac{n}{y}\right\rfloor\cdot k$
		- 否则只有 $xy$ 的倍数会成为 $x$ 的倍数，$ans_y$ 加上 $\left\lfloor{\dfrac{n}{lcm(x,y)}}\right\rfloor\cdot k$
	- $S$ 中的元素打上懒标记，$O(1)$ 跳过
- 操作 3，至多 $\sqrt{n}$ 个因数，先暴力求出答案，再加上打上的懒标记
	- 枚举 $S$ 中的元素 $y$，如果 $y$ 是 $x$ 的因数，因数中会出现 $D\left(\dfrac{x}{y}\right)$ 次 $y$ 的倍数
	- 时间复杂度 $O(\sqrt{n}+B)$
- 操作 4，分为两种。
	- 不在 $S$ 中的元素 $x$，暴力求解答案，枚举 $S$ 中的元素 $y$，加上懒标记。
		- 如果 $x$ 是 $y$ 的倍数，后续会出现 $\left\lfloor\dfrac{n}{x}\right\rfloor$ 次符合条件的 $y$ 的倍数
		- 如果 $y$ 是 $x$ 的倍数，后续会出现 $\left\lfloor\dfrac{n}{y}\right\rfloor$ 次符合条件的 $y$ 的倍数
		- 否则，后续会出现 $\left\lfloor\dfrac{n}{lcm(x,y)}\right\rfloor$ 次符合条件的 $y$ 的倍数
	- 在 $S$ 中的元素，预处理出非懒标记的答案 $ans$，然后同上计算懒标记
	- 时间复杂度 $O(\dfrac{n}{B}+B)$

直接实现的时间复杂度是 $O\left(\dfrac{n^2}{B}\cdot \log n\right)$，复杂度瓶颈在于计算 $lcm$，取 $B=200$ 预处理 $gcd$，通过 $gcd$ 计算 $lcm$，时间复杂度 $O(\dfrac{n^2}{B})$

[***AC 代码***](https://acm.hdu.edu.cn/contest/view-code?cid=1181&rid=3654)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

void solve()
{
    int n, m;
    cin >> n >> m;
    int B = min(int(sqrt(n))+1, 200);

    vector _gcd(n+1, vector<int>(B+1));
    for (int i = 0; i <= n; ++i) { _gcd[i][0] = i; }
    for (int i = 0; i <= min(n,B); ++i) { _gcd[0][i] = i; }
    for (int j = 1; j <= min(n,B); ++j) {
        for (int i = 1; i <= n; ++i) {
            _gcd[i][j] = _gcd[j][i%j];
        }
    }

    vector<ll> a(n+1);
    vector<ll> ans(B+1);
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
    }

    vector fac(n+1, vector<ll>());
    for (int i = 1; i <= n; ++i) {
        for (int j = i; j <= n; j += i) {
            fac[j].push_back(i);
            if (i <= B) { ans[i] += a[j]; }
        }
    }

    vector<ll> lazy(B+1);
    while (m--) {
        int op; cin >> op;
        if (op == 2) {
            int x; ll k;
            cin >> x >> k;
            for (auto &y: fac[x]) {
                a[y] += k;
            }
            for (ll y = 1; y <= B; ++y) {
                if (x % y == 0) {
                    ll d = fac[x / y].size();
                    ans[y] += d * k;
                }
            }
        }
        else if (op == 1) {
            int x; ll k;
            cin >> x >> k;
            if (x > B) {
                for (ll i = x; i <= n; i += x) {
                    a[i] += k;
                }
                for (ll y = 1; y <= B; ++y) {
                    if (x % y == 0) { ans[y] += (n / x) * k; }
                    else if (y % x == 0) { ans[y] += (n / y) * k; }
                    else { ans[y] += n / (1LL * x / _gcd[x][y] * y) * k; }
                }
            } else {
                lazy[x] += k;
            }
        }
        else if (op == 4) {
            int x; cin >> x;
            ll res = 0;
            for (auto y: fac[x]) { res += a[y]; }
            for (ll y = 1; y <= B; ++y) {
                if (x % y == 0) {
                    ll d = fac[x / y].size();
                    res += d * lazy[y]; 
                }
            }
            cout << res << "\n";
        }
        else {
            int x; cin >> x;
            ll res = 0;
            if (x <= B) {
                res = ans[x];
            } else {
                for (ll i = x; i <= n; i += x) { res += a[i]; }
            }

            for (ll y = 1; y <= B; ++y) {
                if (x % y == 0) { res += (n / x) * lazy[y]; }
                else if (y % x == 0) { res += (n / y) * lazy[y]; }
                else { res += n / (1LL * x / _gcd[x][y] * y) * lazy[y]; }
            }
            cout << res << "\n";
        }
    }
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int t = 1;
    // cin >> t;
    while (t--) { solve(); }
}
```
