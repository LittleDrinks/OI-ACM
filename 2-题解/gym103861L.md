---
tags:
  - 题解
  - 贪心
aliases:
  - Fenwick Tree
---
## [gym103861L. Fenwick Tree](https://codeforces.com/gym/103861/problem/L)

每个节点的权值都来自于它的直接子节点，它的直系儿子是不相关的若干段长度为 $2^k$ 的子段和。比如 $c_4$ 的权值来自于 $c_2$ 和 $c_3$。
当 $s_i=\texttt{1}$ 时，它一定会向他的直系父节点传一个非零值。我们记 $cnt_i$ 表示 $i$ 这个节点接收了几个非零值。
当 $s_i=\texttt{1}$ 且 $cnt_1=0$ 时，必须在这个节点上操作一次。
当 $s_i=\texttt{1}$ 且 $cnt_i\ge1$ 时，显然可以满足非零的条件。
当 $s_i=\texttt{0}$ 且 $cnt_i=1$ 时，无法抵消这个非零值，只能操作一次把它清零。
当 $s_i=\texttt{0}$ 且 $cnt_i=0$ 时，显然不用操作。
当 $s_i=\texttt{0}$ 且 $cnt_i\ge2$ 时，由于这若干个来源互不相关，我们一定可以让这些值相互抵消，不用操作。
时间复杂度 $O(\sum n)$

[***AC 代码***](https://codeforces.com/gym/103861/submission/355448037)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

void solve()
{
    int n;
    string s;
    cin >> n >> s;
    s = " " + s;
    int ans = 0;
    vector<int> cnt(n + 1);
    for (int i = 1; i <= n; ++i) {
        if (s[i] == '1') {
            if (i + (i & -i) <= n) {
                cnt[i + (i & -i)]++;
            }
        }
    }
    for (int i = 1; i <= n; ++i) {
        if (s[i] == '1' && cnt[i] == 0) {
            ++ans;
        }
        if (s[i] == '0' && cnt[i] == 1) {
            ++ans;
        }
    }
    cout << ans << "\n";
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    int t = 1;
    cin >> t;
    while (t--) { solve(); }
}
```
