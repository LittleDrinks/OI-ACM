---
tags:
  - 题解
  - DP
aliases:
  - Binary Strings and Blocks
---
## [CF2170E. Binary Strings and Blocks](https://codeforces.com/contest/2170/problem/E)

只要段数大于等于 $2$，就符合“漂亮序列”的条件。一种删法是：偶数删两端，奇数删中间。
接下来考虑如何求出 $[l_i,r_i]$ 不同色的方案数。
对于一个位置 $i$，其最左侧的合法左端点位置为
$$
st=\max_{r_j\le i}\{l_j\} + 1
$$
我们设 $f(i)$ 表示前 $i$ 个位置的合法方案数，枚举最后一段同色段的位置，则有
$$
f(i)=\sum_{j=st-1}^{i-1}f(j)
$$
其中 $j$ 表示倒数第二个同色段的结束位置。
初始化 $f(0)=2$，表示一开始可以填 $0,1$ 两种数。
前缀和优化即可，时间复杂度 $O(n+m)$。

[***AC 代码***](https://codeforces.com/contest/2170/submission/351066014)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

const int MOD = 998244353;
ll add(ll x, ll y) { return (x + y) % MOD; }
ll del(ll x, ll y) { return add(x, MOD - y); }
ll mul(ll x, ll y) { return (x * y) % MOD; }
ll qpow(ll a, ll b = MOD - 2)
{
    ll res = 1;
    for (; b; b >>= 1, a = mul(a, a)) {
        if (b & 1) { res = mul(res, a); }
    }
    return res;
}

void solve()
{
    int n, m;
    cin >> n >> m;

    vector<int> mxl(n + 1);
    for (int i = 1; i <= m; ++i) {
        int l, r;
        cin >> l >> r;
        mxl[r] = max(mxl[r], l);
    }

    vector<int> dp(n + 1);
    vector<int> s(n + 1);
    dp[0] = 2;
    s[0] = 2;

    int st = 1;
    for (int i = 1; i <= n; ++i) {
        st = max(st, mxl[i] + 1);
        if (st <= i) {
            int pre = s[i - 1];
            if (st - 2 >= 0) {
                pre = del(pre, s[st - 2]);
            }
            dp[i] = pre;
        }
        s[i] = add(dp[i], s[i - 1]);
    }

    cout << dp[n] << "\n";
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    // cout << del(qpow(2, 200), mul(2, qpow(2, 175))) << "\n";
    int t = 1;
    cin >> t;
    while (t--) { solve(); }
}

```
