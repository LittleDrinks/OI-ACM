---
tags:
  - 题解
aliases:
  - MEX Count
---
## [CF2123E. MEX Count](https://codeforces.com/problemset/problem/2123/E)

先求出一个数都不删的 mex，记作 $X$。
删除 $k$ 个数字能形成的最大 mex 为 $\min(n-k,X)$，在这个之上的都要删掉。
在此基础上，可以把某一个范围内的一个满足 $cnt_y\le k$ 数 $y$ 全部删光，让 $y$ 成为 mex。
$k$ 每增加一，上界缩小 $1$，将若干个 $cnt_y=k$ 的数新增入答案集合即可。

[***AC 代码***](https://codeforces.com/contest/2123/submission/331744495)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

void solve()
{
	int n;
	cin >> n;
	set<int> exc;
	for (int i = 0; i <= n; ++i) { exc.insert(i); }
	map<int,int> cnt;
	for (int i = 1; i <= n; ++i) {
		int x; 
		cin >> x;
		cnt[x]++;
		exc.erase(x);
	}
	int mex = *exc.begin();
	map<int,vector<int>> invCnt;
	for (auto [x, t]: cnt) { invCnt[t].push_back(x); }

	set<int> ans;
	ans.insert(mex);
	for (int k = 0; k <= n; ++k) {
		ans.erase(n-k+1);
		for (auto x: invCnt[k]) {
			if (x <= mex && x <= n-k) {
				ans.insert(x);
			}
		}
		cout << ans.size() << " \n"[k == n];
	} 
}

int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
	int t = 1;
	cin >> t;
	while (t--) { solve(); }
}
```
