---
tags:
  - 题解
  - 矩阵快速幂
  - DP/状压DP
aliases:
  - Blood Memories
---
## [QOJ14707. Blood Memories](https://qoj.ac/contest/2563/problem/14707)

$n\le 6$，我们可以用一个 $2^n\times 2^n$ 的矩阵 $S$ 表示从某个状态（有若干人已经被加费了）开始，选择若干个人进行一次操作，到达另一个状态的花费。原问题等价于求从 $(000000)_2$ 出发走 $R$ 步到达任意状态的最短路。
定长最短路是一个经典的套路。设 $S(i,st_1,st_2)$ 表示用 $i$ 步从 $st_1$ 走到 $st_2$ 的最小花费，则有
$$
S(i,st_1,st_2)=\min_{st} S(i-1,st_1,st) + S(1, st, st_2)
$$
可以使用矩阵快速幂优化，或者把状态中的 $i$ 变为 $2^i$ 然后倍增，这两种理解本质上是一样的。
时间复杂度 $O(T\cdot 2^{3n})$

[***AC 代码***](https://qoj.ac/submission/1604528)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

void solve()
{
    int n, m, k, R;
    cin >> n >> m >> k >> R;
    vector<ll> a(n), c(n);
    for (int i = 0; i < n; ++i) {
        cin >> a[i] >> c[i];
    }
    int I = __lg(R) + 1;
    vector dp(I + 1, vector(1<<n, vector<ll>(1<<n)));
    for (int s = 0; s < (1 << n); ++s) {
        for (int t = 0; t < (1 << n); ++t) {
            ll tot = 0, dam = 0;
            for (int i = 0; i < n; ++i) {
                if (~t >> i & 1) { continue; }
                tot += c[i];
                dam += a[i];
                if (s >> i & 1) { tot += k; }
            }
            if (tot <= m) {
                dp[0][s][t] = dam;
            }
        }
    }
    for (int i = 1; i <= I; ++i) {
        for (int m = 0; m < (1 << n); ++m) {
            for (int s = 0; s < (1 << n); ++s) {
                for (int t = 0; t < (1 << n); ++t) {
                    dp[i][s][t] = max(dp[i][s][t], dp[i-1][s][m] + dp[i-1][m][t]);
                }
            }
        }
    }

    vector f(1<<n, vector<ll>(1<<n));
    for (int i = 0; i <= I; ++i) {
        if (~R >> i & 1) { continue; }
        vector nf(f);
        for (int m = 0; m < (1 << n); ++m) {
            for (int s = 0; s < (1 << n); ++s) {
                for (int t = 0; t < (1 << n); ++t) {
                    nf[s][t] = max(nf[s][t], f[s][m] + dp[i][m][t]);
                }
            }
        }
        f = move(nf);
    }
    ll ans = *max_element(f[0].begin(), f[0].end());
    cout << ans << "\n";
}

int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
```
