---
tags:
  - 题解
  - AC自动机
  - DP/状压DP
aliases:
  - "[HNOI2006] 最短母串问题"
  - 最短母串问题
---
## [P2322 [HNOI2006] 最短母串问题](https://www.luogu.com.cn/problem/P2322)

母串可以通过拼接某些前后缀相同的模式串的方式缩短。使用 AC 自动机维护最长后缀相同的位置。
采用不同的顺序压缩母串，最终的结果可能不同，这是一个全排列问题，可以转为状压求解。
对字典树上的每一个节点，设一串二进制数表示这个节点所代表的前缀中是否包含第 $i$ 个模式串。然后在 AC 自动机上 bfs 求出以当前模式串作为结尾，包含状态为 $s$ 的最短母串长度，使用类似链表的方式维护前驱节点进行求解。时间复杂度 $O(n\cdot|s|\cdot2^n)$

[***AC 代码***](https://www.luogu.com.cn/record/225439762)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

struct AhoCorasick {
    static constexpr int ALPHABET = 26;
    struct Node {
        int len;
        int link;
        array<int,ALPHABET> next;
        Node(): len{0}, link{0}, next{} { }
    };

    vector<Node> t;

    AhoCorasick() {
        init();
    }

    void init() {
        t.assign(2, Node());
        t[0].next.fill(1);
        t[0].len = -1;
    }

    int newNode() {
        t.emplace_back();
        return t.size() - 1;
    }

    int add(const string &a) {
        int p = 1;
        for (auto c: a) {
            int x = c - 'A';
            if (t[p].next[x] == 0) {
                t[p].next[x] = newNode();
                t[t[p].next[x]].len = t[p].len + 1;
            }
            p = t[p].next[x];
        }
        return p;
    }

    void work() {
        queue<int> q;
        q.push(1);

        while (!q.empty()) {
            int x = q.front();
            q.pop();

            for (int i = 0; i < ALPHABET; ++i) {
                if (t[x].next[i] == 0) {
                    t[x].next[i] = t[t[x].link].next[i];
                } else {
                    t[t[x].next[i]].link = t[t[x].link].next[i];
                    q.push(t[x].next[i]);
                }
            }
        }
    }

    int next(int p, int x) {
        return t[p].next[x];
    }

    int link(int p) {
        return t[p].link;
    }

    int len(int p) {
        return t[p].len;
    }

    int size() {
        return t.size();
    }
};

void solve()
{
	int n;
	cin >> n;

    AhoCorasick AC;
    vector<int> pos(n + 1);
    for (int i = 1; i <= n; ++i) {
        string s;
        cin >> s;
        pos[i] = AC.add(s);
    }
    AC.work();
    int tot = AC.size();

    vector<int> msk(tot);
    vector vis(tot, vector<bool>(1<<n));
    for (int i = 1; i <= n; ++i) {
        msk[pos[i]] |= 1 << (i-1);
    }

    vector G(tot, vector<int>());
    for (int i = 2; i < tot; ++i) {
        G[AC.link(i)].push_back(i);
    }
    function<void(int)> dfs = [&](int u) -> void {
        for (auto v: G[u]) {
            msk[v] |= msk[u];
            dfs(v);
        }
    };
    dfs(1);

    queue<pair<int,int>> q;
    q.emplace(1, 0);
    vis[1][0] = 1;

    int cur = 0;
    vector<pair<int,int>> stk;

    while (!q.empty()) {
        auto [p, stat] = q.front(); q.pop();
        ++cur;
        if (stat == (1<<n) - 1) {
            string ans;
            for (int u = cur; u > 1; u = stk[u-2].first) {
                // cerr << u << " ";
                ans += 'A' + stk[u-2].second;
            }
            reverse(ans.begin(), ans.end());
            cout << ans << "\n";
            return;
        }

        for (int i = 0; i < 26; ++i) {
            int np = AC.next(p,i);
            if (!vis[np][stat | msk[np]]) {
                q.emplace(np, stat | msk[np]);
                vis[np][stat | msk[np]] = 1;
                stk.emplace_back(cur, i);
            }
        }
    }
    assert(false);
}

int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
	int t = 1;
	// cin >> t;
	while (t--) { solve(); }
}
```
