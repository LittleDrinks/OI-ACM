---
tags:
  - 题解
  - 构造
aliases:
  - Minimize Fixed Points
---
## [CF2123F. Minimize Fixed Points](https://codeforces.com/problemset/problem/2123/F)

如果一个数在优秀排列的限制下仍然需要成为不动点，那么它在 $[1,n]$ 内没有其他因数和倍数。
质数 $x$ 满足 $x\le n$ 并且 $2x>n$，那么 $x$ 必须是一个不动点。
尝试构造一个只有这些不动点的优秀排列。从大到小遍历所有非不动点质数，将其所有倍数放到一个环上，然后右移一位即可。

[***AC 代码***](https://codeforces.com/contest/2123/submission/331802446)

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

vector<int> sieve(int n)
{
	vector<bool> vis(n+1);
    vector<int> mP(n+1,1);
	vector<int> prime;
	vis[1] = 1;
	for (int i = 2; i <= n; ++i) {
		if (!vis[i]) {
            prime.push_back(i); 
            mP[i] = i;
        }
		for (auto p: prime) {
			if (i*p > n) { break; }
			vis[i*p] = 1;
            mP[i*p] = p;
			if (i%p == 0) { break; }  // 线性筛关键优化
		}
	}
	return prime;
}

void solve()
{
	int n;
	cin >> n;
    vector<int> p(n+1);
    
    auto Prime = sieve(n);
    reverse(Prime.begin(), Prime.end());
    
    for (auto x: Prime) {
        vector<int> cyc;
        for (int i = x; i <= n; i += x) {
            if (!p[i]) {
                cyc.push_back(i);
            }
        }
        int siz = cyc.size();
        for (int i = 0; i < siz; ++i) {
            p[cyc[i]] = cyc[(i+1)%siz];
        }
    }

    for (int i = 1; i <= n; ++i) {
        if (!p[i]) { p[i] = i; }
        cout << p[i] << " \n"[i == n];
    }
}

int main()
{
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
	int t = 1;
	cin >> t;
	while (t--) { solve(); }
}

```
