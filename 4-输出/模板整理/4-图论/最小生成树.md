---
tags:
  - 模板
---
kruskal 时间复杂度为 $O(m\log m)$
```cpp
int n, m;
vector<pii> G[N];
int kruskal()
{   // 默认是一张连通图
	vector <array<int,3>> e(m);
	for (auto& [w, u, v]: e) { cin >> u >> v >> w; }
	sort(e.begin(), e.end());
	int ans = 0, cnt = 0;
	d = dsu(n);  // 见并查集模板
	for (auto& [w, u, v]: e) {
		if (d.find(u) != d.find(v)) {
			d.merge(u, v);
			ans += w;
			++cnt;
			// 以下两行为建图，完成后 G 中存放了最小生成树
			G[u].push_back( { v, w } );
			G[v].push_back( { u, w } );
		}
		if (cnt == n-1) { break; }
	}
	return ans;
}
```
Prim
```cpp
struct node {
    ll v, w;
};
set<pll> q;
vector<node> edge[N];
bool is[N];
ll dis[N];
ll prim() {
    int tot = 0;
    ll ans = 0;
    memset(is, 0, sizeof(is));
    for (int i = 1; i <= n; i++) {
        dis[i] = 1e18;
    }
    dis[1] = 0;
    q.clear();
    for (int i = 1; i <= n; i++) {
        q.insert({dis[i], i});
    }
    while (!q.empty()) {
        int x = q.begin()->second;
        q.erase(q.begin());
        if (dis[x] == 1e18) {
            break;
        }
        tot++;
        ans += dis[x];
        is[x] = 1;
        for (auto j : edge[x]) {
            if (!is[j.v] && j.w < dis[j.v]) {
                q.erase({dis[j.v], j.v});
                dis[j.v] = j.w;
                q.insert({dis[j.v], j.v});
            }
        }
    }
    if (tot != n) {
        return -1;
    } else {
        return ans;
    }
}
```