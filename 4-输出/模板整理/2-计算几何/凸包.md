判断点是否在凸包内；旋转卡壳。
```cpp
struct Convex: Polygon {
	using Polygon::Polygon;
	// 求平面点集的凸包
	// Andrew 算法，时间复杂度 O(nlogn)
	Convex(vector<Point> p) {
        if (p.empty()) { return; }
        sort(p.begin(), p.end());
        auto check = [&](Point u){
            Point p1=back(), p2=*prev(end(),2);
            return sgn((p1-p2)^(u-p1))<=0;
        };
        for (const Point &u: p) {
            while (size()>1 && check(u)) { pop_back(); }
            push_back(u);
        }
        size_t k = size();
        p.pop_back(); reverse(p.begin(),p.end());
        for (const Point &u: p) {
            while (size()>k && check(u)) { pop_back(); }
            push_back(u);
        }
        pop_back();
    }
    // 判断点是否在凸包内
	bool inConvex(Point p) {
	    int cnt = 0;
	    for (size_t i = 0; i < size(); ++i) {
	        Point p1 = (*this)[i], p2 = (*this)[nxt(i)];
	        if (Line(p1,p2).onSegment(p)) { return true; }
	        cnt += toLeft(p1, p2, p);
	    }
	    if (abs(cnt) == n) { return true; }
	    else { return false; }
	}
	// 旋转卡壳
	template<typename F> void rotcaliper(const F&& func) {
	    auto &p = *this;
	    auto area = [](Point u, Point v, Point w){ return abs((w-u)^(w-v)); };
	    for (size_t i=0, j=1; i < size(); ++i) {
	        func(p[i], p[nxt(i)], p[j]);
	        while (area(p[nxt(j)],p[i],p[nxt(i)]) >= area(p[j],p[i],p[nxt(i)])) { 
	            j = nxt(j);
	            func(p[i], p[nxt(i)], p[j]);
	        }
	    }
	}
	// 旋转卡壳运用：求凸包直径
	T diameter2() {
	    auto &p = *this;
	    if (size() == 1) { return 0; }
	    if (size() == 2) { return (p[0]-p[1]).len2(); }
	    T ans = 0;
	    rotcaliper([&](Point a, Point b, Point c){
	        ans = max( { ans, (a-c).len2(), (b-c).len2() } );
	    }); 
	    return ans;
	}
};
```
旋转卡壳运用：最小矩形覆盖
```cpp
pair<db,Polygon> rotcaliper(Convex &&p)
{
    db ans = inf;
    Polygon ansp;
    auto area = [](Point a, Point b, Point c) { return fabs((c-a)^(c-b)); };
    for (int i=0, j=1, l=-1, r=-1; i<(int)p.size(); ++i) {
        while (area(p[p.nxt(j)],p[i],p[p.nxt(i)]) >= area(p[j],p[i],p[p.nxt(i)])) {
            j = p.nxt(j);
        }
        if (l == -1) { l=i; r=j; }
        Point v = p[p.nxt(i)]-p[i];
        v = Point(-v.y, v.x);
        while (sgn(v^(p[p.nxt(l)]-p[l])) <= 0) { l = p.nxt(l); }
        while (sgn(v^(p[p.nxt(r)]-p[r])) >= 0) { r = p.nxt(r); }
        Line li(p[i], p[p.nxt(i)]-p[i]), lj(p[j], p[i]-p[p.nxt(i)]);
        Line ll(p[l], v), lr(p[r], v);
        Polygon now = {
            getIntersection(li, ll),
            getIntersection(ll, lj),
            getIntersection(lj, lr),
            getIntersection(lr, li)
        };
        if (sgn(now.area()-ans) < 0) {
            ans = now.area();
            ansp = now;
        }
    }
    return {ans,ansp};
}
```
