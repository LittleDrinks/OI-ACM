```cpp
using T = db;
struct Point {
    T x, y, z;
    Point(T x=0, T y=0, T z=0): x(x), y(y), z(z) {}
    friend istream& operator>> (istream& is, Point &p) {
        T a, b, c;
        is >> a >> b >> c;
        db len = sqrtl(a*a + b*b + c*c);
        p.x = a * r / len;
        p.y = b * r / len;
        p.z = c * r / len;
        return is;
    }
    Point operator+ (Point p) { return Point(x+p.x, y+p.y, z+p.z); }
    Point operator- (Point p) { return Point(x-p.x, y-p.y, z-p.z); }
    Point operator* (db k) { return Point(x*k, y*k, z*k); }
    Point operator/ (db k) { return Point(x/k, y/k, z/k); }
    T operator* (Point p) { return x*p.x + y*p.y + z*p.z; }
    Point operator^ (Point p) {
        return Point(
            y*p.z - z*p.y,
            z*p.x - x*p.z,
            x*p.y - y*p.x
        );
    }
    T len2() { return (*this)*(*this); }
    db len() { return sqrtl(len2()); }
};
T mul(Point a, Point b, Point c) {
    return (a ^ b) * c;
}
bool onPlain(Point a, Point b, Point c) {
    return sgn(mul(a,b,c)) == 0;
}
bool hasIntersection(Point p, Point S, Point T) {
    Point n = S ^ T;
    db cross_S_p = (S ^ p) * n;
    db cross_p_T = (p ^ T) * n;
    return sgn(cross_S_p) >= 0 && sgn(cross_p_T) >= 0;
}
db getAng(Point a, Point b) {
    return fabs(atan2( (a^b).len(), a*b ));
}
```