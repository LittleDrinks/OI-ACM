如题，你需要维护这样的一个长度为 $N$ 的数组，支持如下两种操作：

1. 在某个历史版本上修改某一个位置上的值。输入格式为 `v 1 p c`，即为在版本 $v$ 的基础上，将 $a_{p}$ 修改为 $c$。
2. 访问某个历史版本上的某一位置的值。输入格式为 `v 2 p`，即访问版本 $v$ 中的 $a_{p}$ 的值，注意：**生成一样版本的对象应为 $v$**。

```
5 10
59 46 14 87 41
0 2 1
0 1 1 14
0 1 1 57
0 1 1 88
4 2 4
0 2 5
0 2 4
4 2 1
2 2 2
1 1 5 91
---
59
87
41
87
88
46
```

```cpp
#define m ((l+r)>>1)
const int N=1e6, M=1e6;
int root[M+5];
struct segmentTree {
    int cnt;
    struct node {
        int lson, rson, s;
    } a[N*40+5];
    void build(int &rt, int l, int r, const vector<int>& val) {
        rt = ++cnt;
        if (l == r - 1) { a[rt].s = val[l]; return; }
        build(a[rt].lson, l, m, val);
        build(a[rt].rson, m, r, val);
    }
    void update(int &rt, int l, int r, int p, int x) {
        a[++cnt] = a[rt]; rt = cnt;
        if (l == r - 1) { a[rt].s = x; return; }
        if (p < m) { update(a[rt].lson, l, m, p, x); }
        else       { update(a[rt].rson, m, r, p, x); }
    }
    int query(int rt, int l, int r, int p) {
        if (l == r - 1) { return a[rt].s; }
        if (p < m) { return query(a[rt].lson, l, m, p); }
        else       { return query(a[rt].rson, m, r, p); }
    }
} t;
#undef m

void solve()
{
	int n, m;
	cin >> n >> m;
    vector<int> a(n+1);
    for (int i = 1; i <= n; ++i) { cin >> a[i]; }
    t.build(root[0], 0, n+1, a);
    for (int i = 1; i <= m; ++i) {
        int v, op; cin >> v >> op;
        root[i] = root[v];
        if (op == 1) {
            int p, c;
            cin >> p >> c;
            t.update(root[i], 0, n+1, p, c);
        } else {
            int p; cin >> p;
            cout << t.query(root[i], 0, n+1, p) << "\n";
        }
    }
}

```