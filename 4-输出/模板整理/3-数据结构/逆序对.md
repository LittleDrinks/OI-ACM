---
tags:
---
归并排序解决静态逆序对问题。
```cpp
ll msort(vector<int> &a, int l, int r)
{
    if (l == r) { return 0; }
    int mid = (l + r) >> 1;
    ll ans=0;
    ans += msort(a, l, mid);
    ans += msort(a, mid+1, r);
    int i=l, j=mid+1;
    vector<int> b;
    while (i <= mid && j <= r) {
        if (a[i] <= a[j]) { b.push_back(a[i++]); }
        else              { b.push_back(a[j++]); ans+=mid-i+1; }
    }
    while (i <= mid) { b.push_back(a[i++]); }
    while (j <= r)   { b.push_back(a[j++]); }
    copy(b.begin(), b.end(), a.begin()+l);
    return ans;
}
```
树状数组解决静态逆序对问题。
```cpp
ll ans = 0;
for (int i = 0; i < n; ++i) {
    ans += t.query(n)-t.query(p[a[i]]);
    t.modify(p[a[i]], 1);
}
```
分块解决动态逆序对问题。
```cpp
//CF1830E
#include <bits/stdc++.h>
using namespace std;

const int MAXN=5e5+5;
const int K=3162;
int n,q,p[MAXN],t[MAXN],sz[3162],szblock;
pair<int,int>a[162][K+5]; // first是val ； second 是 这个元素在原有p排列中的位置 
long long tot=0,sum=0;

int lowbit(int x){ return x&-x; }
int query(int i){
    int ret=0;
    for(;i;i-=lowbit(i)) ret+=t[i];
    return ret;
}
void modify(int i){
    for(;i<=n;i+=lowbit(i)) t[i]++;
}

long long solve(int l,int r){
	// bell:belong_l l在哪个块   
	// posl表示l在bell块中是第几个 
    int bell=(l-1)/K+1,belr=(r-1)/K+1;
    int posl=lower_bound(a[bell]+1,a[bell]+sz[bell]+1,make_pair(p[l],0))-a[bell];
    int posr=lower_bound(a[belr]+1,a[belr]+sz[belr]+1,make_pair(p[r],0))-a[belr];
    if(bell==belr){
        for(int i=l+1;i<r;i++){
            if(p[i]<p[l]) sum--;
            else          sum++;
            if(p[i]>p[r]) sum--;
            else          sum++;
        }
        a[bell][posl].second=r;	
        a[belr][posr].second=l;
    }else{
        for(int i=1;i<=sz[bell];i++)				//bel_l这个散块 对 答案的影响 
            if(a[bell][i].second>l){
                if(a[bell][i].first<p[l]) sum--;
                else                      sum++;
                if(a[bell][i].first<p[r]) sum++;
                else                      sum--;
            }
        for(int i=1;i<=sz[belr];i++)				//bel_r这个散块 对 答案的影响  
            if(a[belr][i].second<r){
                if(a[belr][i].first>p[r]) sum--;
                else                      sum++;
                if(a[belr][i].first>p[l]) sum++;
                else                      sum--;
            }
        for(int i=bell+1,pos;i<belr;i++){			//处理中间所有整块 
            pos=lower_bound(a[i]+1,a[i]+sz[i]+1,make_pair(p[l],0))-a[i];
            sum=sum-(pos-1)+(sz[i]-pos+1);
            pos=lower_bound(a[i]+1,a[i]+sz[i]+1,make_pair(p[r],0))-a[i];
            sum=sum+(pos-1)-(sz[i]-pos+1);
        }
        a[bell][posl].first=p[r];					//交换两个元素的位置，并维护每个块的有序性 
        if(p[r]>p[l]){
            while(a[bell][posl]>a[bell][posl+1] && posl<sz[bell]){
                swap(a[bell][posl],a[bell][posl+1]);
                posl++;
            }
        }else{
            while(a[bell][posl]<a[bell][posl-1] && posl>1){
                swap(a[bell][posl],a[bell][posl-1]);
                posl--;
            }
        }
        a[belr][posr].first=p[l];
        if(p[l]>p[r]){
            while(a[belr][posr]>a[belr][posr+1] && posr<sz[belr]){
                swap(a[belr][posr],a[belr][posr+1]);
                posr++;
            }
        }else{
            while(a[belr][posr]<a[belr][posr-1] && posr>1){
                swap(a[belr][posr],a[belr][posr-1]);
                posr--;
            }
        }
    }
    if(p[l]<p[r]) sum++;								//计算相互之间产生的逆序对 
    else          sum--;
    tot=tot-abs(l-p[l])-abs(r-p[r])+abs(l-p[r])+abs(r-p[l]);
    swap(p[l],p[r]);
    return tot-sum;
}

int main(){
    cin>>n>>q;
    for(int i=1;i<=n;i++){
        cin>>p[i];
        modify(p[i]);
        sum+=i-query(p[i]);
        a[(i-1)/K+1][(i-1)%K+1]=make_pair(p[i],i);
        sz[(i-1)/K+1]++;
        tot+=abs(i-p[i]);
    }
    szblock=(n-1)/K+1;
    for(int i=1;i<=szblock;i++) sort(a[i]+1,a[i]+sz[i]+1);
    while(q--){
        int l,r;
        cin>>l>>r;
        cout<<solve(l,r)<<endl;
    }
}
```