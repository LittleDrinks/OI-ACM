**阶的定义：**$a$ 的阶 $(ord_n a)$ 是满足方程 $a^x \equiv 1 \pmod{n}$ 的最小正整数解
**定理 1：** 设正整数 $x$，满足 $a^x \equiv 1 \pmod{n}$ 则 $ord_n a\mid x$ ，因此有 $\phi(n)$ 被 $ord_n a$ 整除
**原根的定义**：若 $a$ 与 $n$ 是互素正整数，且 $\phi(n)=ord_n a$，那么称 $a$ 是 $\bmod n$ 的原根
**定理 2：** 设 $g$ 为 $\bmod n$ 的原根，则 $g, g^2, g^3, \ldots, g^{\varphi(n)}$ 这 $\varphi(n)$ 个数构成 $\bmod n$ 的缩系。
**定理 3：** 如果 $ord_n a = t$，$u$ 是正整数，那么 $ord_n (a^u)=\dfrac{t} { (t, u)}$   
**定理 4：** 如果 $\bmod n$ 有原根 $g$，那么 $\bmod n$ 有 $\phi(\phi( n))$ 个不同的原根，这些原根可以写成 $g^u$ ，其中u是 $1,2,…,\phi(n)$ 中与 $phi(n)$ 互质的数
**定理 5：** 仅有 $1,2,4$ 或奇素数 $p^α$ 及 $2p^α$ 有原根，其它的数都没有原根。

找出 n 的所有原根（定理 4 和定理 5）
```cpp
const int N = 1e6 + 1;
vector<int>check(N);
void solve() {
	int n, g= -1;
	cin >> n;
	if (!check[n]) {
		cout << "0\n\n";
		return;
	}
	int phi_n = euler_phi(n);
	auto order = [&](int x) {//求x的阶
		int ord = 0, tmp = 1;
		while (1) {
			ord++;
			tmp *= x;
			tmp %= n;
			if (tmp == 1)return ord;
		}
		};
	for (int a = 1; a <= n; a++) {
		if (gcd(a,n) ==1 && order(a) == phi_n) {
			g = a;
			break;
		}
	}
	vector<int> ans;
	if (g != -1) {
		int tmp = 1;
		for (int i = 1; i <= phi_n; i++) {
			tmp *= g;
			tmp %= n;
			if (gcd(phi_n, i) == 1)ans.push_back(tmp);
		}
	}
}

//check数组构造
check[2] = 1;
check[4] = 1;
vector<int> prime = getPrime(N);
for (auto p : prime) 
	if (p % 2 == 1) {
		long long tmp = p;
		while (tmp < N) {
			check[tmp] = 1;
			if (2 * tmp < N)check[2 * tmp] = 1;
			tmp *= p;
		}
	}
```
