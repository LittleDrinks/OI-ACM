---
tags:
  - 模板
  - 计算几何
---
任意多边形。可以计算面积和回转数，根据回转数判断点是否在该多边形内。
```cpp
T area(const vector<Point> &p) {
	T s = 0;
	int n = p.size();
	for (size_t i = 0; i < n; ++i) {
		s += (p[i] ^ p[(i + 1) % n]);
	}
	return abs(s);
}
db circ(const vector<Point> &p) {
    db s = 0;
    int n = p.size();
    for (int i = 0; i < n; ++i) {
        s += (p[i] - p[(i + 1) % n]).len();
    }
    return s;
}
```
```cpp
struct Polygon: vector<Point> {
    using vector<Point>::vector;  // 直接使用 vector 的构造函数
    size_t nxt(size_t i) { return i+1==size()? 0: i+1; }
    size_t pre(size_t i) { return i==0? size()-1: i-1; }
    // Sunday's algorithm 光线回转法
    // 在整数范围内判断一个点是否在多边形（不保证凸包）内部
    // 亦可用于求某点相对于该多边形的回转数
    pair<bool,int> winding(Point p) {
        int wn = 0, n = this->size();
        for (int i = 0; i < n; ++i) {
            if (Line((*this)[i], (*this)[(i+1)%n]).onSegment(p)) {
            	return { true, -inf };
            }
            int k = Line((*this)[i], (*this)[(i+1)%n]).toLeft(p);
            int d1 = sgn((*this)[i].y - p.y);
            int d2 = sgn((*this)[(i + 1) % n].y - p.y);
            if (k>0 && d1<=0 && d2>0) { wn++; }
            if (k<0 && d2<=0 && d1>0) { wn--; }
        }
        return { wn!=0, wn };
    }
};
```
