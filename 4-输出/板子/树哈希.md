使用 xor shift 进行哈希混淆，计算有根树的哈希值。
对于无根树，选择以重心为根，计算哈希值最大的那一个。
```cpp
using ull = unsigned long long;
const ull msk = chrono::steady_clock::now().time_since_epoch().count();

// ull h(ull x) { return x * x * x * 1237123 + 19260817; }
// ull f(ull x) { return h(x & ((1 << 31) - 1)) + h(x >> 31); }
ull shift(ull x)
{
    x ^= msk;
    x ^= x << 13;
    x ^= x >> 7;
    x ^= x << 17;
    x ^= msk;
    return x;
}

ull has[N];
void getHash(int u, int fa) 
{
    has[u] = 1;
    for (auto v: G[u]) {
        if (v == fa) { continue; }
        getHash(v, u);
        has[u] += shift(has[v]);
    }
}
```
