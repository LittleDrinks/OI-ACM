给出一个长度为 $n$ 的数列 $A$，同时定义一个辅助数组 $B$，$B$ 开始与 $A$ 完全相同。接下来进行了 $m$ 次操作，操作有五种类型，按以下格式给出：

- `1 l r k`：对于所有的 $i\in[l,r]$，将 $A_i$ 加上 $k$（$k$ 可以为负数）。
- `2 l r v`：对于所有的 $i\in[l,r]$，将 $A_i$ 变成 $\min(A_i,v)$。
- `3 l r`：求 $\sum_{i=l}^{r}A_i$。
- `4 l r`：对于所有的 $i\in[l,r]$，求 $A_i$ 的最大值。
- `5 l r`：对于所有的 $i\in[l,r]$，求 $B_i$ 的最大值。

在每一次操作后，我们都进行一次更新，让 $B_i\gets\max(B_i,A_i)$。

```
5 6
1 2 3 4 5
3 2 5
1 1 3 3
4 2 4
2 3 4 1
5 1 5
3 1 4
---
14
6
6
11
```

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using db = long double;
using i128 = __int128;

const int N = 5e5 + 5;
const int inf = 2e9;

struct Info {
    ll s;
    int mx, se, cnt, his;
    Info() : s(-inf), mx(-inf), se(-inf), cnt(0), his(-inf) {
    }
    Info(int val) : s(val), mx(val), se(-inf), cnt(1), his(val) {
    }
    Info(ll s, int mx, int se, int cnt, int his)
        : s(s), mx(mx), se(se), cnt(cnt), his(his) {
    }
};

struct Lazy {
    int a1, a2, a3, a4;
    Lazy() : a1(0), a2(0), a3(0), a4(0) {
    }
    Lazy(int a1, int a2, int a3, int a4) : a1(a1), a2(a2), a3(a3), a4(a4) {
    }
};

#define lson (p << 1)
#define rson (p << 1 | 1)
#define m ((l + r) >> 1)
int vec[N + 5];
Info a[N * 4 + 5];
Lazy t[N * 4 + 5];
void push_up(int p) {
    a[p].s = a[lson].s + a[rson].s;
    a[p].mx = max(a[lson].mx, a[rson].mx);
    a[p].his = max(a[lson].his, a[rson].his);
    if (a[lson].mx == a[rson].mx) {
        a[p].se = max(a[lson].se, a[rson].se);
        a[p].cnt = a[lson].cnt + a[rson].cnt;
    } else if (a[lson].mx > a[rson].mx) {
        a[p].se = max(a[lson].se, a[rson].mx);
        a[p].cnt = a[lson].cnt;
    } else {
        a[p].se = max(a[lson].mx, a[rson].se);
        a[p].cnt = a[rson].cnt;
    }
}
void apply(int p, int l, int r, Lazy v) {
    a[p].s += 1LL * v.a1 * a[p].cnt;
    a[p].s += 1LL * v.a2 * (r - l - a[p].cnt);
    a[p].his = max(a[p].his, a[p].mx + v.a3);
    a[p].mx += v.a1;
    if (a[p].se != -inf) {
        a[p].se += v.a2;
    }

    int a1 = t[p].a1 + v.a1;
    int a2 = t[p].a2 + v.a2;
    int a3 = max(t[p].a3, t[p].a1 + v.a3);
    int a4 = max(t[p].a4, t[p].a2 + v.a4);
    t[p] = Lazy(a1, a2, a3, a4);
}
void spread_down(int p, int l, int r) {
    Lazy v = Lazy(t[p].a2, t[p].a2, t[p].a4, t[p].a4);
    int mx = max(a[lson].mx, a[rson].mx);
    apply(lson, l, m, (a[lson].mx == mx ? t[p] : v));
    apply(rson, m, r, (a[rson].mx == mx ? t[p] : v));
    t[p] = Lazy();
}
void build(int p, int l, int r) {
    if (l == r - 1) {
        a[p] = Info(vec[l]);
        return;
    }
    build(lson, l, m);
    build(rson, m, r);
    push_up(p);
}
void modify_add(int p, int l, int r, int x, int y, int k) {
    if (y <= l || r <= x) {
        return;
    }
    if (x <= l && r <= y) {
        a[p].s += 1LL * k * (r - l);
        a[p].mx += k;
        a[p].his = max(a[p].his, a[p].mx);
        if (a[p].se != -inf) {
            a[p].se += k;
        }
        t[p].a1 += k;
        t[p].a2 += k;
        t[p].a3 = max(t[p].a3, t[p].a1);
        t[p].a4 = max(t[p].a4, t[p].a2);
        return;
    }
    spread_down(p, l, r);
    modify_add(lson, l, m, x, y, k);
    modify_add(rson, m, r, x, y, k);
    push_up(p);
}
void modify_min(int p, int l, int r, int x, int y, int v) {
    if (y <= l || r <= x || v >= a[p].mx) {
        return;
    }
    if (x <= l && r <= y && a[p].se < v) {  // se < v < mx 的条件不分开会 RE
        a[p].s -= 1LL * a[p].cnt * (a[p].mx - v);
        t[p].a1 -= a[p].mx - v;
        a[p].mx = v;
        return;
    }
    spread_down(p, l, r);
    modify_min(lson, l, m, x, y, v);
    modify_min(rson, m, r, x, y, v);
    push_up(p);
}
ll query_sum(int p, int l, int r, int x, int y) {
    if (y <= l || r <= x) {
        return 0;
    }
    if (x <= l && r <= y) {
        return a[p].s;
    }
    ll s = 0;
    spread_down(p, l, r);
    s += query_sum(lson, l, m, x, y);
    s += query_sum(rson, m, r, x, y);
    push_up(p);
    return s;
}
int query_max(int p, int l, int r, int x, int y) {
    if (y <= l || r <= x) {
        return -inf;
    }
    if (x <= l && r <= y) {
        return a[p].mx;
    }
    int mx = -inf;
    spread_down(p, l, r);
    mx = max(mx, query_max(lson, l, m, x, y));
    mx = max(mx, query_max(rson, m, r, x, y));
    push_up(p);
    return mx;
}
int query_hismax(int p, int l, int r, int x, int y) {
    if (y <= l || r <= x) {
        return -inf;
    }
    if (x <= l && r <= y) {
        return a[p].his;
    }
    int mx = -inf;
    spread_down(p, l, r);
    mx = max(mx, query_hismax(lson, l, m, x, y));
    mx = max(mx, query_hismax(rson, m, r, x, y));
    push_up(p);
    return mx;
}
#undef lson
#undef rson
#undef m

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int n, q;
    cin >> n >> q;
    for (int i = 0; i < n; ++i) {
        cin >> vec[i];
    }
    build(1, 0, n);
    for (int _ = 1; _ <= q; ++_) {
        int o, l, r;
        cin >> o >> l >> r;
        --l;
        if (o == 1) {
            int k;
            cin >> k;
            modify_add(1, 0, n, l, r, k);
        } else if (o == 2) {
            int v;
            cin >> v;
            modify_min(1, 0, n, l, r, v);
        } else if (o == 3) {
            cout << query_sum(1, 0, n, l, r) << "\n";
        } else if (o == 4) {
            cout << query_max(1, 0, n, l, r) << "\n";
        } else {
            cout << query_hismax(1, 0, n, l, r) << "\n";
        }
    }
}

```