直接计算极角
```cpp
atan2(y, x);            // atan2(n, m) 表示以 m 为极轴，m 转向 n 为正方向
fmod(2*PI+ang(), 2*PI)  // 极角归一化 
```
所有点在一个半平面内
```cpp
bool argcmp(Point a, Point b) { return (a^b) > eps; }
```
全平面极角排序
```cpp
// 把全平面划分为：下半平面 < 原点 < x 正半轴 < 上半平面 < x 负半轴
bool argcmp(Point a, Point b) {  
    auto quad = [](const Point &a) {
		if (a.y < 0)       { return 1; }
        else if (a.y > 0)  { return 3; }
        else if (a.x >= 0) { return 2; }
        else               { return 4; }	
    };
    int qa = quad(a), qb = quad(b);
	if (qa == qb) {
	    ll cross = a^b;
	    if (cross == 0) { return abs(a.x) < abs(b.x); }
	    return cross > 0;
	}
	return qa < qb;
}

// STL 中使用 argcmp()，不要忘记传入 &argcmp 作为初始化变量
// 如果 argcmp() 使用 lambda 实现，类型应该为 decltype(argcmp)
set<Point,decltype(&argcmp)> evt{&argcmp};
map<Point,pair<ll,ll>,decltype(&argcmp)> evt{&argcmp};
priority_queue<Point,vector<Point>,decltype(&argcmp)> q{&argcmp};
```
