---
tags:
  - 输出
  - 线段树
  - 模板
---
懒标记线段树本质上是维护两个幺半群和三个三元操作，对应重载即可。
> [!quote] 【模板】线段树 2
> 已知一个数列，你需要进行下面三种操作：
> - 将某区间每一个数乘上 $x$；
> - 将某区间每一个数加上 $x$；
> - 求出某区间每一个数的和。
```cpp
#define lson (p << 1)
#define rson (p << 1 | 1)
#define m ((l+r)>>1)
template<typename Info, typename Lazy>
struct segmentTree {
    int n;
    vector<Info> a;
    vector<Lazy> t;

    segmentTree(int n): n(n), a(4 << __lg(n)), t(4 << __lg(n)) { }
    segmentTree(vector<Info>&& vec): segmentTree(vec.size()) {
        function<void(int,int,int)> build = [&](int p, int l, int r) -> void {
            if (r - l == 1) { a[p] = vec[l]; return; }
            build(lson, l, m);
            build(rson, m, r);
            push_up(p); 
        };
        build(1, 0, n);
    }

    void push_up(int p) {
        a[p] = a[lson] + a[rson];
    }

    void apply(int p, Lazy v) {
        a[p] = a[p] + v;
        t[p] = t[p] + v;
    }

    void spread_down(int p) {
        apply(lson, t[p]);
        apply(rson, t[p]);
        t[p] = Lazy();
    }

    template<typename F>
    Info dfs(int p, int l, int r, int x, int y, F&& op) {
        if (y <= l || r <= x) { return Info(); }
        if (x <= l && r <= y) { op(p,l,r); return a[p]; }
        spread_down(p);
        Info res;
        res = res + dfs(lson, l, m, x, y, op);
        res = res + dfs(rson, m, r, x, y, op);
        push_up(p);
        return res;
    }

    template<typename F>
    pair<int,Info> findFirst(int p, int l, int r, int x, int y, F&& pred) {
        if (y <= l || r <= x) { return {-1,Info()}; }
        if (x <= l && r <= y && !pred(a[p])) { return {-1,Info()}; }
        if (l == r-1) { return {l,a[p]}; }
        spread_down(p);
        pair<int,Info> res = findFirst(lson, l, m, x, y, pred);
        if (res.first == -1) {
            res = findFirst(rson, m, r, x, y, pred);
        }
        return res;
    }

    void modify(int x, int y, Lazy v) {
        dfs(1, 0, n, x, y+1, [&](int p, int l, int r){ apply(p, v); });
    }

    Info query(int x, int y) {
        return dfs(1, 0, n, x, y+1, [](int,int,int){});
    }
};
#undef lson
#undef rson
#undef m
struct Info {
    int len;
    ll s;
    Info(ll s=0, int len=1): s(s), len(len) { }
};
struct Lazy {
    ll a, m;
    Lazy(ll a=0, ll m=1): a(a), m(m) { }
};
Info operator+ (Info u, Info v) {
    return Info(add(u.s, v.s), add(u.len,v.len));
}
Info operator+ (Info u, Lazy v) {
    return Info(add(mul(u.s, v.m), mul(v.a, u.len)), u.len);
}
Lazy operator+ (Lazy u, Lazy v) {
    return Lazy(add(mul(u.a, v.m), v.a), mul(u.m, v.m));
}
```
