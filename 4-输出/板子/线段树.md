```cpp
#define lson (p << 1)
#define rson (p << 1 | 1)
#define m ((l+r)>>1)
template<typename Info>
struct segmentTree {
    int n;
    vector<Info> a;
    
    void push_up(int p) {
        a[p] = a[lson] + a[rson];
    }

    template<typename F>
    Info dfs(int p, int l, int r, int x, int y, F&& op) {
        if (y <= l || r <= x) { return Info(); }
        if (x <= l && r <= y) { op(p,l,r); return a[p]; }
        Info res;
        res = res + dfs(lson, l, m, x, y, op);
        res = res + dfs(rson, m, r, x, y, op);
        push_up(p);
        return res;
    }

	template<typename F>
	pair<int,Info> findFirst(int p, int l, int r, int x, int y, F&& pred) {
	    if (y <= l || r <= x) { return {-1,Info()}; }
	    if (x <= l && r <= y && !pred(a[p])) { return {-1,Info()}; }
	    if (l == r-1) { return {l,a[p]}; }
	    pair<int,Info> res = findFirst(lson, l, m, x, y, pred);
	    if (res.first == -1) {
	        res = findFirst(rson, m, r, x, y, pred);
	    }
	    return res;
	}
	
	template<typename F>
	pair<int,Info> findLast(int p, int l, int r, int x, int y, F&& pred) {
	    if (y <= l || r <= x) { return {-1,Info()}; }
	    if (x <= l && r <= y && !pred(a[p])) { return {-1,Info()}; }
	    if (l == r-1) { return {l,a[p]}; }
	    pair<int,Info> res = findLast(lson, m, r, x, y, pred);
	    if (res.first == -1) {
	        res = findLast(rson, l, m, x, y, pred);
	    }
	    return res;
	}

    segmentTree(int n = 0): n(n), a(4 << __lg(n)) { }
    segmentTree(vector<Info>&& b): segmentTree(b.size()) {
        function<void(int,int,int)> build = [&](int p, int l, int r) -> void {
            if (r - l == 1) { a[p] = Info(b[l]); return; }
            build(lson, l, m);
            build(rson, m, r);
            push_up(p);
        };
        build(1, 0, n);
    }

    void modify(int pos, int x) {
        dfs(1, 0, n, pos, pos+1, [&](int p, int l, int r){ a[p].mx = x; });
    }

    int query(int l, int r) {
        return dfs(1, 0, n, l, r+1, [](int,int,int){}).mx;
    }

    void Debug(int p, int l, int r) {
        // cerr << format("a[{}] = [ {}, {}, {} ]\n", p, l, r, a[p].mx);
        if (l == r - 1) { return; }
        Debug(lson, l, m);
        Debug(rson, m, r);
    }
};
#undef lson
#undef rson
#undef m
struct Info {
    int mx;
    Info(int mx = 0): mx(mx) { }
    friend Info operator+ (Info u, Info v) {
        return Info( max(u.mx, v.mx) );
    }
};
```
	