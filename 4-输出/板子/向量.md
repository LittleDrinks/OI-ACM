---
tags:
  - 模板
  - 计算几何
---
```cpp
using T = ll;
struct Point {
	T x, y;
    Point(T x=0, T y=0): x(x), y(y) {}
	friend istream& operator>> (istream& is, Point& p) { return is>>p.x>>p.y; }
	friend ostream& operator<< (ostream& os, Point& p) { return os<<p.x<<" "<<p.y; }
	db ang() { return atan2(y, x); }
	bool operator== (const Point &p) const { return sgn(x-p.x)==0 && sgn(y-p.y)==0; }
	bool operator< (const Point &p) const { return x<p.x || (x==p.x && y<p.y); }
	Point operator+ (const Point &p) const { return Point(x+p.x, y+p.y); }
    Point operator- (const Point &p) const { return Point(x-p.x, y-p.y); }
	Point operator* (const T &k) const { return Point(k*x, k*y); }
	Point operator/ (const T &k) const { return Point(x/k, y/k); }
	T operator* (const Point &p) const { return x*p.x + y*p.y; }
	T operator^ (const Point &p) const { return x*p.y - y*p.x; }  // 叉乘时打括号
	T len2() { return (*this)*(*this); }
	db len() { return sqrtl(len2()); }  // 等价于 hypotl(x, y)
	Point rot(db ang) { return Point(x*cos(ang)-y*sin(ang), x*sin(ang)+y*cos(ang)); }
	Point trunc(db l) { return (*this) * (l/len()); }
};

// 判断 c 是否在 ab 的逆时针方向
int toLeft(Point a, Point b, Point c) { return sgn((b-a)^(c-a)); }

// 二维向量夹角，注意特判垂直的情况
db getAngle(Point a, Point b) { return fabs(atan2(fabs(a^b), a*b)); }

// ab 夹角是否大于 uv
bool polarCmp(Point a, Point b, Point u, Point v)
{
    int qa = sgn(a*b);
    int qu = sgn(u*v);
    if (qa != qu) {
        return qa < qu;
    } else {
        return abs(a^b) * (u*v) > abs(u^v) * (a*b);
    }
}
```
